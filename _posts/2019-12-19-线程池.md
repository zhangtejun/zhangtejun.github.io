---
layout: post
title:  "Spring Security"
date:   2019-12-19 09:34:23
author: zhangtejun
categories: Java
---
#####
为了避免系统频繁的创建和销毁线程，可以让创建的线程复用。
* newFixedThreadPool() 该方法返回一个规定数量的线程池。池中线程数始终保持不变。当一个新任务提交时，如果池中有空闲线程，则立即执行。
如果没有，则新的任务将会被暂存在一个任务队列中，带有空闲线程时，便处理任务中的队列。
```
Executors.newFixedThreadPool(int nThreads);
```

* newSingleThreadExecutor() 该方法返回一个只有一个线程的线程池。如果多余任务被提交到线程池，
则将会被暂存在一个任务队列中，带线程空闲时，按先入先出的顺序执行队列中的任务。
```java
Executors.newSingleThreadExecutor();
```

* newCachedThreadPool() 该方法返回一个可缓存线程池，池中的线程数量（最大2147483647）不确定，有空闲线程可复用池中的线程，如果没有空闲线程，又有新任务提交，
将新建线程来处理。
```java
Executors.newCachedThreadPool();
```
* newSingleThreadScheduledExecutor() 该方法返回一个ScheduledExecutorService，线程池大小为1，该方法返回一个ScheduledExecutorService接口在该方法返回一个ExecutorService
接口上扩展了在给定时间执行任务的功能，比如在某个固定的延迟后执行，或者周期性执行某个任务。
```java
Executors.newSingleThreadScheduledExecutor();
```
* newScheduledThreadPool() 该方法也返回一个ScheduledExecutorService，但可以指定线程池中的线程数量。
```java
Executors. newScheduledThreadPool(int corePoolSize);
```


```java
// corePoolSize：指定线程池中的线程数量，maximumPoolSize：线程池中最大线程数量，keepAliveTime：当线程池中数量大于corePoolSize时，多余的线程空闲时间
// unit：keepAliveTime的单位，workQueue：任务队列，被提交尚未被执行的任务，threadFactory：线程工程，用于创建线程，一般默认即可。
// handler：拒绝策略。
 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue<Runnable> workQueue, ThreadFactory threadFactory) {
        this(corePoolSize, maximumPoolSize, keepAliveTime, unit, workQueue, threadFactory, defaultHandler);
    }
```

##### BlockingQueue
* SynchronousQueue 直接提交的队列，SynchronousQueue没有容量，每一个插入操作都需要等待一个相应的删除，反之，每一个删除操作也要等待对应的插入操作
即提交的任务不会被真实的保存，而总是将任务提交给线程执行，如果没空闲的线程，则尝试新建线程，如果线程数量已经达到最大，则执行拒绝策略。

* ArrayBlockingQueue 有阶的任务队列  若有新的任务需要执行，如果线程池d的实际线程数小于corePoolSize,则会优先创建新的线程，若大于corePoolSize
，则会将新的任务加入等待队列，若队列已满，无法加入，在总线程数不大于maximumPoolSize的情况下，创建新的任务继续执行，如果大于corePoolSize，则执行拒绝策略。

* LinkedBlockingQueue 无界的任务队列，和有阶队列相比较，除非系统资源耗尽，否则无界的任务不存在加入队列失败的情况。

* 优先任务队列  PriorityBlockingQueue 根据任务本身的优先级顺序先后执行。

##### JDK内置4种拒绝策略
* AbortPolicy: 直接抛出异常
* CallerRunsPolicy: 只要线程池未关闭，该策略直接在调用者线程中运行该任务。
* DiscardOldestPolicy: 将最老的一个请求丢弃，即即将被执行的任务。并尝试再次提交当前任务。
* DiscardPolicy: 直接丢弃无法处理的任务，不予如何处理。

以上策略均实现RejectedExecutorHandler接口


##### 扩展线程池
ThreadPoolExecutor是一个可以扩展的线程池，它提供beforeExecutor(),afterExecutor()和terminated() 三个接口来对线程池进行控制。

##### Fork/Join
```java
public <T> ForkJoinTask<T> submit(ForkJoinTask<T> task) {
    if (task == null)
        throw new NullPointerException();
    forkOrSubmit(task);
    return task;
}
```

可以向ForkJoinPool提交一个ForkJoinTask任务（即支持fork()方法分解和join()方法等待的任务），ForkJoinTask有2个重要的子类，
RecursiveAction和RecursiveTask类，他们分别代表没有返回值的任务和可以携带返回值的任务。


#####
* 锁偏向 锁偏向是一种争对j加锁操作的优化手段，其思想是：如果一个线程获得了锁，那么锁就进入偏向模式，当这个线程再次请求锁时，
无须再做任何同步操作。这样可以节省大量有关锁的申请操作。当每次都是不同的线程来请求相同的锁，这时偏向模式会失败。

* 轻量级锁 如果偏向锁失败，虚拟机不会立即挂起线程，它还会使用一种称为轻量级锁的优化手段。其操作为：它只是简单的把对象头部作为
指针指向持有锁的线程堆栈内部，来判断一个线程是否持有对象锁。如果线程获取轻量级锁成功，则可以顺利进入临界区，如果加锁失败，说明其他线程
已获得该锁，那么当前线程请求的锁会膨胀成重量级锁。

* 自旋锁 锁膨胀后，位了避免线程真实的在操作系统上挂起，虚拟机还会做最后的努力（自旋锁），虚拟机会让当前线程z做几个空循环，在经过若干次循环后，
还不能获取到锁，才会将线程在系统层面上进行挂起。

* 锁消除 锁消除是一种更加彻底的锁优化，java虚拟机在JIT编译时，通过对上下文的扫描，去除不可能存在的共享资源竞争的锁。这样可以节省无意义的请求时间。


##### CAS
算法过程：它包含3个参数CAS(V,E,N),其中V表示要更新的变量，E表示预期值，N表示新值。仅当V值等于E时,才会将V设置成N，如果
V和E不同，说明其他线程做了更新，则当前线程什么都不做。最后CAS返回当前V的真实值。


