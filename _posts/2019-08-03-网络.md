---
layout: post
title:  "网络"
date:   2019-08-03 20:53:01
author: zhangtejun
categories: Java
---
##### TCP/IP
TCP/IP体系结构即TCP/IP的4层协议：
* 应用层：各种应用层协议（HTTP,FTP,SMTP等）
* 传输层：传输层为相互通信的应用进程提供逻辑通信。主要协议TCP,UDP。应用所有的应用进程都可以通过传输层传送到网络层（IP层）
  即复用，传输层从IP层收到数据必须交付给相应的应用层，即分用。为了能够使运行在不同操作系统的进程可以相互通信，必须使用一种和系统无光的方法
  来标志进程，即再传输层使用协议端口号来绝决这个问题。
  每一条TCP连接有2个端点，该端点不是主机也不是ip,不是进程，也不是传输层的协议端口，TCP的端点叫套接字（socket）或者插口。端口好拼接到IP地址
  构成套接字。

* 网络层：实现2个系统间数据的透明传输，即寻址，路由等，网际IP协议通常使用ARP协议，ICMP,IGMP通常使用IP协议，向上层提供简单灵活，无连接的数据交付服务，可靠性有传输层负责。

* 链路层：对于数据链路，物理层，


TCP/IP协议族按照层次由上到下，层层包装。最上面的是应用层，这里面有http，ftp 等等我们熟悉的协议。
而第二层则是传输层，著名的TCP和UDP协议就在这个层次。
第三层是网络层，IP协议就在这里，它负责对数据加上IP地址和其他的数据以确定传输的目标。
第四层是数据链路层，这个层次为待传送的数据加入一个以太网协议头，并进行CRC编码，为最后的数据传输做准备。

数据发送方每层不断地封装首部与尾部，添加一些传输的信息，确保能传输到目的地。数据接收方每层不断地拆除首部与尾部，得到最终传输的数据。


##### 数据链路层

物理层负责0、1比特流与物理设备电压高低、光的闪灭之间的互换。数据链路层负责将0、1序列划分为数据帧从一个节点传输到临近的另一个节点,
         这些节点是通过MAC来唯一标识的(MAC,物理地址，一个主机会有一个MAC地址)。

1. 封装成帧: 把网络层数据报加上相应头和尾（以太网首部），封装成帧,帧头中包括源MAC地址和目的MAC地址。

2. 透明传输: 零比特填充、转义字符。

3. 可靠传输: 在出错率很低的链路上很少用，但是无线链路WLAN会保证可靠传输。

4. 差错检测(CRC):接收者检测错误,如果发现差错，丢弃该帧。

##### 数据链路层
1. IP协议： IP协议是TCP/IP协议的核心，所有的TCP，UDP，IMCP，IGMP的数据都以IP数据格式传输。要注意的是，IP不是可靠的协议，
           这是说，IP协议没有提供一种数据未传达以后的处理机制，这被认为是上层协议：TCP或UDP要做的事情。

1.1  IP地址： 数据链路层中我们一般通过MAC地址来识别不同的节点，而在IP层我们也要有一个类似的地址标识，这就是IP地址。

32位IP地址分为网络位和地址位，这样做可以减少路由器中路由表记录的数目，有了网络地址，就可以限定拥有相同网络地址的终端都在同一个范围内，
那么路由表只需要维护一条这个网络地址的方向，就可以找到相应的这些终端了。           

IP地址分类：
* A类IP地址: 0.0.0.0~127.0.0.0
* B类IP地址: 128.0.0.1~191.255.0.0
* C类IP地址: 192.168.0.0~239.255.255.0
* D类地址: 用于组播（multicasting），因此，D类地址又称为组播地址。
* E类地址: 为保留地址，可以用于实验目的

一个A类IP地址是指， 在IP地址的四段号码中，第一段号码为网络号码，剩下的三段号码为本地计算机的号码。如果用二进制表示IP地址的话，
A类IP地址就由1字节的网络地址和3字节主机地址组成，网络地址的最高位必须是“0”,另外7比特可变的网络号可以标识128个网络`（0～127）`

B类IP地址: 前2段为网络号码，B类IP地址就由2字节的网络地址和2字节主机地址组成,第一个字节的最高2比特固定为10，另外14比特可变的网
络号可以标识2^14=16384个网络。16比特主机号可以标识65 536台主机，（2^16=65536）。
由于主机号不能为全0和全1，所以，每个B类网络最多可以容纳65534台主机。B类地址的第一个字节的取值范围为128～191。

C类IP地址: 前3段为网络号码，B类IP地址就由3字节的网络地址和1字节主机地址组成,第一个字节的最高3比特固定为110，
另外21比特可变的网络号可以标识2^21=2097152个网络。8比特主机号可以标识256台主机(2^8=256)，由于主机号不能为全0和全1。
所以，每个C类网络最多可以容纳254台主机。C类地址的第一个字节的取值范围为192～223。

1.2 IP协议头
{{ site.ip.jpeg | prepend: site.baseurl }}

一个Ip数据报由首部和数据2部分组成，首部前一部分固定长度（20字节），后一部分是一些可选字段，长度可变。

固定20字节包括：

1. 版本（4位），即IP协议的版本
2. 首部长度 （4位） 可标识最大10进制数为`2^4 - 1 =15`,该字段所表示的单位是32位字（1个32位字长是4个字节，可看着ip首部的一行）
   IP首部固定部分有20字节，除非含有选项部分。故最小长度为20字节。首部最长为15个32bit长度，即最大长度`4(字节)x5 = 60`字节
   当IP首部长度不是4字节的整数倍时，必须使用填充字段进行填充。
3. 区分服务/服务类型 （8位） 一般情况下不使用这个字段
4. 总长度 （16位） 指首部和数据之和的长度，单位是字节。总长度最大是65535个字节，实际很少有传这么大的数据报。
   数据链路层规定了一个数据帧中的数据字段的最大长度，即最大传送单元MTU(Maximum Transmission Unit)，当一个IP数据报封装成数据链路层的帧时，
   此数据报的藏长度不能大于MTU值，例如常见的以太网规定其MTU为1500字节，如果传送的数据超过此MTU值，就需要把数据报进行分片处理。
5. 标识 （16位） IP软件在存储器中维护一个计数器，每产生一个数据报，计算器加1，并将此值赋给标识字段，当数据报长度超过MTU时，这个标识的值会被复制到所有的数据报片的标识字段中，
   相同的标识字段使分片后的各数据报最后能正确的重组成为原来的数据报。
6. 标志 （3位） 目前只有2位有意义，最低位为MF（More Fragment）。MF=1表示后面还有分片的数据报。MF=0表示这已经是若干分片数据报中的最后一个。
   中间一位记为DF(Don't Fragment),此值为0的时候表示数据报可以被分段,如果为1则不能被分片｡ 
7. 片偏移 （13位） 较长的分组在分片后，某片在原分组中的相对位置。片偏移以8个字节为单位，即每个分片的长度一定是8的整数倍
8. TTL （8位）这个字段规定该数据包在穿过多少个路由之后才会被抛弃。某个IP数据包每穿过一个路由器，该数据包的TTL数值就会减少1，当该数据包的TTL成为零，它就会被自动抛弃。
   这个字段的最大值也就是255，也就是说一个协议包也就在路由器里面穿行255次就会被抛弃了，根据系统的不同，这个数字也不一样，一般是32或者是64。
9. 协议 （8位） 持出数据报所携带的数据使用的是哪种协议。在Linux系统的/etc/protocols文件中定义了所有上层协议对应的协议字段，ICMP为1，TCP为6，UDP为17。
10. 首部校验和 （16位） 这个字段只校验数据报的首部，不包括数据部分。这是因为数据报每经过一个路由器，路由器都要重新计算首部校验和（一些字段，如：TTL,标志,片偏移等）
     由发送端填充接收端对其使用CRC算法校验，检查IP数据报头部在传输过程中是否损坏。在发送端的时候，将校验和全部设置为0，然后把数据报首段数据全部进行反码相加，
     得到的值为校验和，放入首部的校验和字段；然后在接收端的时候，将数据报首段数据和校验和一起全部反码相加，最后若是得到零，则保留，
     若不是零，则说明数据报在传输过程中发生了改变，则丢弃该数据报。
11. 源地址 （32位）     
12. 目的地址 （32位）   
13. 选项 可以支持排错，测量，安全等，最多包含40字节。


传输控制协议TCP：提供可靠的服务，通过TCP传输的数据可以无差错，不重复，不丢失，并且按序到达。

TCP发送的报文是交给IP层传送的，IP层不提供可靠的传送，因此TCP必须采取相应的措施来使2个传输层的信道变得可靠。

理想传输条件：传输信道不产生差错，不管发送方以多大速度发送数据，接收方总来的及处理。

在理想传输条件下，不需要采取任何措施就可以保证传输的可靠性。

实际的网络中并不具备以上2个条件，都是我们可以提供一些可靠传输协议，当出现差错时让发送方重传，接收方来不及接收时，让发送方降低发送速率。




**停止等待协议**
全双工信道的通信双方即是发送方也是接收方，”停止等待“就是没发送完一个分组就停止发送，等待对方确认，确认后再发下一个分组。

优缺点：传输简单，但是信道利益率低，为了提高效率，发送方可以不使用停止等待协议，而采用流水线传输。即发送方一次发送多个分组，

使用流水先传输时，需要使用连续ARQ协议和滑动窗口协议。

发送方维持发送窗口，位于窗口内的分组可以连续发送出去，而不需要等待对方确认。
连续ARQ协议规定：发送方每收到一个确认，就把发送窗口向前移动一个分组的位置。接收方一般采用累加确定的方式，即接收方不必对收到的分组进行每一个确认
而是收到几个分组后，对按序到达的最后一个分组发送确认，表示改组之前的所有分组已正确收到。

累计确认的优缺点：容易实现，即使确定丢失也不必重传。但是不能向发送方反应已经正确接收到的所有分组信息。

TCP报文段的首部格式：一个TCP报文包括首部和数据2部分，而TCP的全部功能都体现在它的首部各字段中，首部的前20个字节是固定的，
后面有4n个字节是根据需要而增加的选项。因此TCP首部最小长度是20字节。

5行每行4字节，

* 源端口和目标端口各2字节，

* 序号4字节：指发送数据的位置，就累加该数据字节数大小，例如一段报文的序号字段是301，而携带数据共100字节，那么本报文最后一个字节序号是400。下一个报文
段的数据序号应该从401开始。

* 确认号：4字节，是期望收到对方下一个报文段的第一个数据字节的序号，例如B正确收到A发送过来的一个报文段，其序号是501，数据长度为200字节（501-700）
，这表明B正确接收到了A发送的到序号700为止的数据。因此B期望收到A下一个数据序号是701，于是B在发送给A的确认报文中把确认号设置为701。

* 第3行
   * 数据偏移：4位，实际上是指出TCP报文段的首部长度，因为首部中还有长度不明确的选项字段，该字段是必要的，
      它指出TCP报文段的数据起始出距离TCP报文段的起始处有多远。
   * 保留：占6位，保留为今后使用，暂时应设为0；
   * 控制位：占6位
     * URG：紧急，当URG=1时，说明紧急指针有效，它表面报文中有紧急数据，应尽快传递（高优先级数据），发送方TCP把紧急数据插入到本报文的最前面
       紧急后面仍然是普通数据。比如一些取消程序运行的指令等。
     * ACK：确认，当ACK=1时，确认字段才有效。TCP规定在连接建立之后，所有的传送报文都必须设置为1。
     * PSH：推送，2个进程通信时，有时一端的应用希望在键入下一个命令后就立即收到对方的响应，发送方将PSH设置为1，接收方收到后将尽快交付给接收应用程序
            而不再等待整个缓冲区都填满了后在往上交付。
     * RST：复位，当RST=1时，表明TCP连接出现了严重的差错（主机崩溃或其他原因），必须释放连接，然后重新建立连接。
     * SYN：同步，在连接建立时用来同步序号。
     * FIN：终止，用来释放连接，当FIN=1时，表明数据传输完成，并要求释放连接。
   * 窗口：2字节，指发送本报文段的一方的接收窗口（不是自己的发送窗口），该值告诉对方：从本报文段首部中的确认号算起，接收方目前允许
     对方发送的数据量，原因是因为接收方的数据缓存空间是有限的。该值经常动态变化。
* 校验和紧急指针，各占2字节，校验和检验的范围包括首部和数据2部分；紧急指针在URG=1时有效，它指出本报文中的紧急数据的字节数。

* 选项（第6行 如果有）：长度可变，最长40字节。当没有使用选项时，TCP首部就20字节。
   TCP最初只规定一种选项，即最大报文长度MSS，MSS为每个TCP报文中数据字段的最大长度。后续增加窗口扩大选项，时间戳等选项。
* 数据（最后一行）：


##### TCP连接的建立与终止

tcp是面向字节流的，TCP传输的数据是报文段，一个TCP报文段包含首部和数据，和IP数据报一样前20个固定字节首部。

TCP首部

* 源端口 （2字节=16位）
* 目的端口 （2字节=16位）
* 序号 （4字节=32位） 可对4GB的数据进行编号。
         tcp是面向字节流的，在tcp连接中每一个字节流都按顺编号，tcp数据段发送的第一个字节的序号,范围`[0,2^32 - 1]`
         当序号增加到2^32 - 1后，下一个序号又会回到0，整个要传送的字节流的起始序号必选字连接建立设置。
         例如,一个报文的序号seq = 301,携带的数据有100,那么本报文段的数据的第一个字节的序号就为301,最后一个字节的序号就为400，
         那么下一个报文段就应该从401开始。
* 确认号 （4字节=32位） 为期望收到对方下一个报文段的第一个数据字节序号。
         例如: B正确收到A发送来的一个报文段，其序号值是501，数据长度是200字节（序号501-700），这表面B收到了A发送序号为700为止的数据。
         因此B期望收到A的下一个序号为701的报文，于是在发送给A的确认报文中，将确认号置为701。
* 数据偏移 （4位） 因为占4位，最大值为15，因此数据最大偏移为60字节：即为tcp首部最大长度（即选项长度不能超过40字节）
          实际就是指定报文段的首部长度，因为首部有长度不明确的选项字段，因此该字段是必须的。
* 保留 （6位） 保留字段
* 6个控制位 （6位）
    * 紧急URG 当URG=1时，表明紧急指针有效，它告诉系统该报文段中有紧急数据，应该尽快传输，而不是按原有的排队顺序来传输。 
      比如正在传输的数据有问题，需要取消该程序运行，可发出中断命令（Control + C）
    * 确认ACK 当ACK=1时，确认号字段才有效。TCP规定在连接建立后使用传送报文的ACK都必须设置为1。
    * 推送PSH 该操作很少使用，当2个应用程序相互通信时，有时需要一端在键入一个命令后可以立即收到对方的响应。
             指示接收方应该尽快将这个报文段交给应用层而不用等待缓冲区装满。
    * 复位RST 当RST=1时，表明TCP连接中出现了严重的差错（主机崩溃或其他原因），必须释放连接，然后再重新建立连接。
              还可以用于拒绝非法的报文段和拒绝打开一个连接。
    * 同步SYN 当SYN=1，ACK=0时，表明是一个连接请求报文段，如果对方同意连接，则再响应报文中使用SYN=1,ACK=1。
              因此SYN=1表明这是一个连接请求或者连接接受请求。
    * 终止FIN 用来释放一个连接，当FIN=1 表明报文段的发送方数据已发送完毕，并要求释放连接。
* 窗口 （2字节）范围`[0,2^16 - 1]` 指发送本报文段的一方的接收窗口（而不是自己的发送窗口）。窗口值告诉对方：从本报文的确认号算起
              接收方允许对方发送的数据量。窗口值作为接收方让发送方设置其发送窗口的依据。
* 校验和 （2字节） 对整个的TCP报文段，包括TCP头部和TCP数据，
* 紧急指针 （2字节） 仅在URG=1时有效，它指出本报文中紧急数据的字节数（紧急数据结束后就是普通数据）。即使窗口为0，也可以发送紧急数据。
* 选项  长度可变，最大40字节，当没有使用选项时，TCP首部就是20字节。


A主动请求：
1. A的TCP进程首先创建传输控制模块（TCB），然后向B发出连接请求报文段，这时首部中的同步位 SYN=1 ，同时选择一个初始序列号seq=x,
TCP规定，SYN报文不能携带数据，但是要消耗一个序号，这时TCP客户端进入SYN_SENT(同步已发送)状态，等待服务器的确认。

2. B收到连接请求报文后，如果同意连接就向A发送确认报文，把SYN和ACK都置1，确认号ack=x+1，同时为自己选择一个序列号seq=y。这个报文也不能携带数据，
   也要消耗一个序号，这时TCP服务端进入SYN_RCVD（同步收到）状态。

3. A收到B的确认后，还要向B给出确认，确认报文段ACK=1,确认号ack=y+1,而自己的序号seq=x+1。TCP规定ACK报文段可以携带数据，如果不携带数据则不消耗序号，这种情况下，下一个数据报的
序号仍为seq=x+1。这时TCP连接已经建立，A进入ESTABLISHED（已建立连接状态）。 当B收到A的确认后，也进入ESTABLISHED状态。

5. A为什么要再发送一次确认？

为了防止已失效的连接请求报文段突然又传送到了服务端，因而产生错误。

client发出的第一个连接请求报文段并没有丢失，而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达server。
本来这是一个早已失效的报文段。但server收到此失效的连接请求报文段后，就误认为是client再次发出的一个新的连接请求。
于是就向client发出确认报文段，同意建立连接。假设不采用“三次握手”，那么只要server发出确认，新的连接就建立了。
由于现在client并没有发出建立连接的请求，因此不会理睬server的确认，也不会向server发送数据。但server却以为新的运输连接已经建立，
并一直等待client发来数据。这样，server的很多资源就白白浪费掉了。采用“三次握手”的办法可以防止上述现象发生。例如刚才那种情况，
client不会向server的确认发出确认。server由于收不到确认，就知道client并没有要求建立连接。”


**TCP连接的终止** 

1. A先向TCP发出释放连接报文段，并停止发送数据，主动关闭TCP连接，A把连接释放报文的设置为FIN=1，其序号seq=u，u等于前面已传输过数据的最后一个字节序号加1，这时A
进入FIN_WAIT_1(终止等待1)状态，等待B确认。TCP规定FIN报文即使不携带数据也会消耗一个序号。

2. B收到连接释放报文后即发出确认，确认号ack=u+1，这个报文段自己的序号是v，等于前面B已传送过的数据的最后一个字节的序号加1。然后B进入CLOSE_WAIT(关闭等待)状态，
TCP服务器进程这时应该通知应用程序，从A到B的这个方向的连接就释放了，这时TCP处于半关闭状态。即A已经没有数据要发送，B可能还有数据要接收，从B到A的这个方向连接并未关闭。
这个状态可能会持续一些时间。A收到来自B的确认后，就进入FIN_WAIT_2（终止等待2）状态，等待B发出连接释放报文段。

3. 如果B没有要向A发送的数据，应用程序就会通知TCP释放连接，这时B发出连接释放报文段FIN=1,B还必须重复发送上次已发送的确认后ack=u+1。
这时B进入LAST_ACK（最后确认）状态，等待A确认。

4. A再收到B发送的释放报文段后，必须对此发出确认，在确认报文中把确认号ack=w+1，而自己的序号seq=u+1（TCP标准，前面发送的FIN报文要消耗一个序号）,
然后A进入TIME_WAIT（时间等待）状态，此时TCP连接并没有断开，必须经过时间等待器设置的2MSL后，A才会进入到CLOSED状态。
MSL最大报文段寿命（RFC793建议设置为2分钟） B收到A发出的确认后，就会进入CLOSED状态。

5. 为什么要经过时间等待器设置的2MSL后，A才会进入到CLOSED状态？

第一，为保证A发送的最后一个ACK报文段能够到达B,这个报文段有可能丢失，因此处于LAST_ACK状态的B收不到对已发送的FIN+ACK报文段的确认，
B会超时重传这个FIN+ACK报文段，而A就可能在2MSL时间内收到这个重传的报文段，接着A会重传一次确认，重新启动计时器2MSL。最后A ,B都可以正常进入CLOSED状态。

第二，防止”已失效的连接请求报文“出现在本连接中。A在发送完最后一个ACK报文段后，再经过时间2MSL，就可以使本连接持续的时间内所产生的报文段都从网络中
消失。这样即使下一个新的连接中不会出现这种旧的请求报文段。如果主机1直接CLOSED，然后又再向主机2发起一个新连接，我们不能保证这个新连接与刚关闭的连接的端口号是不同的。
也就是说有可能新连接和老连接的端口号是相同的。一般来说不会发生什么问题，但是还是有特殊情况出现：假设新连接和已经关闭的老连接端口号是一样的，如果前一次连接的某些数据仍
然滞留在网络中，这些延迟数据在建立新连接之后才到达主机2，由于新连接和老连接的端口号是一样的，TCP协议就认为那个延迟的数据是属于新连接的，这样就和真正的新连接的数据包发
生混淆了。所以TCP连接还要在TIME_WAIT状态等待2倍MSL，这样可以保证本次连接的所有数据都从网络中消失。

除了时间等待计时器外TCP还有保活计时器，保活计时器使用在某些实现中，用来防止在两个TCP之间的连接出现长时期的空闲。
假定客户打开了到服务器的连接，传送了一些数据，然后就保持静默了。也许这个客户出故障了。在这种情况下，这个连接将永远地处理打开状态。
要解决这种问题，在大多数的实现中都是使服务器设置保活计时器。每当服务器收到客户的信息，就将计时器复位。超时通常设置为2小时。
若服务器过了2小时还没有收到客户端的信息，它就发送探测报文段。若发送了10个探测报文段，每一个相隔75秒，还没有响应就假定客户出了故障，因而就终止该连接。

```
cat  /proc/sys/net/ipv4/tcp_keepalive_time 
cat  /proc/sys/net/ipv4/tcp_keepalive_intvl  
cat  /proc/sys/net/ipv4/tcp_keepalive_probes  
```

##### TCP可靠传输的实现
**以字节流为单位的滑动窗口**
1. 虽然A的发送窗口是根据B的接收窗口设置的，但是在同一时刻并不能保证窗口总是保存一样的大小。
2. 对于不安序到达的数据如何处理，TCP通常把到达的数据先临时放到接收窗口中，等字节流中所缺少的字节收到后，再按序交付给上层应用。
3. TCP要求接收方有累计确认功能，这样可以减少开销。

假如A收到B发来的确认报文段，其中窗口大小是20字节，而确认号是31（这表明B期望收到下一个序号是31.而序号为30的已经收到），
A就根据这2个数据，构造自己的发送窗口（31+20 = 50）

发送窗口表示，在没有收到B的确认的情况下，A可以连续把窗口内的数据发送出去，凡是以发送的数据，在没有收到确认的情况之前都必须保留，已便超时重传使用

{{ site.tcp1.jpeg | prepend: site.baseurl }}

要描述一个发送窗口的状态需要3个指针：P1,P2,P3。指针都是指向字节的序号。
* 小于P1的是已发送并且已经收到的部分，大于P3的是不允许发送的部分
* P3-P1 = A的发送窗口
* P2-P1 = 已发送但是尚未收到确认的字节数
* P3-P2 = 允许发送但是尚未发送的字节数（可用窗口、有效窗口）

B的接收窗口大小是20，接收窗口内的序号(31-50)是允许接收的，B收到32和33的序号数据，这些数据没有按顺序到达，因为31序号没有收到（可能丢失了，也可能滞留在网络中）
B只能对按序接收到的数据中的最高序号给出确认，因此B发送的确认号仍然是31（即期望收到的序号），而不是32或33。


**超时重传**
TCP采用自适应算法，它记录报文的发出时间，以及收到相应确认的时间，时间差就是报文的往返时间RTT。TCP保留RTT的一个加权平均往返时间，
超时重传时间RTO应略大于加权平均往返时间。


**TCP流量控制**
假设A向B发送数据。在连接建立时，B告诉了A：“我的接收窗口是 rwnd = 400 ”(这里的 rwnd 表示 receiver window) 。
因此，发送方的发送窗口不能超过接收方给出的接收窗口的数值。请注意，TCP的窗口单位是字节，不是报文段。假设每一个报文段为100字节长，
而数据报文段序号的初始值设为1。大写ACK表示首部中的确认位ACK，小写ack表示确认字段的值ack。

