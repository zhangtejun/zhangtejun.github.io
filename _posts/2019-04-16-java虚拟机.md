---
layout: post
title:  "java虚拟机"
date:   2019-04-11 19:35:21
author: zhangtejun
categories: Java
---
#### 运行时数据区域
java虚拟机在执行java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。
* 程序计数器
    *




`java.lang.OutOfMemoryError: Java heap space` 是内存泄漏还是内存溢出

##### java堆溢出
Java堆用于存储对象实例，只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，
那么在对象数量到达最大堆的容量限制后就会产生内存溢出异常。

要解决这个区域的异常，一般的手段是先通过内存映像分析工具（如Eclipse Memory Analyzer）对Dump出来的堆转储快照进行分析，
重点是确认内存中的对象是否是必要的，也就是要先分清除到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）。

如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄露对象是通过怎样的路径与GC Roots相关联并导致
垃圾收集器无法自动回收他们的。掌握了泄漏对象的类型信息及GC Roots引用链的信息，就可以比较准确的定位出泄漏代码的位置。

如果不存在泄漏，换句话说，就是内存中的对象确实还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看
是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少的程序运行期的内存消耗。

##### 虚拟机栈和本地方法栈溢出
由于hotSpot虚拟机不区分虚拟机栈和本地方法栈，虽然参数-Xoss（设置本地方法栈大小）存在，但实际上无效，栈容量由-Xss参数设置。
在 Java 虚拟机规范中，对虚拟机栈这个区域规定了两种异常状况：
* 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError 异常；
* 如果虚拟机栈可以动态扩展（当前大部分的 Java 虚拟机都可动态扩展，只不过 Java 虚拟机规范中也允许固定长度的虚拟机栈），当扩
展时无法申请到足够的内存时会抛出 OutOfMemoryError 异常。

在单个线程下，无论是由于栈帧太大，还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是 StackOverflowError 异常，而不是OOM。
1. 使用参数-Xss减小栈内存容量。
2. 定义大量本地变量，增加此方法帧中本地变量表的长度。

##### 方法区和运行时常量池溢出(JDK 1.7开始逐步“去永久代”)
String.intern()是一个Native方法，它的作用是：如果字符串常量池中已经包含一个等于此String对象的字符串，则返回常量池中这个字符串的String
对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。在JDK 1.6及之前的版本中，由于常量池分配在`永久代`内，
我们可以通过-XX:PermSize和-XX:MaxPermSize限制方法区大小，从而间接限制其中常量池的容量

运行时常量池溢出，在OutOfMemoryError后面跟随的提示信息是“PermGen space”，说明运行时常量池属于方法区（HotSpot虚拟机中的永久代）的一部分。
```java
/**
 * VM Args：-XX:PermSize=10M -XX:MaxPermSize=10M
 */
public static void main(String[] args) {
    // 使用List保持着常量池引用，避免Full GC回收常量池行为
    List<String> list = new ArrayList<String>();
    // 10MB的PermSize在integer范围内足够产生OOM了
    int i = 0;
    while (true) {
        list.add(String.valueOf(i++).intern());
    }
}
// jdk1.6
Exception in thread "main" java.lang.OutOfMemoryError: PermGen space
at java.lang.String.intern(Native Method)
// 而使用JDK 1.7运行这段程序就不会得到相同的结果，while循环将一直进行下去。
```
方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。对于这些区域的测试，基本的思路是运行时产生大量的类去填满方法区，直到溢出。

intern用来返回常量池中的某字符串，如果常量池中已经存在该字符串，则直接返回常量池中该对象的引用。否则，在常量池中加入该对象，然后 返回引用。

在JDK 1.6中，intern()方法会把首次遇到的字符串实例复制到永久代中，返回的也是永久代中这个字符串实例的引用，而由StringBuilder创建的字符串实例在Java堆上，所以必然不是同一个引用。

而JDK 1.7的intern()实现不会再复制实例，只是在常量池中记录`首次出现`的实例引用，因此intern()返回的引用和由StringBuilder创建的那个字符串实例是同一个

```java
String s1 = new String("1"); // 同时会生成堆中的对象 以及常量池中1的对象，但是此时s1是指向堆中的对象的
s1.intern();// 常量池中的已经存在
String s2 = "1";
System.out.println(s1 == s2); // false

String s3 = new String("1") + new String("1");    // 此时生成了四个对象 常量池中的"1" + 2个堆中的"1" + s3指向的堆中的对象（注此时常量池不会生成"11"）
String intern = s3.intern();// jdk1.7之后，常量池不仅仅可以存储对象，还可以存储对象的引用，会直接将s3的地址存储在常量池
String s4 = "11";    // jdk1.7之后，常量池中的地址其实就是s3的地址
System.out.println(s3 == s4); // 结果jdk1.8 false（不同电脑结果不一致） 期望（jdk1.7false， jdk1.7之后true）
System.out.println(intern == s4);//jdk1.8 true

s3 = new String("2") + new String("2");
s4 = "22";        // 常量池中不存在22，所以会新开辟一个存储22对象的常量池地址
s3.intern();    // 常量池22的地址和s3的地址不同
System.out.println(s3 == s4); // false
```

方法区溢出也是一种常见的内存溢出异常。jdk 1.7的HotSpot中，已经把原本放在永久代的字符串常量池移出,在jdk1.7之前，字符串常量存储在方法区的PermGen Space。

当前主流的很多框架 如：Spring,Hibernate对类进行增强时，都会使用到类似CGLIB这类字节码技术，增强的类越多，
就需要越大的方法区来保证动态生成的Class可以加载如内存。程序不断地加载一个类，同时会增加该类的各种信息，直至方法区填充完，抛出错误。

在java 1.8中取消了这两个参数，可以被设置，但是会被忽略。
* -XX:PermSize分配非堆最小内存，默认为物理内存的1/64；
* -XX:MaxPermSize分配最大内存，默认为物理内存的1/4。

JVM直接内存：
直接内存并不是虚拟机运行时数据区的一部分，也不是Java 虚拟机规范中定义的内存区域。在JDK1.4 中新加入了NIO(New Input/Output)类，引入了一
种基于通道（Channel）与缓冲区（Buffer）的 I/O 方式，它可以使用 native 函数库直接分配堆外内存，然后通过一个存储在Java堆中的 DirectByteBuffer
对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。

由于申请直接内存不由虚拟机管理，所以由此导致的 OOM 是不会在 Heap Dump 文件中看出明显的异常。

java运行时各个区域，其中程序计数器，虚拟机栈，本地方法栈随线程而生，随线程而灭。栈中的栈帧随方法的进入和退出执行着出栈和入栈操作。
每一个栈帧中分配多少内存基本上是在类结构确定下来时，就已知了（尽管在运行期会由JIT编译器优化，大体上仍然认为是已知的）
而java堆和方法区的内存分配和回收都是动态的，垃圾收集器关注的是这部分内存。




引用计数算法：给对象添加一个引用计数器，每当有一个地方引用它，计数器加1，当引用失效，计数器减1，垃圾收集器在进行垃圾回收时，对扫
描到的每一个对象判断一下计数器是否等于0，若等于0，就会释放该对象占用的内存空间,同时将该对象引用的其他对象的计数器进行减一操作。

算法的劣势： 采用引用计数器进行垃圾回收，最大的缺点就是不能解决循环引用的问题，例如一个父对象持有一个子对象的引用，子对象也持有父对象的引用，这种情况下，父子对象将一直存在于JVM的堆中，无法进行回收。

可达性分析法：在主流的商用语言中，都是通过可达性分析来判断对象是否存活。
原理：通过一系列被称为“GC Roots‘’的对象作为起始点，从这些节点向下搜索，搜索所走过的路径叫做引用链，
当一个节点到GC Roots没有任何引用链时，证明该对象不可用了。

在Java中，可以被作为GC Roots的对象有以下几种：
1. 虚拟机栈中引用的对象（栈帧中的引用变量表）
2. 方法区中类静态属性引用的对象
3. 方法区中常量引用的对象
4. 本地方法栈中Native方法（JNI）引用的对象

jdk1.2之后，java对引用做了扩充，将引用分为强引用，软引用，弱引用，虚引用。
* 强引用：
    * 强引用是指在程序代码中普遍存在的，类似“Object obj=new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。
* 软引用
    * 软引用是用来描述一些有用但并不是必需的对象。对于软引用关联着的对象，只有在内存不足的时候JVM才会回收该对象。因此，这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。JDK 1.2之后，提供了SoftReference类来实现软引用。
* 弱引用
    * 弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象

* 虚引用
    * 虚引用和前面的软引用、弱引用不同，它并不影响对象的生命周期。在java中用java.lang.ref.PhantomReference类表示。如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。

即使可达性分析算法不可达的对象，也并非“非死不可”，要真正宣告一个对象死亡，至少要经历2次标记过程，对象在进行可达性分析后发现没有与GC Roots相连接的引用链
那么它会被第一次标记并进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法，当对象没有覆盖finalize方法，或者finzlize方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。

第二次标记，如果这个对象被判定为有必要执行finalize（）方法，那么这个对象将会被放置在一个名为：F-Queue的队列之中，并在稍后由一条虚拟机自动建立的、低优先级的Finalizer线程去执行。这里所谓的“执行”是指虚拟机会
触发这个方法，但并不承诺会等待它运行结束。这样做的原因是，如果一个对象finalize（）方法中执行缓慢，或者发生死循环（更极端的情况），将很可能会导致F-Queue队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。
Finalize（）方法是对象脱逃死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模标记，如果对象要在finalize（）中成功拯救自己----只要重新与引用链上的任何的一个对象建立关联即可，
譬如把自己赋值给某个类变量或对象的成员变量，那在第二次标记时它将移除出“即将回收”的集合。如果对象这时候还没逃脱，那基本上它就真的被回收了。

##### 回收方法区

##### 垃圾收集算法
* 标记-清除算法（Mark-Sweep）
    *




































