---
layout: post
title:  "java虚拟机"
date:   2019-04-11 19:35:21
author: zhangtejun
categories: Java
---
#### 运行时数据区域
java虚拟机在执行java程序的过程中会把它所管理的内存划分为若干个不同的数据区域。
* 程序计数器 是一块较小的内存空间（每一个线程会分配独立的程序计数器），是当前线程所执行的字节码的行号指示器，
  字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、
  异常处理、线程恢复等基础功能都需要依赖这个计数器来完成。

##### 栈(线程) 存放局部变量
栈帧：一个方法对应一块栈帧内存区域(栈帧)




`java.lang.OutOfMemoryError: Java heap space` 是内存泄漏还是内存溢出

##### java堆溢出
Java堆用于存储对象实例，只要不断地创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，
那么在对象数量到达最大堆的容量限制后就会产生内存溢出异常。

要解决这个区域的异常，一般的手段是先通过内存映像分析工具（如Eclipse Memory Analyzer）对Dump出来的堆转储快照进行分析，
重点是确认内存中的对象是否是必要的，也就是要先分清除到底是出现了内存泄漏（Memory Leak）还是内存溢出（Memory Overflow）。

如果是内存泄漏，可进一步通过工具查看泄漏对象到GC Roots的引用链。于是就能找到泄露对象是通过怎样的路径与GC Roots相关联并导致
垃圾收集器无法自动回收他们的。掌握了泄漏对象的类型信息及GC Roots引用链的信息，就可以比较准确的定位出泄漏代码的位置。

如果不存在泄漏，换句话说，就是内存中的对象确实还必须存活着，那就应当检查虚拟机的堆参数（-Xmx与-Xms），与机器物理内存对比看
是否还可以调大，从代码上检查是否存在某些对象生命周期过长、持有状态时间过长的情况，尝试减少的程序运行期的内存消耗。

##### 虚拟机栈和本地方法栈溢出
由于hotSpot虚拟机不区分虚拟机栈和本地方法栈，虽然参数-Xoss（设置本地方法栈大小）存在，但实际上无效，栈容量由-Xss参数设置。
在 Java 虚拟机规范中，对虚拟机栈这个区域规定了两种异常状况：
* 如果线程请求的栈深度大于虚拟机所允许的深度，将抛出StackOverflowError 异常；
* 如果虚拟机栈可以动态扩展（当前大部分的 Java 虚拟机都可动态扩展，只不过 Java 虚拟机规范中也允许固定长度的虚拟机栈），当扩
展时无法申请到足够的内存时会抛出 OutOfMemoryError 异常。

在单个线程下，无论是由于栈帧太大，还是虚拟机栈容量太小，当内存无法分配的时候，虚拟机抛出的都是 StackOverflowError 异常，而不是OOM。
1. 使用参数-Xss减小栈内存容量。
2. 定义大量本地变量，增加此方法帧中本地变量表的长度。

##### 方法区和运行时常量池溢出(JDK 1.7开始逐步“去永久代”)
String.intern()是一个Native方法，它的作用是：如果字符串常量池中已经包含一个等于此String对象的字符串，则返回常量池中这个字符串的String
对象；否则，将此String对象包含的字符串添加到常量池中，并且返回此String对象的引用。在JDK 1.6及之前的版本中，由于常量池分配在`永久代`内，
我们可以通过-XX:PermSize和-XX:MaxPermSize限制方法区大小，从而间接限制其中常量池的容量

运行时常量池溢出，在OutOfMemoryError后面跟随的提示信息是“PermGen space”，说明运行时常量池属于方法区（HotSpot虚拟机中的永久代）的一部分。
```java
/**
 * VM Args：-XX:PermSize=10M -XX:MaxPermSize=10M
 */
public static void main(String[] args) {
    // 使用List保持着常量池引用，避免Full GC回收常量池行为
    List<String> list = new ArrayList<String>();
    // 10MB的PermSize在integer范围内足够产生OOM了
    int i = 0;
    while (true) {
        list.add(String.valueOf(i++).intern());
    }
}
// jdk1.6
Exception in thread "main" java.lang.OutOfMemoryError: PermGen space
at java.lang.String.intern(Native Method)
// 而使用JDK 1.7运行这段程序就不会得到相同的结果，while循环将一直进行下去。
```
方法区用于存放Class的相关信息，如类名、访问修饰符、常量池、字段描述、方法描述等。对于这些区域的测试，基本的思路是运行时产生大量的类去填满方法区，直到溢出。

intern用来返回常量池中的某字符串，如果常量池中已经存在该字符串，则直接返回常量池中该对象的引用。否则，在常量池中加入该对象，然后 返回引用。

在JDK 1.6中，intern()方法会把首次遇到的字符串实例复制到永久代中，返回的也是永久代中这个字符串实例的引用，而由StringBuilder创建的字符串实例在Java堆上，所以必然不是同一个引用。

而JDK 1.7的intern()实现不会再复制实例，只是在常量池中记录`首次出现`的实例引用，因此intern()返回的引用和由StringBuilder创建的那个字符串实例是同一个

```java
String s1 = new String("1"); // 同时会生成堆中的对象 以及常量池中1的对象，但是此时s1是指向堆中的对象的
s1.intern();// 常量池中的已经存在
String s2 = "1";
System.out.println(s1 == s2); // false

String s3 = new String("1") + new String("1");    // 此时生成了四个对象 常量池中的"1" + 2个堆中的"1" + s3指向的堆中的对象（注此时常量池不会生成"11"）
String intern = s3.intern();// jdk1.7之后，常量池不仅仅可以存储对象，还可以存储对象的引用，会直接将s3的地址存储在常量池
String s4 = "11";    // jdk1.7之后，常量池中的地址其实就是s3的地址
System.out.println(s3 == s4); // 结果jdk1.8 false（不同电脑结果不一致） 期望（jdk1.7false， jdk1.7之后true）
System.out.println(intern == s4);//jdk1.8 true

s3 = new String("2") + new String("2");
s4 = "22";        // 常量池中不存在22，所以会新开辟一个存储22对象的常量池地址
s3.intern();    // 常量池22的地址和s3的地址不同
System.out.println(s3 == s4); // false
```

方法区溢出也是一种常见的内存溢出异常。jdk 1.7的HotSpot中，已经把原本放在永久代的字符串常量池移出,在jdk1.7之前，字符串常量存储在方法区的PermGen Space。

当前主流的很多框架 如：Spring,Hibernate对类进行增强时，都会使用到类似CGLIB这类字节码技术，增强的类越多，
就需要越大的方法区来保证动态生成的Class可以加载如内存。程序不断地加载一个类，同时会增加该类的各种信息，直至方法区填充完，抛出错误。

在java 1.8中取消了这两个参数，可以被设置，但是会被忽略。
* -XX:PermSize分配非堆最小内存，默认为物理内存的1/64；
* -XX:MaxPermSize分配最大内存，默认为物理内存的1/4。

JVM直接内存：
直接内存并不是虚拟机运行时数据区的一部分，也不是Java 虚拟机规范中定义的内存区域。在JDK1.4 中新加入了NIO(New Input/Output)类，引入了一
种基于通道（Channel）与缓冲区（Buffer）的 I/O 方式，它可以使用 native 函数库直接分配堆外内存，然后通过一个存储在Java堆中的 DirectByteBuffer
对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。

由于申请直接内存不由虚拟机管理，所以由此导致的 OOM 是不会在 Heap Dump 文件中看出明显的异常。

java运行时各个区域，其中程序计数器，虚拟机栈，本地方法栈随线程而生，随线程而灭。栈中的栈帧随方法的进入和退出执行着出栈和入栈操作。
每一个栈帧中分配多少内存基本上是在类结构确定下来时，就已知了（尽管在运行期会由JIT编译器优化，大体上仍然认为是已知的）
而java堆和方法区的内存分配和回收都是动态的，垃圾收集器关注的是这部分内存。




引用计数算法：给对象添加一个引用计数器，每当有一个地方引用它，计数器加1，当引用失效，计数器减1，垃圾收集器在进行垃圾回收时，对扫
描到的每一个对象判断一下计数器是否等于0，若等于0，就会释放该对象占用的内存空间,同时将该对象引用的其他对象的计数器进行减一操作。

算法的劣势： 采用引用计数器进行垃圾回收，最大的缺点就是不能解决循环引用的问题，例如一个父对象持有一个子对象的引用，子对象也持有父对象的引用，这种情况下，父子对象将一直存在于JVM的堆中，无法进行回收。

可达性分析法：在主流的商用语言中，都是通过可达性分析来判断对象是否存活。
原理：通过一系列被称为“GC Roots‘’的对象作为起始点，从这些节点向下搜索，搜索所走过的路径叫做引用链，将其标记为非垃圾对象，全部复制到s0
当一个节点到GC Roots没有任何引用链时，证明该对象不可用了。

在Java中，可以被作为GC Roots的对象有以下几种：
1. 虚拟机栈中引用的对象（栈帧中的引用变量表）
2. 方法区中类静态属性引用的对象
3. 方法区中常量引用的对象
4. 本地方法栈中Native方法（JNI）引用的对象

jdk1.2之后，java对引用做了扩充，将引用分为强引用，软引用，弱引用，虚引用。
* 强引用：
    * 强引用是指在程序代码中普遍存在的，类似“Object obj=new Object()”这类的引用，只要强引用还存在，垃圾收集器永远不会回收掉被引用的对象。
* 软引用
    * 软引用是用来描述一些有用但并不是必需的对象。对于软引用关联着的对象，只有在内存不足的时候JVM才会回收该对象。因此，这一点可以很好地用来解决OOM的问题，并且这个特性很适合用来实现缓存：比如网页缓存、图片缓存等。JDK 1.2之后，提供了SoftReference类来实现软引用。
* 弱引用
    * 弱引用也是用来描述非必需对象的，当JVM进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象

* 虚引用
    * 虚引用和前面的软引用、弱引用不同，它并不影响对象的生命周期。在java中用java.lang.ref.PhantomReference类表示。如果一个对象与虚引用关联，则跟没有引用与之关联一样，在任何时候都可能被垃圾回收器回收。

即使可达性分析算法不可达的对象，也并非“非死不可”，要真正宣告一个对象死亡，至少要经历2次标记过程，对象在进行可达性分析后发现没有与GC Roots相连接的引用链
那么它会被第一次标记并进行一次筛选，筛选的条件是此对象是否有必要执行finalize()方法，当对象没有覆盖finalize方法，或者finzlize方法已经被虚拟机调用过，虚拟机将这两种情况都视为“没有必要执行”。

第二次标记，如果这个对象被判定为有必要执行finalize（）方法，那么这个对象将会被放置在一个名为：F-Queue的队列之中，并在稍后由一条虚拟机自动建立的、低优先级的Finalizer线程去执行。这里所谓的“执行”是指虚拟机会
触发这个方法，但并不承诺会等待它运行结束。这样做的原因是，如果一个对象finalize（）方法中执行缓慢，或者发生死循环（更极端的情况），将很可能会导致F-Queue队列中的其他对象永久处于等待状态，甚至导致整个内存回收系统崩溃。
Finalize（）方法是对象脱逃死亡命运的最后一次机会，稍后GC将对F-Queue中的对象进行第二次小规模标记，如果对象要在finalize（）中成功拯救自己----只要重新与引用链上的任何的一个对象建立关联即可，
譬如把自己赋值给某个类变量或对象的成员变量，那在第二次标记时它将移除出“即将回收”的集合。如果对象这时候还没逃脱，那基本上它就真的被回收了。

##### 回收方法区

##### 垃圾收集算法
* 标记-清除算法（Mark-Sweep）
    *



动态链接：在程序运行期间，由符合引用转换为直接引用（堆例生成实例对象并被指向（指针。句柄））。




java对象头，age:4字节 （故只能分代年龄达到15，进入老年代）



gceasy.io

##### JMM
JMM即为JAVA 内存模型（java memory model）,或者说是java线程模型，和CPU缓存模型类似，是基于CPU缓存模型来建立
的一个抽象化的概念。 java内存模型是标准化的（为什么要怎么做？屏蔽底层不同计算机的区别，以实现java程序在各种平台下都可以达到一致性
内存访问的效果）。

JMM规定所有变量都存在主内存（java虚拟机内存的一部分）中，每个线程有自己的工作内存，所有该线程使用的变量（仅仅是主内存中变量的拷贝副本）都保存在这
，线程对变量的各种操作都在工作内存中进行，不能直接操作主内存。

1. 线程A读取共享变量S到该线程的工作内存（类比CPU 三级缓存），线程执行过程中，都是在工作内存中进行操作。
2. 线程B读取共享变量S到该线程的工作内存（类比CPU 三级缓存）
3. 线程A修改共享变量S



一个变量如何从主内存拷贝到工作内存。如何从工作内存同步到主内存中的实现细节。
java内存模型定义了8种操作来完成。这8种操作每一种都是原子操作。

8种操作如下：

1. lock(锁定)：作用于主内存，在store的时候，它把一个变量标记为一条线程独占状态；
2. read(读取)：作用于主内存，它把变量值从主内存传送到线程的工作内存中，以便随后的load动作使用。即从主内存读取数据；
3. load(载入)：作用于工作内存，它把read操作的值放入工作内存中的变量副本中；
4. use(使用)：作用于工作内存，它把工作内存中的值传递给执行引擎，每当虚拟机遇到一个需要使用这个变量的指令时候，将会执行这个动作；
5. assign(赋值)：作用于工作内存，它把从执行引擎获取的值赋值给工作内存中的变量，每当虚拟机遇到一个给变量赋值的指令时候，执行该操作；
6. store(存储)：作用于工作内存，它把工作内存中的一个变量传送给主内存中，以备随后的write操作使用；
7. write(写入)：作用于主内存，它把store传送值放到主内存中的变量中，
8. unlock(解锁)：作用于主内存，它将一个处于锁定状态的变量释放出来，释放后的变量才能够被其他线程锁定，在write后。








































