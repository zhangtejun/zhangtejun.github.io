---
layout: post
title:  "serialization"
date:   2017-11-14 14:44:21
author: zhangtejun
categories: zhangtejun
---
##### 序列化
对象序列化（object serialization）API框架，用来将对象编码成一个字节流（序列化serializing）
及从字节流编码中构建对象(反序列化deserializing)。

实现serializable付出的代价有：

* 一旦一个类被发布，则`改变这个类的实现`的灵活性将大大降低。
  
  序列化使类的演化受到限制，这种限制和流的唯一标识符（stream unique identifier）有关。
  即UID(serial version UID)。每个可序列化的类都有一个唯一标识和它相关联，如果没有指定
  一个名为serial version UID的私有静态final的long域来显试指定该标识，那么系统将自动生产
  该标识，这个标识的值将受到类名字，实现的接口，以及所有公有或受保护的成员名字的影响。
  如果以任何方式改变了这些信息，如增加一个不重要的工具方法等，自动生产的UID也会发生变化。
  因此如果没有申明一个显式的序列化版本UID，则兼容性将会被打破。
  
* 它增加了错误（bug）和安全漏洞的可能性。

  一般情况下，对象是由构造函数来创建的；序列化机制是一种语言之外的对象创建机制。
  无论你是接受默认的行为，还是改写了默认的行为，反序列化机制是一个“隐藏的构造函数”，
  具备和其他构造函数相同的特点。因为反序列化机制中没有显式的构造函数，所有很容易忘记确保这一点。
  
* 随着类的新版本发行，相关的测试负担增加。
  
  当一个类被修订时，要检查是否在新版本中序列化一个实例，然后在老版本中反序列化，或者相反的过程。
  
 
无论你是否使用默认序列化形式，当defaultWriteObject方法被调用时，每一个未被标记为transient的实例域都
会被序列化。

如果你正在使用默认的序列化形式，并且把一个或者多个域标记为transient，则记住，当一个实例被反序列化时，这些域将会
为他们初始化默认值，对于对象引用，默认值为null,对应数值原语，默认值为0，对应boolean域，默认值为false.
如果这些值不能被任何transient域所接受，那么必须提供一个readObject方法，它首先调用defaultWriteObject方法，然后把这些
transient域的值恢复为可接受的值，另一种方法，这些域可以被延迟初始化，直到第一次被调用时才真正初始化。


##### readObject方法
当对象被反序列化时，对于客户不应该拥有的对象的引用，如果哪个域包含了这样的引用，则必须要做保护性拷贝。因此，对于每一个可序列化的非可变类，
如果它包含了私有的可变组件,那么在它的readObject方法中，必须要对这些组件进行保护性拷贝。
  
  
