---
layout: post
title:  "JavaScript"
date:   2017-05-23 10:53:16
author: zhangtj
categories: zhangtj
---
[]{#4ffjk1488963794248 .anchor}**内存空间详细图解**

[]{#36pjkw1488963822088 .anchor}变量对象与堆内存

> []{#93htek1488963802413 .anchor}**var** a = 20;
>
> []{#60rdpa1488963802422 .anchor}**var** b = 'abc';
>
> []{#10nqvg1488963802430 .anchor}**var** c = **true**;
>
> []{#92bfup1488963802439 .anchor}**var** d = { m: 20 }

[]{#34rvmj1488963802446
.anchor}因为JavaScript具有自动垃圾回收机制，所以对于前端开发来说，内存空间并不是一个经常被提及的概念，很容易被大家忽视。特别是很多不是计算机专业的朋友在进入到前端之后，会对内存空间的认知比较模糊，甚至有些人干脆就是一无所知。

[]{#87mnih1488963839376 .anchor}

[]{#97lefr1488963802451
.anchor}当然也包括我自己。在很长一段时间里认为内存空间的概念在JS的学习中并不是那么重要。可是后我当我回过头来重新整理JS基础时，发现由于对它们的模糊认知，导致了很多东西我都理解得并不明白。比如最基本的引用数据类型和引用传递到底是怎么回事儿？比如浅复制与深复制有什么不同？还有闭包，原型等等。

[]{#41xukc1488963802456 .anchor}

[]{#53oglr1488963802456
.anchor}因此后来我才渐渐明白，想要对JS的理解更加深刻，就必须对内存空间有一个清晰的认知。

[]{#41dvgi1488963802457 .anchor}

[]{#33qumj1488963802458 .anchor}**一、栈与堆**

[]{#23mpyi1488963802459 .anchor}

> []{#17jbxu1488963802460 .anchor}注：栈，也可以叫堆栈

[]{#33msir1488963802461 .anchor}

[]{#47rtgs1488963802461
.anchor}与C/C++不同，JavaScript中并没有严格意义上区分栈内存与堆内存。因此我们可以粗浅的理解为JavaScript的所有数据都保存在堆内存中。但是在某些场景，我们仍然需要基于堆栈数据结构的思路进行处理，比如JavaScript的执行上下文（关于执行上下文我会在下一篇文章中总结）。执行上下文在逻辑上实现了堆栈。因此理解堆栈数据结构的原理与特点任然十分重要。

[]{#86dxqh1488963802463
.anchor}注：基本类型就是保存在栈内存中的简单数据段，而引用类型指的是那些保存在堆内存中的对象。

[]{#99tmfv1489460829162 .anchor}1 、基本类型  

[]{#48dmrr1489460829164
.anchor}基本类型有 Undefined、Null、Boolean、Number
和String。这些类型在内存中分别占有固定大小的空间，他们的值保存在栈空间，我们通过按值来访问的。

[]{#4prmw1489460829167 .anchor}2 、引用类型

[]{#15kqwh1489460829168
.anchor}引用类型，值大小不固定，栈内存中存放地址指向堆内存中的对象。是按引用访问的。如下图所示：栈内存中存放的只是该对象的访问地址， 在堆内存中为这个值分配空间 。 由于这种值的大小不固定，因此不能把它们保存到栈内存中。但内存地址大小的固定的，因此可以将内存地址保存在栈内存中。
这样，当查询引用类型的变量时， 先从栈中读取内存地址，
然后再通过地址找到堆中的值。对于这种，我们把它叫做按引用访问。

[]{#97nbtm1489461055282 .anchor}**为什么会有栈内存和堆内存之分？**

[]{#74rbtt1489461056897
.anchor}通常与垃圾回收机制有关。为了使程序运行时占用的内存最小。

[]{#69dwdu1489461056898
.anchor}当一个方法执行时，每个方法都会建立自己的内存栈，在这个方法内定义的变量将会逐个放入这块栈内存里，随着方法的执行结束，这个方法的内存栈也将自然销毁了。因此，所有在方法中定义的变量都是放在栈内存中的；

[]{#96wsnd1489461056901
.anchor}当我们在程序中创建一个对象时，这个对象将被保存到运行时数据区中，以便反复利用（因为对象的创建成本通常较大），这个运行时数据区就是堆内存。堆内存中的对象不会随方法的结束而销毁，即使方法结束后，这个对象还可能被另一个引用变量所引用（方法的参数传递时很常见），则这个对象依然不会被销毁，只有当一个对象没有任何引用变量引用它时，系统的垃圾回收机制才会在核实的时候回收它。

[]{#81kzof1488963802464
.anchor}要简单理解栈的存取方式，我们可以通过类比乒乓球盒子来分析。如下图左侧。

[]{#64nlmt1488963802464 .anchor}

[]{#27zgxp1488963802464 .anchor}

[]{#72jalz1488963802465 .anchor}

[]{#49agmk1488963802466 .anchor}乒乓球盒子与栈类比

[]{#88asjy1488963802466 .anchor}

[]{#63ikjf1488963802466
.anchor}这种乒乓球的存放方式与栈中存取数据的方式如出一辙。处于盒子中最顶层的乒乓球5，它一定是最后被放进去，但可以最先被使用。而我们想要使用底层的乒乓球1，就必须将上面的4个乒乓球取出来，让乒乓球1处于盒子顶层。这就是栈空间先进后出，后进先出的特点。图中已经详细的表明了栈空间的存储原理。

[]{#57tilt1488963802468 .anchor}

[]{#30rpdc1488963802468 .anchor}堆存取数据的方式，则与书架与书非常相似。

[]{#56hwtd1488963802469 .anchor}

[]{#77qxes1488963802469
.anchor}书虽然也整齐的存放在书架上，但是我们只要知道书的名字，我们就可以很方便的取出我们想要的书，而不用像从乒乓球盒子里取乒乓一样，非得将上面的所有乒乓球拿出来才能取到中间的某一个乒乓球。好比在JSON格式的数据中，我们存储的key-value是可以无序的，因为顺序的不同并不影响我们的使用，我们只需要关心书的名字。

[]{#58jvxt1488963802471 .anchor}

[]{#48gaxs1488963802472 .anchor}**二、变量对象与基础数据类型**

[]{#86sasr1488963802472 .anchor}

[]{#32uzcq1488963802472
.anchor}JavaScript的执行上下文生成之后，会创建一个叫做变量对象的特殊对象（具体会在下一篇文章与执行上下文一起总结），JavaScript的基础数据类型往往都会保存在变量对象中。

[]{#67srrx1488963802473 .anchor}

> []{#34lyub1488963802473
> .anchor}严格意义上来说，变量对象也是存放于堆内存中，但是由于变量对象的特殊职能，我们在理解时仍然需要将其于堆内存区分开来。

[]{#62gron1488963802474 .anchor}

[]{#28xbzu1488963802474
.anchor}基础数据类型都是一些简单的数据段，JavaScript中有5中基础数据类型，分别是Undefined、Null、Boolean、Number、String。基础数据类型都是按值访问，因为我们可以直接操作保存在变量中的实际的值。

[]{#97ccfm1488963802476 .anchor}

[]{#78iyvl1488963802476 .anchor}**三、引用数据类型与堆内存**

[]{#98qmpq1488963802477 .anchor}

[]{#52swqf1488963802477
.anchor}与其他语言不通，JS的引用数据类型，比如数组Array，它们值的大小是不固定的。引用数据类型的值是保存在堆内存中的对象。JavaScript不允许直接访问堆内存中的位置，因此我们不能直接操作对象的堆内存空间。在操作对象时，实际上是在操作对象的引用而不是实际的对象。因此，引用类型的值都是按引用访问的。这里的引用，我们可以粗浅地理解为保存在变量对象中的一个地址，该地址与堆内存的实际值相关联。

[]{#93tkep1488963802480 .anchor}

[]{#48qibs1488963802480
.anchor}为了更好的搞懂变量对象与堆内存，我们可以结合以下例子与图解进行理解。

[]{#85oawn1488963802481 .anchor}

> []{#61aree1488963802490 .anchor}**var** a1 = 0;   *// 变量对象*
>
> []{#43oqrj1488963802494 .anchor}**var** a2 = 'this is string'; *//
> 变量对象*
>
> []{#31jxer1488963802502 .anchor}**var** a3 = **null**; *// 变量对象*
>
> []{#55tbqk1488963802503 .anchor} 
>
> []{#0guii1488963802506 .anchor}**var** b = { m: 20 }; *//
> 变量b存在于变量对象中，{m: 20} 作为对象存在于堆内存中*
>
> []{#58sxlf1488963802510 .anchor}**var** c = \[1, 2, 3\]; *//
> 变量c存在于变量对象中，\[1, 2, 3\] 作为对象存在于堆内存中*

[]{#49fohf1488963802510 .anchor}

[]{#41sigp1488963802511 .anchor}

[]{#21dzlc1488963802512 .anchor}上例图解

[]{#41oynt1488963802512 .anchor}

[]{#9qgoz1488963802512
.anchor}因此当我们要访问堆内存中的引用数据类型时，实际上我们首先是从变量对象中获取了该对象的地址引用（或者地址指针），然后再从堆内存中取得我们需要的数据。

[]{#80byhg1488963802513 .anchor}*modify by zhangtj 2017年5月9日16:09:06*

[]{#39aweb1494317353816 .anchor}*1.对象的定义*

[]{#56hthi1494317391920
.anchor}*对象被定义为“无序属性集合，其属性可以包含基本值，对象或者函数”。*

[]{#87ozdk1494317614666
.anchor}*2.对象的创建：①通过new的方式创建②通过字面量的形式创建一个简单的对象(var
obj = {})。*

[]{#21cruz1488963802514
.anchor}理解了JS的内存空间，我们就可以借助内存空间的特性来验证一下引用类型的一些特点了。

[]{#15enrq1488963802515 .anchor}

[]{#34vuyz1488963802515
.anchor}在前端面试中我们常常会遇到这样一个类似的题目

[]{#56mvef1488963802515 .anchor}

> []{#77ribv1488963802515 .anchor}*// demo01.js*
>
> []{#14gjws1488963802516 .anchor}**var** a = 20;
>
> []{#94gwel1488963802522 .anchor}**var** b = a;
>
> []{#67sgej1488963802524 .anchor}b = 30;
>
> []{#79gmnv1488963802525 .anchor} 
>
> []{#60nnpy1488963802526 .anchor}*// 这时a的值是多少？*

[]{#58mvzq1488963802527 .anchor} 

> []{#25juqo1488963802527 .anchor}*// demo02.js*
>
> []{#16homm1488963802532 .anchor}**var** m = { a: 10, b: 20 }
>
> []{#18geih1488963802535 .anchor}**var** n = m;
>
> []{#42rtfa1488963802536 .anchor}n.a = 15;
>
> []{#39lcnx1488963802537 .anchor} 
>
> []{#20soff1488963802537 .anchor}*// 这时m.a的值是多少*

[]{#8kiyi1488963802538 .anchor}

[]{#35rjij1488963802538
.anchor}在变量对象中的数据发生复制行为时，系统会自动为新的变量分配一个新值。var
b =
a执行之后，a与b虽然值都等于20，但是他们其实已经是相互独立互不影响的值了。具体如图。所以我们修改了b的值以后，a的值并不会发生变化。

[]{#42kkcw1488963802539 .anchor}

[]{#67dnwj1488963802540 .anchor}

[]{#31aydy1488963802540 .anchor}demo01图解

[]{#94dfuh1488963802541 .anchor}

[]{#42vxdf1488963802541 .anchor}在demo02中，我们通过var n =
m执行一次复制引用类型的操作。引用类型的复制同样也会为新的变量自动分配一个新的值保存在变量对象中，但不同的是，这个新的值，仅仅只是引用类型的一个地址指针。当地址指针相同时，尽管他们相互独立，但是在变量对象中访问到的具体对象实际上是同一个。如图所示。

[]{#46kbwq1488963802542 .anchor}

[]{#90fmuo1488963802543
.anchor}因此当我改变n时，m也发生了变化。这就是引用类型的特性。

[]{#97tzom1488963802543 .anchor}

[]{#88tdat1488963802544 .anchor}

[]{#28ceel1488963802545 .anchor}demo02图解

[]{#10ywme1488963802545 .anchor}

[]{#5irgy1488963802546
.anchor}通过内存的角度来理解，是不是感觉要轻松很多。除此之外，我们还可以以此为基础，一步一步的理解JavaScript的执行上下文，作用域链，闭包，原型链等重要概念。其他的我会在以后的文章慢慢总结，敬请期待。

[]{#44hpcl1488963802547 .anchor}

[]{#90zuoy1488963802547 .anchor}**内存空间管理**

[]{#85pflh1488963802548 .anchor}

[]{#56zqrc1488963802548
.anchor}因为JavaScript具有自动垃圾收集机制，所以我们在开发时好像不用关心内存的使用问题，内存的分配与回收都完全实现了自动管理。但是根据我自己的开发经验，了解内存机制有助于自己清晰的认识到自己写的代码在执行过程中发生过什么，从而写出性能更加优秀的代码。因此关心内存是一件非常重要的事情。

[]{#22widf1488963802550 .anchor}

[]{#57gwjj1488963802550 .anchor}JavaScript的内存生命周期

[]{#68wses1488963802550 .anchor}

[]{#84cqpr1488963802551 .anchor}1. 分配你所需要的内存

[]{#28wvol1488963802551 .anchor}2. 使用分配到的内存（读、写）

[]{#2xcbr1488963802551 .anchor}3. 不需要时将其释放、归还

[]{#8ybxq1488963802552 .anchor}

[]{#83ivlo1488963802552
.anchor}为了便于理解，我们使用一个简单的例子来解释这个周期。

[]{#20gyis1488963802553 .anchor}

> []{#83kbsa1488963802554 .anchor}**var** a = 20;  *//
> 在内存中给数值变量分配空间*
>
> []{#31knuj1488963802556 .anchor}**alert**(a + 100);  *// 使用内存*
>
> []{#24khlc1488963802560 .anchor}a = **null**; *//
> 使用完毕之后，释放内存空间*

[]{#44daut1488963802561 .anchor}

[]{#61tlba1488963802561
.anchor}第一步和第二步我们都很好理解，JavaScript在定义变量时就完成了内存分配。第三步释放内存空间则是我们需要重点理解的一个点。

[]{#3lmee1488963802562 .anchor}

[]{#80jpdz1488963802562
.anchor}JavaScript有自动垃圾收集机制，那么这个自动垃圾收集机制的原理是什么呢？其实很简单，就是找出那些不再继续使用的值，然后释放其占用的内存。垃圾收集器会每隔固定的时间段就执行一次释放操作。

[]{#19brim1488963802563 .anchor}

[]{#6fncc1488963802563
.anchor}在JavaScript中，最常用的是通过标记清除的算法来找到哪些对象是不再继续使用的，因此a
= null其实仅仅只是做了一个释放引用的操作，让 a
原本对应的值失去引用，脱离执行环境，这个值会在下一次垃圾收集器执行操作时被找到并释放。而在适当的时候解除引用，是为页面获得更好性能的一个重要方式。

[]{#25nvvn1488963802564 .anchor}

[]{#31gwra1488963802566
.anchor}在局部作用域中，当函数执行完毕，局部变量也就没有存在的必要了，因此垃圾收集器很容易做出判断并回收。但是全局变量什么时候需要自动释放内存空间则很难判断，因此在我们的开发中，需要尽量避免使用全局变量，以确保性能问题。

[]{#58lptd1488963802568
.anchor}要详细了解垃圾收集机制，建议阅读《JavaScript高级编程》中的4.3节

[]{#30wzeg1488963847322 .anchor}

[]{#22tygd1488963850177 .anchor}

[]{#57pkfl1488963850851 .anchor}**执行上下文详细图解**

[]{#26jkvt1488963926246 .anchor}

[]{#40utev1488963926248 .anchor}先随便放张图

[]{#17gocs1488963926252 .anchor}

[]{#8fcwz1488963926253
.anchor}我们在JS学习初期或者面试的时候常常会遇到考核变量提升的思考题。比如先来一个简单一点的。

[]{#39shkg1488963926255 .anchor}

> []{#87ooyz1488963926272 .anchor}console.log(a);   *//
> 这里会打印出什么？*
>
> []{#15btuq1488963926279 .anchor}**var** a = 20;

[]{#29efqj1488963926280 .anchor}

[]{#43fztt1488963926281
.anchor}暂时先不管这个例子，我们先引入一个JavaScript中最基础，但同时也是最重要的一个概念执行上下文（Execution
Context）。

[]{#92xpcb1488963926284 .anchor}

[]{#88qkci1488963926286
.anchor}每次当控制器转到可执行代码的时候，就会进入一个执行上下文。执行上下文可以理解为当前代码的执行环境，它会形成一个作用域。JavaScript中的运行环境大概包括三种情况。

[]{#99sdhd1488963926290 .anchor}

[]{#90gdzy1488963926293
.anchor}全局环境：JavaScript代码运行起来会首先进入该环境

[]{#22qhzy1488963926294
.anchor}函数环境：当函数被调用执行时，会进入当前函数中执行代码

[]{#31lvde1488963926295 .anchor}eval

[]{#17isfa1488963926296 .anchor}

[]{#35ekpb1488963926296
.anchor}因此在一个JavaScript程序中，必定会产生多个执行上下文，在我的上一篇文章中也有提到，JavaScript引擎会以堆栈的方式来处理它们，这个堆栈，我们称其为函数调用栈(call
stack)。栈底永远都是全局上下文，而栈顶就是当前正在执行的上下文。

[]{#85rpku1488963926299 .anchor}

[]{#58gdnz1488963926300
.anchor}当代码在执行过程中，遇到以上三种情况，都会生成一个执行上下文，放入栈中，而处于栈顶的上下文执行完毕之后，就会自动出栈。为了更加清晰的理解这个过程，根据下面的例子，结合图示给大家展示。

[]{#6pudg1488963926301 .anchor}

> []{#73qayr1488963926303 .anchor}**var** color = 'blue';
>
> []{#63qszz1488963926304 .anchor} 
>
> []{#48koev1488963926308 .anchor}**function** changeColor() {
>
> []{#67elmn1488963926310 .anchor}    **var** anotherColor = 'red';
>
> []{#4gijt1488963926311 .anchor} 
>
> []{#55ipzp1488963926313 .anchor}    **function** swapColors() {
>
> []{#6xfin1488963926315
> .anchor}        **var** tempColor = anotherColor;
>
> []{#76qcod1488963926318 .anchor}        anotherColor = color;
>
> []{#35cpdi1488963926322 .anchor}        color = tempColor;
>
> []{#75twsm1488963926325 .anchor}    }
>
> []{#1jhyo1488963926325 .anchor} 
>
> []{#77cglu1488963926326 .anchor}    swapColors();
>
> []{#75fkoo1488963926327 .anchor}}
>
> []{#40zixk1488963926327 .anchor} 
>
> []{#7mlyo1488963926329 .anchor}changeColor();

[]{#69bpni1488963926329 .anchor}

[]{#71xozq1488963926329
.anchor}我们用ECStack来表示处理执行上下文组的堆栈。我们很容易知道，第一步，首先是全局上下文入栈。

[]{#96yuis1488963926331 .anchor}

[]{#15keeu1488963926332 .anchor}第一步：全局上下文入栈

[]{#6amei1488963926332 .anchor}

[]{#40glgg1488963926332
.anchor}全局上下文入栈之后，其中的可执行代码开始执行，直到遇到了changeColor()，这一句激活函数changeColor创建它自己的执行上下文，因此第二步就是changeColor的执行上下文入栈。

[]{#83ufcu1488963926333 .anchor}

[]{#90bcfd1488963926334 .anchor}第二步：changeColor的执行上下文入栈

[]{#69lccy1488963926334 .anchor}

[]{#74euhq1488963926334
.anchor}changeColor的上下文入栈之后，控制器开始执行其中的可执行代码，遇到swapColors()之后又激活了一个执行上下文。因此第三步是swapColors的执行上下文入栈。

[]{#34sssk1488963926335 .anchor}

[]{#73vqek1488963926336 .anchor}第三步：swapColors的执行上下文入栈

[]{#45mzjv1488963926336 .anchor}

[]{#82umgw1488963926336
.anchor}在swapColors的可执行代码中，再没有遇到其他能生成执行上下文的情况，因此这段代码顺利执行完毕，swapColors的上下文从栈中弹出。

[]{#6gxkw1488963926338 .anchor}

[]{#59tnty1488963926338 .anchor}

[]{#97bkrc1488963926339 .anchor}第四步：swapColors的执行上下文出栈

[]{#98lkoq1488963926339 .anchor}

[]{#50hgty1488963926340
.anchor}swapColors的执行上下文弹出之后，继续执行changeColor的可执行代码，也没有再遇到其他执行上下文，顺利执行完毕之后弹出。这样，ECStack中就只身下全局上下文了。

[]{#13fegv1488963926341 .anchor}

[]{#7tugu1488963926341 .anchor}

[]{#17nwlb1488963926341 .anchor}第五步：changeColor的执行上下文出栈

[]{#5qtfx1488963926343 .anchor}

[]{#65zvvp1488963926343 .anchor}全局上下文在浏览器窗口关闭后出栈。

[]{#71vcmd1488963926343 .anchor}

> []{#40vgwf1488963926344
> .anchor}注意：函数中，遇到return能直接终止可执行代码的执行，因此会直接将当前上下文弹出栈。

[]{#58lism1488963926344 .anchor}

[]{#92dvzp1488963926344 .anchor}

[]{#4dohc1488963926344 .anchor}整个过程

[]{#22hpqq1488963926345 .anchor}

[]{#96amid1488963926345
.anchor}详细了解了这个过程之后，我们就可以对执行上下文总结一些结论了。

[]{#45mrbd1488963926346 .anchor}

[]{#96ojdr1488963926346 .anchor}单线程

[]{#44gawz1488963926347
.anchor}同步执行，只有栈顶的上下文处于执行中，其他上下文需要等待

[]{#75iwie1488963926347
.anchor}全局上下文只有唯一的一个，它在浏览器关闭时出栈

[]{#19khrl1488963926348 .anchor}函数的执行上下文的个数没有限制

[]{#41fnxh1488963926349
.anchor}每次某个函数被调用，就会有个新的执行上下文为其创建，即使是调用的自身函数，也是如此。

[]{#96mfqg1488963926349 .anchor}

[]{#26bbmo1488963926349
.anchor}为了巩固一下执行上下文的理解，我们再来绘制一个例子的演变过程，这是一个简单的闭包例子。

[]{#72laln1488963926350 .anchor}

> []{#58ifgt1488963926350 .anchor}**function** f1(){
>
> []{#10dhqw1488963926351 .anchor}    **var** n=999;
>
> []{#19mxss1488963926354 .anchor}    **function** f2(){
>
> []{#34ywcz1488963926355 .anchor}        **alert**(n);
>
> []{#67orch1488963926356 .anchor}    }
>
> []{#65qdft1488963926357 .anchor}    **return** f2;
>
> []{#49ofzd1488963926357 .anchor}}
>
> []{#95dkiw1488963926358 .anchor}**var** result=f1();
>
> []{#78uxqb1488963926359 .anchor}result(); *// 999*

[]{#39hsgj1488963926359 .anchor}

[]{#41rtxu1488963926360
.anchor}因为f1中的函数f2在f1的可执行代码中，并没有被调用执行，因此执行f1时，f2不会创建新的上下文，而直到result执行时，才创建了一个新的。具体演变过程如下。

[]{#57eiaq1488963926361 .anchor}

[]{#79hrts1488963926361 .anchor}

[]{#10fnpl1488963926361 .anchor}上例演变过程

[]{#13kufv1488963958380 .anchor}

[]{#12icyh1488963967107 .anchor}

[]{#20ntax1488963967413 .anchor}变量对象详解

[]{#42dzrl1488964006479 .anchor}

[]{#69igri1488964030800 .anchor}

[]{#50lqtp1488964030801 .anchor}

[]{#2jsar1488964030805 .anchor}

[]{#20pxhf1488964030805
.anchor}在JavaScript中，我们肯定不可避免的需要声明变量和函数，可是JS解析器是如何找到这些变量的呢？我们还得对执行上下文有一个进一步的了解。

[]{#29wftt1488964030807 .anchor}

[]{#74pzaz1488964030807
.anchor}在上一篇文章中，我们已经知道，当调用一个函数时（激活），一个新的执行上下文就会被创建。而一个执行上下文的生命周期可以分为两个阶段。

[]{#35wvfl1488964030810 .anchor}

[]{#28wyhb1488964030812 .anchor}创建阶段

[]{#34shtk1488964030813
.anchor}在这个阶段中，执行上下文会分别创建变量对象，建立作用域链，以及确定this的指向

[]{#65dwld1488964030817 .anchor}代码执行阶段

[]{#16wnjp1488964030818
.anchor}创建完成之后，就会开始执行代码，这个时候，会完成变量赋值，函数引用，以及执行其他代码。

[]{#33dctb1488964030820
.anchor}注：变量相对于简单属性来说，变量有一个特性(attribute)：{DontDelete},这个特性的含义就是不能用delete操作符直接删除变量属性。通常，各类文章和JavaScript相关的书籍都声称：“不管是使用var关键字(在全局上下文)还是不使用var关键字(在任何地方)，都可以声明一个变量”。请记住，这是错误的概念：

[]{#15wxtj1489471814356
.anchor}任何时候，变量只能通过使用var关键字才能声明。a = 10;

[]{#46wuah1489471836758
.anchor}这仅仅是给全局对象创建了一个新属性(但它不是变量)。“不是变量”并不是说它不能被改变，而是指它不符合ECMAScript规范中的变量概念，所以它“不是变量”(它之所以能成为全局对象的属性，完全是因为VO(globalContext)
=== global

[]{#60fafj1488964030826 .anchor}执行上下文生命周期

[]{#74qinz1488964030827 .anchor}

[]{#45nunt1488964030828
.anchor}从这里我们就可以看出详细了解执行上下文极为重要，因为其中涉及到了变量对象，作用域链，this等很多人没有怎么弄明白，但是却极为重要的概念，因此它关系到我们能不能真正理解JavaScript。在后面的文章中我们会一一详细总结，这里我们先重点了解变量对象。

[]{#43fwof1488964030831 .anchor}

[]{#16tbrw1488964030835 .anchor}**变量对象（Variable Object）**

[]{#75nscr1488964030836 .anchor}

[]{#91sjrx1488964030836 .anchor}变量对象的创建，依次经历了以下几个过程。

[]{#73fomt1488964030841 .anchor}

[]{#64tvmx1488964030843
.anchor}建立arguments对象。检查当前上下文中的参数，建立该对象下的属性与属性值。

[]{#7tuyg1488964030846
.anchor}检查当前上下文的函数声明，也就是使用function关键字声明的函数。在变量对象中以函数名建立一个属性，属性值为指向该函数所在内存地址的引用。如果函数名的属性已经存在，那么该属性将会被新的引用所覆盖。

[]{#64qkta1488964030850
.anchor}检查当前上下文中的变量声明，每找到一个变量声明，就在变量对象中以变量名建立一个属性，属性值为undefined。如果该变量名的属性已经存在，为了防止同名的函数被修改为undefined，则会直接跳过，原属性值不会被修改。

[]{#78cwph1488964030852 .anchor}

[]{#58busb1488964030853 .anchor}我知道有的人不喜欢看文字

[]{#59joxk1488964030854 .anchor}

[]{#13abcf1488964030854
.anchor}根据这个规则，理解变量提升就变得十分简单了。在很多文章中虽然提到了变量提升，但是具体是怎么回事还真的很多人都说不出来，以后在面试中用变量对象的创建过程跟面试官解释变量提升，保证瞬间提升逼格。

[]{#19yknj1488964030856 .anchor}

[]{#88drcy1488964030856
.anchor}在上面的规则中我们看出，function声明会比var声明优先级更高一点。为了帮助大家更好的理解变量对象，我们结合一些简单的例子来进行探讨。

[]{#71xapo1488964030857 .anchor}

> []{#74mvtr1488964030858 .anchor}*// demo01*
>
> []{#32wzac1488964030861 .anchor}**function** test() {
>
> []{#77xraz1488964030863 .anchor}    console.log(a);
>
> []{#76omff1488964030865 .anchor}    console.log(foo());
>
> []{#4vzan1488964030866 .anchor} 
>
> []{#16ktau1488964030868 .anchor}    **var** a = 1;
>
> []{#50uzcl1488964030870 .anchor}    **function** foo() {
>
> []{#77bsxq1488964030873 .anchor}        **return** 2;
>
> []{#15xptx1488964030874 .anchor}    }
>
> []{#86flwn1488964030875 .anchor}}
>
> []{#73wyak1488964030875 .anchor} 
>
> []{#3rhid1488964030877 .anchor}test();

[]{#63beck1488964030878 .anchor}

[]{#57qlpw1488964030878
.anchor}在上例中，我们直接从test()的执行上下文开始理解。全局作用域中运行test()时，test()的执行上下文开始创建。为了便于理解，我们用如下的形式来表示

[]{#10foxw1488964030879 .anchor}

> []{#45wudr1488964030879 .anchor}创建过程
>
> []{#99jjhr1488964030880 .anchor}testEC = {
>
> []{#39szas1488964030880 .anchor}    *// 变量对象*
>
> []{#58urgw1488964030881 .anchor}    VO: {},
>
> []{#36hjpn1488964030882 .anchor}    scopeChain: {},
>
> []{#53mtnh1488964030882 .anchor}    **this**: {}
>
> []{#16clyg1488964030883 .anchor}}
>
> []{#33zzkq1488964030883 .anchor} 
>
> []{#27gedu1488964030883 .anchor}*//
> 因为本文暂时不详细解释作用域链和this，所以把变量对象专门提出来说明*
>
> []{#5qgfr1488964030884 .anchor} 
>
> []{#22iwyy1488964030884 .anchor}*// VO 为 Variable
> Object的缩写，即变量对象*
>
> []{#50rmul1488964030885 .anchor}VO = {
>
> []{#80iwpq1488964030886
> .anchor}    arguments: {...},  *//注：在浏览器的展示中，函数的参数可能并不是放在arguments对象中，这里为了方便理解，我做了这样的处理*
>
> []{#36ieka1488964030888 .anchor}    foo: &lt;foo reference&gt;  *//
> 表示foo的地址引用*
>
> []{#9sikv1488964030888 .anchor}    a: undefined
>
> []{#35fwdt1488964030889 .anchor}}

[]{#91zxdy1488964030889 .anchor}

[]{#54kgsh1488964030889
.anchor}未进入执行阶段之前，变量对象中的属性都不能访问！但是进入执行阶段之后，变量对象转变为了活动对象，里面的属性都能被访问了，然后开始进行执行阶段的操作。

[]{#4qkte1488964030890 .anchor}

> []{#54eupb1488964030890
> .anchor}这样，如果再面试的时候被问到变量对象和活动对象有什么区别，就又可以自如的应答了，他们其实都是同一个对象，只是处于执行上下文的不同生命周期。

[]{#93krnb1488964030891 .anchor}

> []{#84rmsz1488964030891 .anchor}*// 执行阶段*
>
> []{#25eizv1488964030892 .anchor}VO -&gt;  AO   *// Active Object*
>
> []{#78qntf1488964030893 .anchor}AO = {
>
> []{#82ebul1488964030894 .anchor}    arguments: {...},
>
> []{#19akbx1488964030895 .anchor}    foo: &lt;foo reference&gt;,
>
> []{#92bdcn1488964030896 .anchor}    a: 1
>
> []{#87iupb1488964030897 .anchor}}

[]{#24fhho1488964030897 .anchor}

[]{#5xfsf1488964030898
.anchor}因此，上面的例子demo1，执行顺序就变成了这样

[]{#65ufal1488964030898 .anchor}

> []{#56eops1488964030899 .anchor}**function** test() {
>
> []{#19bmkt1488964030900 .anchor}    **function** foo() {
>
> []{#70jtbd1488964030901 .anchor}        **return** 2;
>
> []{#25eilx1488964030901 .anchor}    }
>
> []{#27vcoy1488964030902 .anchor}    **var** a;
>
> []{#57oxcf1488964030903 .anchor}    console.log(a);
>
> []{#70adnm1488964030904 .anchor}    console.log(foo());
>
> []{#81gdeh1488964030905 .anchor}    a = 1;
>
> []{#87nvaf1488964030905 .anchor}}
>
> []{#76gogx1488964030905 .anchor} 
>
> []{#30bzlo1488964030905 .anchor}test();

[]{#5xoft1488964030906 .anchor}

[]{#40idfb1488964030906 .anchor}再来一个例子，巩固一下我们的理解。

[]{#71xudj1488964030906 .anchor}

> []{#19pbci1488964030907 .anchor}*// demo2*
>
> []{#89ujqu1488964030908 .anchor}**function** test() {
>
> []{#1pxkp1488964030910 .anchor}    console.log(foo);
>
> []{#83lxro1488964030910 .anchor}    console.log(bar);
>
> []{#96mowt1488964030911 .anchor} 
>
> []{#95iyjv1488964030912 .anchor}    **var** foo = 'Hello';
>
> []{#84nhul1488964030913 .anchor}    console.log(foo);
>
> []{#83onjp1488964030914 .anchor}    **var** bar = **function** () {
>
> []{#82axtw1488964030915 .anchor}        **return** 'world';
>
> []{#36alye1488964030915 .anchor}    }
>
> []{#29mexk1488964030916 .anchor} 
>
> []{#44xetj1488964030917 .anchor}    **function** foo() {
>
> []{#15xxyt1488964030918 .anchor}        **return** 'hello';
>
> []{#44jwwb1488964030919 .anchor}    }
>
> []{#76mchw1488964030919 .anchor}}
>
> []{#80heay1488964030919 .anchor} 
>
> []{#71xkzt1488964030919 .anchor}test();

[]{#90zmcp1488964030920 .anchor}

> []{#1dbfw1488964030920 .anchor}*// 创建阶段*
>
> []{#87annj1488964030921 .anchor}VO = {
>
> []{#75kzug1488964030921 .anchor}    arguments: {...},
>
> []{#58ejxc1488964030922 .anchor}    foo: &lt;foo reference&gt;,
>
> []{#53nncl1488964030923 .anchor}    bar: undefined
>
> []{#80jqgo1488964030923 .anchor}}
>
> []{#34qolo1488964030923 .anchor}*//
> 这里有一个需要注意的地方，因为var声明的变量当遇到同名的属性时，会跳过而不会覆盖*

[]{#52awqh1488964030924 .anchor}

> []{#88pxno1488964030924 .anchor}*// 执行阶段*
>
> []{#94taax1488964030925 .anchor}VO -&gt; AO
>
> []{#88etvg1488964030925 .anchor}VO = {
>
> []{#43eflz1488964030926 .anchor}    arguments: {...},
>
> []{#77gcce1488964030928 .anchor}    foo: 'Hello',
>
> []{#3sxbs1488964030928 .anchor}    bar: &lt;bar reference&gt;
>
> []{#86ycuv1488964030929 .anchor}}

[]{#39ijzi1488964030929 .anchor}

[]{#7cfvx1488964030929
.anchor}需要结合上面的知识，仔细对比这个例子中变量对象从创建阶段到执行阶段的变化，如果你已经理解了，说明变量对象相关的东西都已经难不倒你了。

[]{#74mdve1488964030930 .anchor}

[]{#99tvbb1488964030930 .anchor}**全局上下文的变量对象**

[]{#66rjmd1488964030930 .anchor}

[]{#89kwmj1488964030930 .anchor}以浏览器中为例，全局对象为window。

[]{#20exdi1488964030932
.anchor}全局上下文有一个特殊的地方，它的变量对象，就是window对象。而这个特殊，在this指向上也同样适用，this也是指向window。

[]{#99xgfs1488964030932 .anchor}

> []{#89gqtv1488964030932 .anchor}*// 以浏览器中为例，全局对象为window*
>
> []{#69vvoo1488964030933 .anchor}*// 全局上下文*
>
> []{#82akgg1488964030933 .anchor}windowEC = {
>
> []{#59wbxj1488964030934 .anchor}    VO: **window**,
>
> []{#71yupm1488964030935 .anchor}    scopeChain: {},
>
> []{#20etir1488964030935 .anchor}    **this**: **window**
>
> []{#46ugqh1488964030936 .anchor}}

[]{#75bfwa1488964030936 .anchor}

[]{#91jrdc1488964030936
.anchor}除此之外，全局上下文的生命周期，与程序的生命周期一致，只要程序运行不结束，比如关掉浏览器窗口，全局上下文就会一直存在。其他所有的上下文环境，都能直接访问全局上下文的属性。

[]{#80gpqn1489459361175 .anchor}

[]{#51qxbp1489459361588 .anchor}

[]{#30knol1489459691349 .anchor}

[]{#39cnkq1489459691350 .anchor}攻克闭包难题

[]{#58mzlc1489459691351 .anchor}

[]{#74wuoz1489459691352
.anchor}初学JavaScript的时候，我在学习闭包上，走了很多弯路。而这次重新回过头来对基础知识进行梳理，要讲清楚闭包，也是一个非常大的挑战。

[]{#58opep1489459691355 .anchor}

[]{#28vajk1489459691355
.anchor}闭包有多重要？如果你是初入前端的朋友，我没有办法直观的告诉你闭包在实际开发中的无处不在，但是我可以告诉你，前端面试，必问闭包。面试官们常常用对闭包的了解程度来判定面试者的基础水平，保守估计，10个前端面试者，至少5个都死在闭包上。

[]{#97jakk1489459691357 .anchor}

[]{#25asbk1489459691357
.anchor}可是为什么，闭包如此重要，还是有那么多人没有搞清楚呢？是因为大家不愿意学习吗？还真不是，而是我们通过搜索找到的大部分讲解闭包的中文文章，都没有清晰明了的把闭包讲解清楚。要么浅尝辄止，要么高深莫测，要么干脆就直接乱说一通。包括我自己曾经也写过一篇关于闭包的总结，回头一看，不忍直视\[捂脸\]。

[]{#24wqci1489459691359 .anchor}

[]{#31vtpt1489459691359
.anchor}因此本文的目的就在于，能够清晰明了得把闭包说清楚，让读者老爷们看了之后，就把闭包给彻底学会了，而不是似懂非懂。

[]{#68qxis1489459691360 .anchor}

[]{#1pcqg1489459691361 .anchor}**一、作用域与作用域链**

[]{#79ywud1489459691362 .anchor}

[]{#30hybg1489459691362
.anchor}在详细讲解作用域链之前，我默认你已经大概明白了JavaScript中的下面这些重要概念。这些概念将会非常有帮助。

[]{#7ouxe1489459691363 .anchor}

[]{#51wvwt1489459691365 .anchor}基础数据类型与引用数据类型

[]{#68nihw1489459691366 .anchor}内存空间

[]{#90swsn1489459691367 .anchor}垃圾回收机制

[]{#39qdxf1489459691367 .anchor}执行上下文

[]{#43oujc1489459691368 .anchor}变量对象与活动对象

[]{#46uiad1489459691368 .anchor}

[]{#71nsrw1489459691368
.anchor}如果你暂时还没有明白，可以去看本系列的前三篇文章，本文文末有目录链接。为了讲解闭包，我已经为大家做好了基础知识的铺垫。哈哈，真是好大一出戏。

[]{#45jkqn1489459691369 .anchor}

[]{#36ncnp1489459691369 .anchor}**作用域**

[]{#58tycb1489459691370 .anchor}

[]{#35hlpz1489459691370
.anchor}在JavaScript中，我们可以将作用域定义为一套规则,这套规则用来管理引擎如何在当前作用域以及嵌套的子作用域中根据标识符名称进行变量查找。

[]{#78ajiv1489459691371 .anchor}这里的标识符，指的是变量名或者函数名

[]{#65ptgl1489459691372
.anchor}JavaScript中只有全局作用域与函数作用域(因为eval我们平时开发中几乎不会用到它，这里不讨论)。

[]{#70oprv1489459691373
.anchor}作用域与执行上下文是完全不同的两个概念。我知道很多人会混淆他们，但是一定要仔细区分。

[]{#20aumy1489459691374
.anchor}JavaScript代码的整个执行过程，分为两个阶段，代码编译阶段与代码执行阶段。编译阶段由编译器完成，将代码翻译成可执行代码，这个阶段作用域规则会确定。执行阶段由引擎完成，主要任务是执行可执行代码，执行上下文在这个阶段创建。

[]{#33svas1489459691375 .anchor}

[]{#12mvsb1489459691375 .anchor}

[]{#11skfl1489459691376 .anchor}

[]{#70cqgm1489459691376 .anchor}**作用域链**

[]{#72gark1489459691379
.anchor}回顾一下上一篇文章我们分析的执行上下文的生命周期，如下图。

[]{#13fgqj1489459691380 .anchor}

[]{#1yumc1489459691380 .anchor}执行上下文生命周期

[]{#0osks1489459691382
.anchor}我们发现，作用域链是在执行上下文的创建阶段生成的。这个就奇怪了。上面我们刚刚说作用域在编译阶段确定规则，可是为什么作用域链却在执行阶段确定呢？

[]{#47bolk1489459691384
.anchor}之所有有这个疑问，是因为大家对作用域和作用域链有一个误解。我们上面说了，作用域是一套规则，那么作用域链是什么呢？是这套规则的具体实现。所以这就是作用域与作用域链的关系，相信大家都应该明白了吧。

[]{#40lapn1489459691386
.anchor}我们知道函数在调用激活时，会开始创建对应的执行上下文，在执行上下文生成的过程中，变量对象，作用域链，以及this的值会分别被确定。之前一篇文章我们详细说明了变量对象，而这里，我们将详细说明作用域链。

[]{#90wpgi1489459691387
.anchor}作用域链，是由当前环境与上层环境的一系列变量对象组成，它保证了当前执行环境对符合访问权限的变量和函数的有序访问。

[]{#23ysjw1489459691388
.anchor}为了帮助大家理解作用域链，我我们先结合一个例子，以及相应的图示来说明。

> []{#38mfzr1489459691390 .anchor}**var** a = 20; 
>
> []{#31ldqs1489459691392 .anchor}**function** test() {
>
> []{#13dvmx1489459691394 .anchor}    **var** b = a + 10; 
>
> []{#49dfqq1489459691396 .anchor}    **function** innerTest() {
>
> []{#16azra1489459691401 .anchor}        **var** c = 10;
>
> []{#70swta1489459691403 .anchor}        **return** b + c;
>
> []{#98hpts1489459691403 .anchor}    }
>
> []{#78yuub1489459691403 .anchor} 
>
> []{#2gdnj1489459691405 .anchor}    **return** innerTest();
>
> []{#79slyt1489459691406 .anchor}}
>
> []{#20xlhy1489459691406 .anchor} 
>
> []{#8coqg1489459691407 .anchor}test();

[]{#57zceb1489459691407 .anchor}

[]{#63tpti1489459691408
.anchor}在上面的例子中，全局，函数test，函数innerTest的执行上下文先后创建。我们设定他们的变量对象分别为VO(global)，VO(test),
VO(innerTest)。而innerTest的作用域链，则同时包含了这三个变量对象，所以innerTest的执行上下文可如下表示。

> []{#29uayb1489459691409 .anchor}innerTestEC = {
>
> []{#74fqvc1489459691410 .anchor}    VO: {...},  *// 变量对象*
>
> []{#75xvff1489459691413
> .anchor}    scopeChain: \[VO(innerTest), VO(test), VO(global)\], *//
> 作用域链*
>
> []{#43bjgb1489459691416 .anchor}    **this**: {}
>
> []{#98vkdr1489459691416 .anchor}}

[]{#24gvnh1489459691418
.anchor}是的，你没有看错，我们可以直接用一个数组来表示作用域链，数组的第一项scopeChain\[0\]为作用域链的最前端，而数组的最后一项，为作用域链的最末端，所有的最末端都为全局变量对象。

[]{#32flpp1489459691419
.anchor}很多人会误解为当前作用域与上层作用域为包含关系，但其实并不是。以最前端为起点，最末端为终点的单方向通道我认为是更加贴切的形容。如图。

[]{#42qajq1489459691421 .anchor}

[]{#13mlfa1489459691422 .anchor}作用域链图示

[]{#22tndp1489459691424 .anchor}

[]{#26vgmt1489459691424
.anchor}注意，因为变量对象在执行上下文进入执行阶段时，就变成了活动对象，这一点在上一篇文章中已经讲过，因此图中使用了AO来表示。Active
Object

[]{#64tegr1489459691425
.anchor}是的，作用域链是由一系列变量对象组成，我们可以在这个单向通道中，查询变量对象中的标识符，这样就可以访问到上一层作用域中的变量了。

[]{#58wbnn1489459691426 .anchor}**二、闭包**

[]{#13qgaw1489459691428 .anchor}对于那些有一点 JavaScript
使用经验但从未真正理解闭包概念的人来说，理解闭包可以看作是某种意义上的重生，突破闭包的瓶颈可以使你功力大增。

[]{#27dsor1489459691430 .anchor}闭包与作用域链息息相关；

[]{#60chck1489459691430 .anchor}闭包是在函数执行过程中被确认。

[]{#10kbpq1489459691431
.anchor}先直截了当的抛出闭包的定义：当函数可以记住并访问所在的作用域(全局作用域除外)时，就产生了闭包，即使函数是在当前作用域之外执行。

[]{#62dklq1489459691431 .anchor}

> []{#60ybsz1489459691432
> .anchor}简单来说，假设函数A在函数B的内部进行定义了，并且当函数A在执行时，访问了函数B内部的变量对象，那么B就是一个闭包。

[]{#71edof1489459691432 .anchor}

[]{#55lmmm1489459691432
.anchor}非常抱歉之前对于闭包定义的描述有一些不准确，现在已经改过，希望收藏文章的同学再看到的时候能看到吧，对不起大家了。

[]{#33qomk1489459691433 .anchor}

[]{#44apod1489459691434
.anchor}在基础进阶（一）中，我总结了JavaScript的垃圾回收机制。JavaScript拥有自动的垃圾回收机制，关于垃圾回收机制，有一个重要的行为，那就是，当一个值，在内存中失去引用时，垃圾回收机制会根据特殊的算法找到它，并将其回收，释放内存。

[]{#11xbog1489459691435 .anchor}

[]{#41ntit1489459691435
.anchor}而我们知道，函数的执行上下文，在执行完毕之后，生命周期结束，那么该函数的执行上下文就会失去引用。其占用的内存空间很快就会被垃圾回收器释放。可是闭包的存在，会阻止这一过程。

[]{#46hqxv1489459691436 .anchor}

[]{#61rjfg1489459691436 .anchor}先来一个简单的例子。

[]{#27hgzu1489459691436 .anchor}

> []{#13vuah1489459691437 .anchor}**var** fn = **null**;
>
> []{#97okgs1489459691438 .anchor}**function** foo() {
>
> []{#89lufg1489459691440 .anchor}    **var** a = 2;
>
> []{#41kbng1489459691442 .anchor}    **function** innnerFoo() {
>
> []{#88xycz1489459691443 .anchor}        console.log(a);
>
> []{#42tyqd1489459691443 .anchor}    }
>
> []{#16xosp1489459691445 .anchor}    fn = innnerFoo; *// 将
> innnerFoo的引用，赋值给全局变量中的fn*
>
> []{#43xcdk1489459691445 .anchor}}
>
> []{#36icbz1489459691446 .anchor} 
>
> []{#79poqw1489459691446 .anchor}**function** bar() {
>
> []{#61runh1489459691447 .anchor}    fn(); *//
> 此处的保留的innerFoo的引用*
>
> []{#78xjkz1489459691447 .anchor}}
>
> []{#80bgnz1489459691448 .anchor} 
>
> []{#53vvds1489459691449 .anchor}foo();
>
> []{#59damw1489459691450 .anchor}bar(); *// 2*

[]{#41bqbb1489459691450 .anchor}

[]{#75cuoo1489459691450
.anchor}在上面的例子中，foo()执行完毕之后，按照常理，其执行环境生命周期会结束，所占内存被垃圾收集器释放。但是通过fn
=
innerFoo，函数innerFoo的引用被保留了下来，复制给了全局变量fn。这个行为，导致了foo的变量对象，也被保留了下来。于是，函数fn在函数bar内部执行时，依然可以访问这个被保留下来的变量对象。所以此刻仍然能够访问到变量a的值。

[]{#20ujov1489459691452 .anchor}

[]{#0nttj1489459691453 .anchor}这样，我们就可以称foo为闭包。

[]{#45juhb1489459691453 .anchor}

[]{#1kmya1489459691453 .anchor}下图展示了闭包fn的作用域链。

[]{#15nlsr1489459691453 .anchor}

[]{#19cteb1489459691454 .anchor}

[]{#54pwcr1489459691454 .anchor}闭包fn的作用域链

[]{#37xosv1489459691454 .anchor}

[]{#89yuse1489459691454
.anchor}我们可以在chrome浏览器的开发者工具中查看这段代码运行时产生的函数调用栈与作用域链的生成情况。如下图。

[]{#92bvco1489459691455 .anchor}

[]{#17ytij1489459691455 .anchor}

[]{#45boqk1489459691456 .anchor}

[]{#20ndni1489459691456
.anchor}从图中可以看出，chrome浏览器认为闭包是foo，而不是通常我们认为的

[]{#17joyj1489459691456
.anchor}innerFoo在上面的图中，红色箭头所指的正是闭包。其中Call
Stack为当前的函数调用栈，Scope为当前正在被执行的函数的作用域链，Local为当前的局部变量。

[]{#56llxg1489459691457 .anchor}

[]{#64plnk1489459691458
.anchor}所以，通过闭包，我们可以在其他的执行上下文中，访问到函数的内部变量。比如在上面的例子中，我们在函数bar的执行环境中访问到了函数foo的a变量。个人认为，从应用层面，这是闭包最重要的特性。利用这个特性，我们可以实现很多有意思的东西。

[]{#91httw1489459691459 .anchor}

[]{#55iglw1489459691459
.anchor}不过读者老爷们需要注意的是，虽然例子中的闭包被保存在了全局变量中，但是闭包的作用域链并不会发生任何改变。在闭包中，能访问到的变量，仍然是作用域链上能够查询到的变量。

[]{#89vqzk1489459691460 .anchor}

[]{#62krta1489459691460
.anchor}对上面的例子稍作修改，如果我们在函数bar中声明一个变量c，并在闭包fn中试图访问该变量，运行结果会抛出错误。

[]{#20dbza1489459691462 .anchor}

> []{#64qoet1489459691463 .anchor}**var** fn = **null**;
>
> []{#79labk1489459691464 .anchor}**function** foo() {
>
> []{#24faxp1489459691465 .anchor}    **var** a = 2;
>
> []{#51krgz1489459691466 .anchor}    **function** innnerFoo() {
>
> []{#12wytb1489459691468 .anchor}        console.log(c); *//
> 在这里，试图访问函数bar中的c变量，会抛出错误*
>
> []{#46mgry1489459691469 .anchor}        console.log(a);
>
> []{#36ntmi1489459691470 .anchor}    }
>
> []{#64kwtf1489459691471 .anchor}    fn = innnerFoo; *// 将
> innnerFoo的引用，赋值给全局变量中的fn*
>
> []{#77evqu1489459691471 .anchor}}
>
> []{#41mfpm1489459691472 .anchor} 
>
> []{#40etnf1489459691472 .anchor}**function** bar() {
>
> []{#59ojpm1489459691476 .anchor}    **var** c = 100;
>
> []{#21rjwl1489459691476 .anchor}    fn(); *//
> 此处的保留的innerFoo的引用*
>
> []{#34yflf1489459691477 .anchor}}
>
> []{#92bafo1489459691477 .anchor} 
>
> []{#4xehu1489459691478 .anchor}foo();
>
> []{#87ugag1489459691478 .anchor}bar();

[]{#14qlvf1489459691478 .anchor}

[]{#40tfdi1489459691479 .anchor}**闭包的应用场景**

[]{#91pjhw1489459691479 .anchor}

[]{#78hmpn1489459691480 .anchor}接下来，我们来总结下，闭包的常用场景。

[]{#95vbco1489459691480 .anchor}

[]{#27ntew1489459691481 .anchor}延迟函数setTimeout

[]{#69gngf1489459691482 .anchor}

[]{#18pcai1489459691482
.anchor}我们知道setTimeout的第一个参数是一个函数，第二个参数则是延迟的时间。在下面例子中，

[]{#9rjae1489459691483 .anchor}

> []{#53ivrk1489459691485 .anchor}**function** fn() {
>
> []{#22yavw1489459691486 .anchor}    console.log('this is test.')
>
> []{#3rbzq1489459691486 .anchor}}
>
> []{#81ujzh1489459691488
> .anchor}**var** timer =  **setTimeout**(fn, 1000);
>
> []{#28zcnq1489459691490 .anchor}console.log(timer);

[]{#19yopi1489459691490 .anchor}

[]{#82tizt1489459691490
.anchor}执行上面的代码，变量timer的值，会立即输出出来，表示setTimeout这个函数本身已经执行完毕了。但是一秒钟之后，fn才会被执行。这是为什么？

[]{#86alrz1489459691491 .anchor}

[]{#9mjdx1489459691491
.anchor}按道理来说，既然fn被作为参数传入了setTimeout中，那么fn将会被保存在setTimeout变量对象中，setTimeout执行完毕之后，它的变量对象也就不存在了。可是事实上并不是这样。至少在这一秒钟的事件里，它仍然是存在的。这正是因为闭包。

[]{#97bdet1489459691492 .anchor}

[]{#74qhms1489459691492
.anchor}很显然，这是在函数的内部实现中，setTimeout通过特殊的方式，保留了fn的引用，让setTimeout的变量对象，并没有在其执行完毕后被垃圾收集器回收。因此setTimeout执行结束后一秒，我们任然能够执行fn函数。

[]{#85vunu1489459691493 .anchor}

[]{#32zncl1489459691494 .anchor}柯里化

[]{#38gbpx1489459691494 .anchor}

[]{#59rbhf1489459691494
.anchor}在函数式编程中，利用闭包能够实现很多炫酷的功能，柯里化算是其中一种。关于柯里化，我会在以后详解函数式编程的时候仔细总结。

[]{#94qhpg1489459691495 .anchor}

[]{#1suqa1489459691495 .anchor}模块

[]{#66dbnz1489459691496 .anchor}

[]{#24nttl1489459691496
.anchor}在我看来，模块是闭包最强大的一个应用场景。如果你是初学者，对于模块的了解可以暂时不用放在心上，因为理解模块需要更多的基础知识。但是如果你已经有了很多JavaScript的使用经验，在彻底了解了闭包之后，不妨借助本文介绍的作用域链与闭包的思路，重新理一理关于模块的知识。这对于我们理解各种各样的设计模式具有莫大的帮助。

[]{#94nvkd1489459691497 .anchor}

> []{#49msxg1489459691499 .anchor}(**function** () {
>
> []{#90nvtn1489459691500 .anchor}    **var** a = 10;
>
> []{#77dbnb1489459691501 .anchor}    **var** b = 20;
>
> []{#6imeh1489459691502 .anchor} 
>
> []{#38zdwj1489459691504 .anchor}    **function** add(num1, num2) {
>
> []{#30umxo1489459691505 .anchor}        **var** num1 =
> !!num1 ? num1 : a;
>
> []{#45sctm1489459691507 .anchor}        **var** num2 =
> !!num2 ? num2 : b;
>
> []{#29qdwf1489459691507 .anchor} 
>
> []{#85nihr1489459691508 .anchor}        **return** num1 + num2;
>
> []{#19ufvh1489459691509 .anchor}    }
>
> []{#27epsy1489459691509 .anchor} 
>
> []{#57vpdx1489459691510 .anchor}    window.add = add;
>
> []{#36ilqs1489459691510 .anchor}})();
>
> []{#79mnbz1489459691511 .anchor} 
>
> []{#67tpfu1489459691512 .anchor}add(10, 20);

[]{#63zuty1489459691512 .anchor}

[]{#42judu1489459691512
.anchor}在上面的例子中，我使用函数自执行的方式，创建了一个模块。方法add被作为一个闭包，对外暴露了一个公共方法。而变量a，b被作为私有变量。在面向对象的开发中，我们常常需要考虑是将变量作为私有变量，还是放在构造函数中的this中，因此理解闭包，以及原型链是一个非常重要的事情。模块十分重要，因此我会在以后的文章专门介绍，这里就暂时不多说啦。

[]{#80idkv1489459691513 .anchor}

[]{#66gnwf1489459691513 .anchor}

[]{#94mtue1489459691513 .anchor}

[]{#81svsf1489459691513
.anchor}此图中可以观看到当代码执行到add方法时的调用栈与作用域链，此刻的闭包为外层的自执行函数

[]{#54vpue1489459691514
.anchor}为了验证自己有没有搞懂作用域链与闭包，这里留下一个经典的思考题，常常也会在面试中被问到。

[]{#30ftcv1489459691514 .anchor}

[]{#81sspg1489459691514
.anchor}利用闭包，修改下面的代码，让循环输出的结果依次为1， 2， 3， 4，
5

[]{#29ixvd1489459691515 .anchor}

> []{#2cshj1489459691517 .anchor}**for** (**var** i=1; i&lt;=5; i++) {
>
> []{#39tpeu1489459691518
> .anchor}    **setTimeout**( **function** timer() {
>
> []{#9gvvp1489459691519 .anchor}        console.log(i);
>
> []{#93ejya1489459691520 .anchor}    }, i\*1000 );
>
> []{#83kony1489459691521 .anchor}}

[]{#68okkm1489459691521 .anchor}

[]{#69yqom1489459691521 .anchor}关于作用域链的与闭包我就总结完了。

[]{#73gklp1489459771403 .anchor}

[]{#70pces1489459772218
.anchor}比如对于this指向的理解中，有这样一种说法：谁调用它，this就指向谁。在我刚开始学习this的时候，我是非常相信这句话的。因为在一些情况下，这样理解也还算说得通。可是我常常会在开发中遇到一些不一样的情况，一个由于this的错误调用，可以让我懵逼一整天。那个时候我也查资料，在群里问大神，可是我仍然搞不清楚“我特么到底错哪里了”。其实只是因为我心中有一个不太准确的结论。

[]{#18ysfg1489459825947 .anchor}

> []{#57jvga1489459825948
> .anchor}这里吐槽一下百度搜索，搜索出来的文章，好多知识点都是错的，害了劳资好久

[]{#69naur1489459825948 .anchor}

[]{#40hwix1489459825948
.anchor}所以，我认为需要有这样一篇文章，来帮助大家全方位的解读this。让大家对this，有一个正确的，全面的认知。

[]{#10qipk1489459825950 .anchor}

[]{#14phpd1489459825950 .anchor}在这之前，我们需要来回顾一下执行上下文。

[]{#2wcqd1489459825950 .anchor}

[]{#29jsus1489459825951
.anchor}在前面几篇文章中，我有好几个地方都提到执行上下文的生命周期，为了防止大家没有记住，再次来回顾一下，如下图。

[]{#73vaua1489459825953 .anchor}

[]{#6caiw1489459825954 .anchor}

[]{#16xvmk1489459825954 .anchor}执行上下文生命周期

[]{#15imho1489459825955 .anchor}

[]{#54rxkv1489459825955
.anchor}在执行上下文的创建阶段，会分别生成变量对象，建立作用域链，确定this指向。其中变量对象与作用域链我们都已经仔细总结过了，而这里的关键，就是确定this指向。

[]{#31gqnb1489459825956 .anchor}

[]{#29pgmn1489459825956
.anchor}在这里，我们需要得出一个非常重要一定要牢记于心的结论，this的指向，是在函数被调用的时候确定的。也就是执行上下文被创建时确定的。因此我们可以很容易就能理解到，一个函数中的this指向，可以是非常灵活的。比如下面的例子中，同一个函数由于调用方式的不同，this指向了不一样的对象。

[]{#61xbpj1489459825957 .anchor}

> []{#38yaod1489459825960 .anchor}**var** a = 10;
>
> []{#51evan1489459825963 .anchor}**var** obj = {
>
> []{#71hdok1489459825965 .anchor}    a: 20
>
> []{#81ahfj1489459825965 .anchor}}
>
> []{#93niqr1489459825965 .anchor} 
>
> []{#37hjbm1489459825966 .anchor}**function** fn () {
>
> []{#34qhcy1489459825968 .anchor}    console.log(**this**.a);
>
> []{#62cucp1489459825968 .anchor}}
>
> []{#33byxi1489459825969 .anchor} 
>
> []{#37nair1489459825969 .anchor}fn(); *// 10*
>
> []{#19uzms1489459825971 .anchor}fn.call(obj); *// 20*

[]{#28rjgw1489483371224 .anchor}apply():
将函数作为指定对象的方法来调用，传递给它的是指定的参数数组

[]{#5uinf1489483371848 .anchor}　　　　 ——function.apply(thisobj, args)
或者 function.apply(thisobj, args)

[]{#72ierx1489483371849 .anchor}bind():
主要作用：将函数绑定到一个对象，返回一个新函数，通过可选的指定参数，作为指定对象的方法调用该方法

[]{#19mcxq1489483371849 .anchor}　　　　 ——function.bind(o)
或者是function.bind(o, args...);

[]{#9riqd1489483371850 .anchor}call():
类似apply，将函数作为指定对象的方法来调用，传递给它的是指定参数

[]{#92vcog1489483371850 .anchor}　　　　 ——function.call(thisobj,
args.....)

[]{#20dyra1489459825972
.anchor}注：call调用一个对象的一个方法，以另一个对象替换当前对象。
,apply应用某一对象的一个方法，用另一个对象替换当前对象。，这两个方法基本上是一个意思，区别在于
call
的第二个参数可以是任意类型，而apply的第二个参数必须是数组，也可以是arguments.call或apply的第一个参数传的是什么，它们就会将其默认为执行上下文对象。倘若我们没有指明call或apply的执行上下文对象，即，call和apply的第一个参数是null、undefined或为空时，在非严格模式下，函数内的this指向window或global，浏览器就是window。严格模式下，null为null，undefined或空为undefined。因为call或apply是将执行上下文对象换了后，立即执行；而bind是将执行上下文对象换了后，创建一个新函数。

[]{#67iudg1489459825972
.anchor}除此之外，在函数执行过程中，this一旦被确定，就不可更改了。

[]{#2emmh1489459825972 .anchor}

> []{#35zmzn1489459825974 .anchor}**var** a = 10;
>
> []{#61zbvy1489459825974 .anchor}**var** obj = {
>
> []{#28xdrm1489459825975 .anchor}    a: 20
>
> []{#59ceon1489459825975 .anchor}}
>
> []{#8evmu1489459825975 .anchor} 
>
> []{#89kmmi1489459825978 .anchor}**function** fn () {
>
> []{#85blfg1489459825979 .anchor}    **this** = obj; *//
> 这句话试图修改this，运行后会报错*
>
> []{#8cvde1489459825980 .anchor}    console.log(**this**.a);
>
> []{#4vflh1489459825981 .anchor}}
>
> []{#15qbqf1489459825981 .anchor} 
>
> []{#14wfhq1489459825981 .anchor}fn();

[]{#90rgqz1489459825982 .anchor}

[]{#53cqqb1489459825982 .anchor}**一、全局对象中的this**

[]{#11ctqy1489459825983 .anchor}

[]{#37ujfy1489459825984
.anchor}关于全局对象的this，我之前在总结变量对象的时候提到过，它是一个比较特殊的存在。全局环境中的this，指向它本身。因此，这也相对简单，没有那么多复杂的情况需要考虑。

[]{#90muwl1489459825985 .anchor}

> []{#35nbti1489459825985 .anchor}*// 通过this绑定到全局对象*
>
> []{#48euut1489459825986 .anchor}**this**.a2 = 20;
>
> []{#20mqms1489459825986 .anchor} 
>
> []{#74ajrm1489459825987 .anchor}*//
> 通过声明绑定到变量对象，但在全局环境中，变量对象就是它自身*
>
> []{#18worg1489459825989 .anchor}**var** a1 = 10;
>
> []{#11awtk1489459825989 .anchor} 
>
> []{#27xqxu1489459825990 .anchor}*//
> 仅仅只有赋值操作，标识符会隐式绑定到全局对象*
>
> []{#97dqie1489459825990 .anchor}a3 = 30;
>
> []{#5ysbd1489459825991 .anchor} 
>
> []{#31tbzz1489459825991 .anchor}*// 输出结果会全部符合预期*
>
> []{#35cvru1489459825993 .anchor}console.log(a1);
>
> []{#93gfnl1489459825996 .anchor}console.log(a2);
>
> []{#59vosh1489459825998 .anchor}console.log(a3);

[]{#34gtyv1489459826000 .anchor}

[]{#6dbis1489459826000 .anchor}**二、函数中的this**

[]{#11zqlv1489459826000 .anchor}

[]{#62zfrg1489459826000
.anchor}在总结函数中this指向之前，我想我们有必要通过一些奇怪的例子，来感受一下函数中this的捉摸不定。

[]{#96dwci1489459826002 .anchor}

> []{#96rtui1489459826002 .anchor}*// demo01*
>
> []{#88xkkm1489459826003 .anchor}**var** a = 20;
>
> []{#98nuab1489459826004 .anchor}**function** fn() {
>
> []{#13tzhq1489459826005 .anchor}    console.log(**this**.a);
>
> []{#14ijhc1489459826006 .anchor}}
>
> []{#42oyik1489459826006 .anchor}fn();

[]{#18bnrf1489459826006 .anchor}

> []{#79lfhw1489459826007 .anchor}*// demo02*
>
> []{#37gwgj1489459826007 .anchor}**var** a = 20;
>
> []{#68vpfb1489459826008 .anchor}**function** fn() {
>
> []{#86uxsb1489459826009 .anchor}    **function** foo() {
>
> []{#6knyw1489459826011 .anchor}        console.log(**this**.a);
>
> []{#64gzbw1489459826011 .anchor}    }
>
> []{#92vojf1489459826012 .anchor}    foo();
>
> []{#95pqhp1489459826013 .anchor}}
>
> []{#75hsql1489459826014 .anchor}fn();

[]{#93cexh1489459826015 .anchor}

> []{#79ltrp1489459826015 .anchor}*// demo03*
>
> []{#19msoh1489459826016 .anchor}**var** a = 20;
>
> []{#15jlal1489459826017 .anchor}**var** obj = {
>
> []{#21vmgd1489459826017 .anchor}    a: 10,
>
> []{#60djzh1489459826019 .anchor}    c: **this**.a + 20,
>
> []{#28etmf1489459826020 .anchor}    fn: **function** () {
>
> []{#32ltoo1489459826021 .anchor}        **return** **this**.a;
>
> []{#58ksbm1489459826022 .anchor}    }
>
> []{#38xxin1489459826022 .anchor}}
>
> []{#94whfz1489459826022 .anchor} 
>
> []{#50heoi1489459826023 .anchor}console.log(obj.c);
>
> []{#16wegp1489459826024 .anchor}console.log(obj.fn());

[]{#52sxxe1489459826025 .anchor}

[]{#65tser1489459826025
.anchor}这几个例子需要读者老爷们花点时间稍微感受一下，如果你暂时没想明白怎么回事，也不用着急，我们一点一点来分析。

[]{#98svas1489459826026 .anchor}

[]{#75aans1489459826026 .anchor}分析之前，我们先直接了当抛出结论。

[]{#1bybd1489459826027 .anchor}

[]{#53kvuu1489459826027
.anchor}在一个函数上下文中，this由调用者提供，由调用函数的方式来决定。如果调用者函数，被某一个对象所拥有，那么该函数在调用时，内部的this指向该对象。如果函数独立调用，那么该函数内部的this，则指向undefined。但是在非严格模式中，当this指向undefined时，它会被自动指向全局对象。

[]{#93ygks1489459826028 .anchor}

[]{#95jtfa1489459826028
.anchor}从结论中我们可以看出，想要准确确定this指向，找到函数的调用者以及区分他是否是独立调用就变得十分关键。

[]{#62hksl1489459826029 .anchor}

> []{#99ylpm1489459826029 .anchor}*//
> 为了能够准确判断，我们在函数内部使用严格模式，因为非严格模式会自动指向全局*
>
> []{#14cexm1489459826031 .anchor}**function** fn() {
>
> []{#4wgbi1489459826032 .anchor}    'use strict';
>
> []{#96yhnp1489459826032 .anchor}    console.log(**this**);
>
> []{#40ckng1489459826033 .anchor}}
>
> []{#26yexi1489459826033 .anchor} 
>
> []{#37idpn1489459826034 .anchor}fn();  *// fn是调用者，独立调用*
>
> []{#43sbis1489459826035 .anchor}window.fn();  *//
> fn是调用者，被window所拥有*

[]{#67rlql1489459826035 .anchor}

[]{#74vewn1489459826036
.anchor}在上面的简单例子中，fn()作为独立调用者，按照定义的理解，它内部的this指向就为undefined。而window.fn()则因为fn被window所拥有，内部的this就指向了window对象。

[]{#2lxuq1489459826037 .anchor}

[]{#36yhnz1489459826037
.anchor}那么掌握了这个规则，现在回过头去看看上面的三个例子，通过添加/去除严格模式，那么你就会发现，原来this已经变得不那么虚无缥缈，已经有迹可循了。

[]{#82yjfw1489459826038 .anchor}

[]{#44qjdu1489459826038
.anchor}但是我们需要特别注意的是demo03。在demo03中，对象obj中的c属性使用this.a
+
20来计算，而他的调用者obj.c并非是一个函数。因此他不适用于上面的规则，我们要对这种方式单独下一个结论。

[]{#54bagw1489459826038 .anchor}

[]{#84jcfg1489459826039
.anchor}当obj在全局声明时，无论obj.c在什么地方调用，这里的this都指向全局对象，而当obj在函数环境中声明时，这个this指向undefined，在非严格模式下，会自动转向全局对象。可运行下面的例子查看区别。

[]{#21orbx1489459826039 .anchor}

> []{#34qtvu1489459826040 .anchor}'use strict';
>
> []{#79fxxj1489459826041 .anchor}**var** a = 20;
>
> []{#51feed1489459826042 .anchor}**function** foo () {
>
> []{#36ugwe1489459826044 .anchor}    **var** a = 1;
>
> []{#58semr1489459826045 .anchor}    **var** obj = {
>
> []{#8skhu1489459826046 .anchor}        a: 10,
>
> []{#13xzto1489459826049 .anchor}        c: **this**.a + 20,
>
> []{#63wvkj1489459826050 .anchor}        fn: **function** () {
>
> []{#3abji1489459826051 .anchor}            **return** **this**.a;
>
> []{#48mumi1489459826052 .anchor}        }
>
> []{#44wusl1489459826052 .anchor}    }
>
> []{#29mgru1489459826053 .anchor}    **return** obj.c;
>
> []{#28dyog1489459826053 .anchor} 
>
> []{#16xrjd1489459826054 .anchor}}
>
> []{#41ifsr1489459826054 .anchor}console.log(foo()); *// 运行会报错*

[]{#70qpft1489459826056 .anchor}

[]{#48wqng1489459826059 .anchor}实际开发中，并不推荐这样使用this；

[]{#53zmlf1489459826061
.anchor}上面多次提到的严格模式，需要大家认真对待，因为在实际开发中，现在基本已经全部采用严格模式了，而最新的ES6，也是默认支持严格模式。

[]{#77lvrt1489459826061 .anchor}

[]{#62rvgh1489459826061
.anchor}再来看一些容易理解错误的例子，加深一下对调用者与是否独立运行的理解。

[]{#2qbdx1489459826063 .anchor}

> []{#20ruic1489459826064 .anchor}**var** a = 20;
>
> []{#15gjfu1489459826065 .anchor}**var** foo = {
>
> []{#5dxuk1489459826066 .anchor}    a: 10,
>
> []{#9bpgy1489459826067 .anchor}    getA: **function** () {
>
> []{#95eisy1489459826068 .anchor}        **return** **this**.a;
>
> []{#99qtfl1489459826069 .anchor}    }
>
> []{#4vzzi1489459826069 .anchor}}
>
> []{#48qnby1489459826070 .anchor}console.log(foo.getA()); *// 10*
>
> []{#32gvvi1489459826071 .anchor} 
>
> []{#41kpti1489459826072 .anchor}**var** test = foo.getA;
>
> []{#11cvqe1489459826073 .anchor}console.log(test());  *// 20*

[]{#65glrt1489459826073 .anchor}

[]{#80gagp1489459826073
.anchor}foo.getA()中，getA是调用者，他不是独立调用，被对象foo所拥有，因此它的this指向了foo。而test()作为调用者，尽管他与foo.getA的引用相同，但是它是独立调用的，因此this指向undefined，在非严格模式，自动转向全局window。

[]{#56peay1489459826075 .anchor}

[]{#49ubmd1489459826075 .anchor}稍微修改一下代码，大家自行理解。

[]{#57lqcd1489459826075 .anchor}

> []{#11nnbc1489459826076 .anchor}**var** a = 20;
>
> []{#59ylqv1489459826077 .anchor}**function** getA() {
>
> []{#38umnk1489459826079 .anchor}    **return** **this**.a;
>
> []{#10heen1489459826079 .anchor}}
>
> []{#30fryr1489459826080 .anchor}**var** foo = {
>
> []{#18ilzd1489459826080 .anchor}    a: 10,
>
> []{#7zzzm1489459826081 .anchor}    getA: getA
>
> []{#74zryn1489459826081 .anchor}}
>
> []{#72yomp1489459826082 .anchor}console.log(foo.getA());  *// 10*

[]{#8acxi1489459826083 .anchor}

[]{#43xqgt1489459826083 .anchor}灵机一动，再来一个。如下例子。

[]{#45fqht1489459826084 .anchor}

> []{#76qpzs1489459826084 .anchor}**function** foo() {
>
> []{#21nfot1489459826086 .anchor}    console.log(**this**.a)
>
> []{#14djjx1489459826086 .anchor}}
>
> []{#19nioi1489459826087 .anchor} 
>
> []{#3vdei1489459826088 .anchor}**function** active(fn) {
>
> []{#50syex1489459826088 .anchor}    fn(); *// 真实调用者，为独立调用*
>
> []{#98tbca1489459826089 .anchor}}
>
> []{#98ijbc1489459826089 .anchor} 
>
> []{#93gxqn1489459826090 .anchor}**var** a = 20;
>
> []{#39yoov1489459826090 .anchor}**var** obj = {
>
> []{#84gzde1489459826091 .anchor}    a: 10,
>
> []{#43stoz1489459826092 .anchor}    getA: foo
>
> []{#0qfdy1489459826092 .anchor}}
>
> []{#68cfqi1489459826092 .anchor} 
>
> []{#25nswy1489459826093 .anchor}active(obj.getA);

[]{#10cnak1489459826093 .anchor}

[]{#93grzo1489459826094 .anchor}**三、使用call，apply显示指定this**

[]{#77uojb1489459826094 .anchor}

[]{#21xvvo1489459826095
.anchor}JavaScript内部提供了一种机制，让我们可以自行手动设置this的指向。它们就是call与apply。所有的函数都具有着两个方法。它们除了参数略有不同，其功能完全一样。它们的第一个参数都为this将要指向的对象。

[]{#91lmyi1489459826097 .anchor}

[]{#49ttie1489459826098
.anchor}如下例子所示。fn并非属于对象obj的方法，但是通过call，我们将fn内部的this绑定为obj，因此就可以使用this.a访问obj的a属性了。这就是call/apply的用法。

[]{#94eaqo1489459826099 .anchor}

> []{#95gshc1489459826100 .anchor}**function** fn() {
>
> []{#72vfgk1489459826101 .anchor}    console.log(**this**.a);
>
> []{#27eeps1489459826101 .anchor}}
>
> []{#94ikpc1489459826102 .anchor}**var** obj = {
>
> []{#90iwop1489459826102 .anchor}    a: 20
>
> []{#23yqwk1489459826103 .anchor}}
>
> []{#97kntz1489459826103 .anchor} 
>
> []{#25lory1489459826104 .anchor}fn.call(obj);

[]{#83yaqh1489459826104 .anchor}

[]{#30jhvj1489459826104
.anchor}而call与applay后面的参数，都是向将要执行的函数传递参数。其中call以一个一个的形式传递，apply以数组的形式传递。这是他们唯一的不同。

[]{#45bzpk1489459826105 .anchor}

> []{#51jggu1489459826106 .anchor}**function** fn(num1, num2) {
>
> []{#19lfmq1489459826108
> .anchor}    console.log(**this**.a + num1 + num2);
>
> []{#19xofy1489459826109 .anchor}}
>
> []{#50qasw1489459826109 .anchor}**var** obj = {
>
> []{#48djko1489459826110 .anchor}    a: 20
>
> []{#5sbbg1489459826110 .anchor}}
>
> []{#83rjwb1489459826110 .anchor} 
>
> []{#37dfwa1489459826113 .anchor}fn.call(obj, 100, 10); *// 130*
>
> []{#8amfo1489459826115 .anchor}fn.apply(obj, \[20, 10\]); *// 50*

[]{#34mbgt1489459826115 .anchor}

[]{#45mozc1489459826115
.anchor}因为call/apply的存在，这让JavaScript变得十分灵活。因此就让call/apply拥有了很多有用处的场景。简单总结几点，也欢迎大家补充。

[]{#24azyy1489459826116 .anchor}

[]{#71xcrg1489459826116 .anchor}将类数组对象转换为数组

[]{#43eiyi1489459826117 .anchor}

> []{#82iouo1489459826119 .anchor}**function** exam(a, b, c, d, e) {
>
> []{#63irkw1489459826120 .anchor} 
>
> []{#76izna1489459826120 .anchor}    *// 先看看函数的自带属性 arguments
> 什么是样子的*
>
> []{#9kqax1489459826121 .anchor}    console.log(**arguments**);
>
> []{#32xaus1489459826121 .anchor} 
>
> []{#59vacn1489459826122 .anchor}    *//
> 使用call/apply将arguments转换为数组,
> 返回结果为数组，arguments自身不会改变*

[]{#18cwjz1489549162772
.anchor}//Array.prototype.slice.call(arguments)能将具有length属性的对象转成数组

[]{#71qxjk1489550673560
.anchor}//\[\].slice.call(arguments)==\[\].slice.call(arguments,0)

> []{#96rwld1489459826123
> .anchor}    **var** arg = \[\].slice.call(**arguments**);
>
> []{#34epwn1489459826124 .anchor} 
>
> []{#21tldt1489459826124 .anchor}    console.log(arg);
>
> []{#82mfzv1489459826125 .anchor}}
>
> []{#67ppxf1489459826125 .anchor} 
>
> []{#4vlvf1489459826126 .anchor}exam(2, 8, 9, 10, 3);
>
> []{#72mxfs1489459826127 .anchor} 
>
> []{#91kxql1489459826128 .anchor}*// result:*
>
> []{#81atul1489459826128 .anchor}*// { '0': 2, '1': 8, '2': 9, '3': 10,
> '4': 3 }*
>
> []{#21sxqk1489459826129 .anchor}*// \[ 2, 8, 9, 10, 3 \]*
>
> []{#47nscs1489459826129 .anchor}*//*
>
> []{#70azal1489459826129 .anchor}*//
> 也常常使用该方法将DOM中的nodelist转换为数组*
>
> []{#49yhwd1489459826130 .anchor}*// \[\].slice.call(
> document.getElementsByTagName('li') );*

[]{#56vcme1489459826130 .anchor}

[]{#96wpqp1489459826131 .anchor}根据自己的需要灵活修改this指向

[]{#58gtis1489459826132 .anchor}

> []{#36jxsq1489459826133 .anchor}**var** foo = {
>
> []{#36kmyg1489459826133 .anchor}    name: 'joker',
>
> []{#6zoyy1489459826134 .anchor}    showName: **function**() {
>
> []{#49nxmz1489459826135 .anchor}      console.log(**this**.name);
>
> []{#23cvsb1489459826136 .anchor}    }
>
> []{#22csoa1489459826136 .anchor}}
>
> []{#79jufs1489459826137 .anchor}**var** bar = {
>
> []{#10tnbt1489459826137 .anchor}    name: 'rose'
>
> []{#15iyhz1489459826138 .anchor}}
>
> []{#32dczl1489459826139 .anchor}foo.showName.call(bar);

[]{#77sktv1489459826140 .anchor}

[]{#92ukgz1489459826140 .anchor}实现继承

[]{#71wyyw1489459826140 .anchor}

> []{#67tsix1489459826141 .anchor}*// 定义父级的构造函数*
>
> []{#69zyai1489459826142
> .anchor}**var** Person = **function**(**name**, age) {
>
> []{#91jfow1489459826143 .anchor}    **this**.name = **name**;
>
> []{#31vmzo1489459826145 .anchor}    **this**.age  = age;
>
> []{#69kdje1489459826148
> .anchor}    **this**.gender = \['man', 'woman'\];
>
> []{#31mzas1489459826149 .anchor}}
>
> []{#82qdix1489459826149 .anchor} 
>
> []{#77gbxo1489459826149 .anchor}*// 定义子类的构造函数*
>
> []{#71rgxe1489459826150
> .anchor}**var** Student = **function**(**name**, age, high) {
>
> []{#95dqpa1489459826151 .anchor} 
>
> []{#46czfm1489459826152 .anchor}    *// use call*
>
> []{#49rhxb1489459826153
> .anchor}    Person.call(**this**, **name**, age);
>
> []{#11phcw1489459826154 .anchor}    **this**.high = high;
>
> []{#22kknd1489459826154 .anchor}}
>
> []{#66hhpb1489459826155
> .anchor}Student.prototype.message = **function**() {
>
> []{#97fweq1489459826159
> .anchor}    console.log('name:'+**this**.name+', age:'+**this**.age+',
> high:'+**this**.high+', gender:'+**this**.gender\[0\]+';');
>
> []{#6uhpc1489459826160 .anchor}}
>
> []{#40pffj1489459826160 .anchor} 
>
> []{#7pgbg1489459826161
> .anchor}**new** Student('xiaom', 12, '150cm').message();
>
> []{#43ekwn1489459826162 .anchor} 
>
> []{#36mibz1489459826163 .anchor}*// result*
>
> []{#24qwez1489459826163 .anchor}*// ----------*
>
> []{#85tsnl1489459826163 .anchor}*// name:xiaom, age:12, high:150cm,
> gender:man;*

[]{#52atdv1489459826164 .anchor}

[]{#22kgjh1489459826164
.anchor}简单给有面向对象基础的朋友解释一下。在Student的构造函数中，借助call方法，将父级的构造函数执行了一次，相当于将Person中的代码，在Sudent中复制了一份，其中的this指向为从Student中new出来的实例对象。call方法保证了this的指向正确，因此就相当于实现了基层。Student的构造函数等同于下。

[]{#13grzo1489459826165 .anchor}

> []{#22dgbh1489459826166
> .anchor}**var** Student = **function**(**name**, age, high) {
>
> []{#91zime1489459826167 .anchor}    **this**.name = **name**;
>
> []{#40keba1489459826168 .anchor}    **this**.age  = age;
>
> []{#43dzlv1489459826170
> .anchor}    **this**.gender = \['man', 'woman'\];
>
> []{#16ehji1489459826170 .anchor}    *// Person.call(this, name, age);
> 这一句话，相当于上面三句话，因此实现了继承*
>
> []{#86gogs1489459826171 .anchor}    **this**.high = high;
>
> []{#20ysyu1489459826172 .anchor}}

[]{#53rdup1489459826172 .anchor}

[]{#38wwdp1489459826173
.anchor}在向其他执行上下文的传递中，确保this的指向保持不变

[]{#94fvau1489459826173 .anchor}

[]{#6hwwk1489459826173
.anchor}如下面的例子中，我们期待的是getA被obj调用时，this指向obj，但是由于匿名函数的存在导致了this指向的丢失，在这个匿名函数中this指向了全局，因此我们需要想一些办法找回正确的this指向。

[]{#14natw1489459826174 .anchor}

> []{#45volj1489459826174 .anchor}**var** obj = {
>
> []{#81ozkj1489459826175 .anchor}    a: 20,
>
> []{#89uahx1489459826176 .anchor}    getA: **function**() {
>
> []{#14evvt1489459826177
> .anchor}        **setTimeout**(**function**() {
>
> []{#8pnpd1489459826178 .anchor}            console.log(**this**.a)
>
> []{#55qvxa1489459826179 .anchor}        }, 1000)
>
> []{#66ondc1489459826179 .anchor}    }
>
> []{#94ocgq1489459826180 .anchor}}
>
> []{#5mtqu1489459826180 .anchor} 
>
> []{#12desz1489459826180 .anchor}obj.getA();

[]{#72ybji1489459826181 .anchor}

[]{#79akov1489459826181
.anchor}常规的解决办法很简单，就是使用一个变量，将this的引用保存起来。我们常常会用到这方法，但是我们也要借助上面讲到过的知识，来判断this是否在传递中被修改了，如果没有被修改，就没有必要这样使用了。

[]{#84arhg1489459826182 .anchor}

> []{#0hupe1489459826183 .anchor}**var** obj = {
>
> []{#43dozb1489459826183 .anchor}    a: 20,
>
> []{#27zfcq1489459826184 .anchor}    getA: **function**() {
>
> []{#24xhom1489459826186 .anchor}        **var** **self** = **this**;
>
> []{#48xihf1489459826186
> .anchor}        **setTimeout**(**function**() {
>
> []{#59ombh1489459826188 .anchor}            console.log(**self**.a)
>
> []{#47qcyz1489459826189 .anchor}        }, 1000)
>
> []{#47aumj1489459826190 .anchor}    }
>
> []{#61aazc1489459826190 .anchor}}

[]{#37mifz1489459826190 .anchor}

[]{#76sbon1489459826191
.anchor}另外就是借助闭包与apply方法，封装一个bind方法。

[]{#34ogsp1489459826191 .anchor}

> []{#55iwuf1489459826192 .anchor}**function** bind(fn, obj) {
>
> []{#76kpgx1489459826193 .anchor}    **return** **function**() {
>
> []{#32vyfw1489459826195
> .anchor}        **return** fn.apply(obj, **arguments**);
>
> []{#33hzur1489459826196 .anchor}    }
>
> []{#50ixxo1489459826197 .anchor}}
>
> []{#83kfer1489459826197 .anchor} 
>
> []{#24xlli1489459826198 .anchor}**var** obj = {
>
> []{#40stse1489459826199 .anchor}    a: 20,
>
> []{#69mxvj1489459826200 .anchor}    getA: **function**() {
>
> []{#48mrja1489459826201
> .anchor}        **setTimeout**(bind(**function**() {
>
> []{#8qakt1489459826202 .anchor}            console.log(**this**.a)
>
> []{#22zozw1489459826203 .anchor}        }, **this**), 1000)
>
> []{#87ltna1489459826204 .anchor}    }
>
> []{#53urii1489459826204 .anchor}}
>
> []{#7jbdm1489459826204 .anchor} 
>
> []{#73tixe1489459826205 .anchor}obj.getA();

[]{#84wqmy1489459826205 .anchor}

[]{#81npmz1489459826205
.anchor}当然，也可以使用ES5中已经自带的bind方法。它与我上面封装的bind方法是一样的效果。

[]{#85zras1489459826206 .anchor}

> []{#68fiue1489459826206 .anchor}**var** obj = {
>
> []{#94vddb1489459826207 .anchor}    a: 20,
>
> []{#61xspi1489459826208 .anchor}    getA: **function**() {
>
> []{#17dyiw1489459826210
> .anchor}        **setTimeout**(**function**() {
>
> []{#70onoi1489459826211 .anchor}            console.log(**this**.a)
>
> []{#87miwx1489459826213 .anchor}        }.bind(**this**), 1000)
>
> []{#47tmzh1489459826213 .anchor}    }
>
> []{#2sinl1489459826214 .anchor}}

[]{#46fgrv1489459826214 .anchor}

[]{#12fooo1489459826214 .anchor}**四、构造函数与原型方法上的this**

[]{#30kpad1489459826214 .anchor}

[]{#72nres1489459826214
.anchor}在封装对象的时候，我们几乎都会用到this，但是，只有少数人搞明白了在这个过程中的this指向，就算我们理解了原型，也不一定理解了this。所以这一部分，我认为将会为这篇文章最重要最核心的部分。理解了这里，将会对你学习JS面向对象产生巨大的帮助。

[]{#67pgaj1489459826215 .anchor}

[]{#46cevg1489459826215
.anchor}结合下面的例子，我在例子抛出几个问题大家思考一下。

[]{#16lnjo1489459826216 .anchor}

> []{#20bdwy1489459826217 .anchor}**function** Person(**name**, age) {
>
> []{#42fbnu1489459826217 .anchor} 
>
> []{#63axww1489459826218 .anchor}    *// 这里的this指向了谁?*
>
> []{#84jkvt1489459826218 .anchor}    **this**.name = **name**;
>
> []{#37qjvy1489459826220 .anchor}    **this**.age = age;  
>
> []{#2yrsm1489459826220 .anchor}}
>
> []{#76lvlv1489459826220 .anchor} 
>
> []{#79rhnz1489459826221
> .anchor}Person.prototype.getName = **function**() {
>
> []{#80mjxo1489459826221 .anchor} 
>
> []{#2oloo1489459826222 .anchor}    *// 这里的this又指向了谁？*
>
> []{#74cnyz1489459826223 .anchor}    **return** **this**.name;
>
> []{#42ppgv1489459826225 .anchor}}
>
> []{#33qndu1489459826225 .anchor} 
>
> []{#52qthe1489459826225 .anchor}*//
> 上面的2个this，是同一个吗，他们是否指向了原型对象？*
>
> []{#18xgqi1489459826226 .anchor} 
>
> []{#6uhfa1489459826227
> .anchor}**var** p1 = **new** Person('Nick', 20);
>
> []{#15wfhg1489459826228 .anchor}p1.getName();

[]{#47npbx1489459826228 .anchor}

[]{#70eyga1489459826228
.anchor}我们已经知道，this，是在函数调用过程中确定，因此，搞明白new的过程中到底发生了什么就变得十分重要。

[]{#61feub1489459826229 .anchor}

[]{#19gcew1489459826229
.anchor}通过new操作符调用构造函数，会经历以下4个阶段。

[]{#29jost1489459826229 .anchor}

[]{#68cqlb1489459826230 .anchor}创建一个新的对象；

[]{#21esio1489459826231 .anchor}将构造函数的this指向这个新对象；

[]{#76jukz1489459826231
.anchor}指向构造函数的代码，为这个对象添加属性，方法等；

[]{#11aqgq1489459826231 .anchor}返回新对象。

[]{#52mkie1489459826232 .anchor}

[]{#79jaqr1489459826232
.anchor}因此，当new操作符调用构造函数时，this其实指向的是这个新创建的对象，最后又将新的对象返回出来，被实例对象p1接收。因此，我们可以说，这个时候，构造函数的this，指向了新的实例对象，p1。

[]{#33qqgg1489459826232 .anchor}

[]{#69pwqq1489459826233
.anchor}而原型方法上的this就好理解多了，根据上边对函数中this的定义，

[]{#72ayab1489459826233
.anchor}p1.getName()中的getName为调用者，他被p1所拥有，因此getName中的this，也是指向了p1。

[]{#92evxv1489459768078 .anchor}

[]{#74wqvc1489459835603 .anchor}JavaScript 中的 this
指向问题有很多博客在解释，仍然有很多人问。上周我们的开发团队连续两个人遇到相关问题，所以我不得不将关于前端构建技术的交流会延长了半个时候讨论
this 的问题。

[]{#85akez1489459857705 .anchor}

[]{#40mqcv1489459857705 .anchor}与我们常见的很多语言不同，JavaScript
函数中的 this
指向并不是在函数定义的时候确定的，而是在调用的时候确定的。换句话说，函数的调用方式决定了
this 指向。

[]{#23mxmf1489459857706 .anchor}

[]{#83mouk1489459857706 .anchor}JavaScript
中，普通的函数调用方式有三种：直接调用、方法调用和 new
调用。除此之外，还有一些特殊的调用方式，比如通过bind()
将函数绑定到对象之后再进行调用、通过 call()、apply() 进行调用等。而 es6
引入了箭头函数之后，箭头函数调用时，其 this
指向又有所不同。下面就来分析这些情况下的 this 指向。

[]{#4vkmf1489459857708 .anchor}

[]{#46lylo1489459857709 .anchor}**直接调用**

[]{#45vcew1489459857709 .anchor}

[]{#42wmrq1489459857709 .anchor}直接调用，就是通过 函数名(...)
这种方式调用。这时候，函数内部的 this 指向全局对象，在浏览器中全局对象是
window，在 NodeJs 中全局对象是 global。

[]{#17hcdl1489459857710 .anchor}

[]{#69gmlb1489459857710 .anchor}来看一个例子：

[]{#70wmcl1489459857711 .anchor}

> []{#88owlv1489459857711 .anchor}*// 简单兼容浏览器和 NodeJs
> 的全局对象*
>
> []{#36bdvb1489459857716
> .anchor}const \_global = **typeof** **window** === "undefined" ? global : **window**;
>
> []{#43uole1489459857717 .anchor} 
>
> []{#68mpui1489459857720 .anchor}**function** test() {
>
> []{#0arbn1489459857723
> .anchor}    console.log(**this** === \_global);    *// true*
>
> []{#96hjeb1489459857725 .anchor}}
>
> []{#8qqbx1489459857725 .anchor} 
>
> []{#99dhjr1489459857726 .anchor}test();    *// 直接调用*

[]{#93jroy1489459857726 .anchor}

[]{#95dkhc1489459857726
.anchor}这里需要注意的一点是，直接调用并不是指在全局作用域下进行调用，在任何作用域下，直接通过
函数名(...)
来对函数进行调用的方式，都称为直接调用。比如下面这个例子也是直接调用

[]{#85xqgs1489459857727 .anchor}

> []{#74vypk1489459857728 .anchor}(**function**(\_global) {
>
> []{#7ndrw1489459857729 .anchor}    *// 通过 IIFE 限定作用域*
>
> []{#87jjwx1489459857729 .anchor} 
>
> []{#37kmgb1489459857731 .anchor}    **function** test() {
>
> []{#80ilpf1489459857734
> .anchor}        console.log(**this** === \_global);  *// true*
>
> []{#21pbzi1489459857735 .anchor}    }
>
> []{#80musj1489459857735 .anchor} 
>
> []{#24obad1489459857736 .anchor}    test();     *//
> 非全局作用域下的直接调用*
>
> []{#28iaqc1489459857738
> .anchor}})(**typeof** **window** === "undefined" ? global : **window**);

[]{#42gagb1489459857739 .anchor}

[]{#93lflb1489459857739 .anchor}**bind() 对直接调用的影响**

[]{#4iabr1489459857740 .anchor}

[]{#89unbr1489459857740 .anchor}还有一点需要注意的是 bind()
的影响。Function.prototype.bind()
的作用是将当前函数与指定的对象绑定，并返回一个新函数，这个新函数无论以什么样的方式调用，其
this 始终指向绑定的对象。还是来看例子：

[]{#62sxxw1489459857741 .anchor}

> []{#5tipo1489459857742 .anchor}const obj = {};
>
> []{#24ueds1489459857742 .anchor} 
>
> []{#70aosi1489459857745 .anchor}**function** test() {
>
> []{#43mxde1489459857746 .anchor}    console.log(**this** === obj);
>
> []{#15ykhd1489459857748 .anchor}}
>
> []{#14wmcm1489459857748 .anchor} 
>
> []{#31acmq1489459857750 .anchor}const testObj = test.bind(obj);
>
> []{#38xdjc1489459857751 .anchor}test();     *// false*
>
> []{#90turz1489459857751 .anchor}testObj();  *// true*

[]{#3ycdf1489459857752 .anchor}

[]{#63bwjr1489459857752 .anchor}那么 bind() 干了啥？不妨模拟一个 bind()
来了解它是如何做到对 this 产生影响的。

[]{#8puyi1489459857753 .anchor}

> []{#66nheb1489459857754 .anchor}const obj = {};
>
> []{#84jrtg1489459857755 .anchor} 
>
> []{#75iqtc1489459857756 .anchor}**function** test() {
>
> []{#18evya1489459857757 .anchor}    console.log(**this** === obj);
>
> []{#55umzq1489459857758 .anchor}}
>
> []{#19tihf1489459857758 .anchor} 
>
> []{#47vpyl1489459857758 .anchor}*// 自定义的函数，模拟 bind() 对 this
> 的影响*
>
> []{#22rsbf1489459857760 .anchor}**function** myBind(func, target) {
>
> []{#45yyzx1489459857761 .anchor}    **return** **function**() {
>
> []{#97barh1489459857763
> .anchor}        **return** func.apply(target, **arguments**);
>
> []{#56lvmj1489459857764 .anchor}    };
>
> []{#46hakl1489459857764 .anchor}}
>
> []{#8opnr1489459857764 .anchor} 
>
> []{#1ylnj1489459857765 .anchor}const testObj = myBind(test, obj);
>
> []{#84fpum1489459857766 .anchor}test();     *// false*
>
> []{#19taiy1489459857767 .anchor}testObj();  *// true*

[]{#84qtkc1489459857768 .anchor}

[]{#70cscc1489459857768
.anchor}从上面的示例可以看到，首先，通过闭包，保持了
target，即绑定的对象；然后在调用函数的时候，对原函数使用了 apply
方法来指定函数的 this。当然原生的 bind()
实现可能会不同，而且更高效。但这个示例说明了 bind() 的可行性。

[]{#70opud1489459857769 .anchor}

[]{#12wwak1489459857769 .anchor}**call 和 apply 对 this 的影响**

[]{#13etvw1489459857769 .anchor}

[]{#14hmhw1489459857770 .anchor}上面的示例中用到了
Function.prototype.apply()，与之类似的还有
Function.prototype.call()。这两方法的用法请大家自己通过链接去看文档。不过，它们的第一个参数都是指定函数运行时其中的
this 指向。

[]{#25funf1489459857770 .anchor}

[]{#30mrcm1489459857771 .anchor}不过使用 apply 和 call
的时候仍然需要注意，如果目录函数本身是一个绑定了 this 对象的函数，那
apply 和 call 不会像预期那样执行，比如

[]{#15vnwi1489459857771 .anchor}

> []{#90kxri1489459857773 .anchor}const obj = {};
>
> []{#88cghp1489459857774 .anchor} 
>
> []{#9xrjc1489459857774 .anchor}**function** test() {
>
> []{#52wydu1489459857776 .anchor}    console.log(**this** === obj);
>
> []{#68jhex1489459857776 .anchor}}
>
> []{#49vshg1489459857776 .anchor} 
>
> []{#64exxp1489459857776 .anchor}*// 绑定到一个新对象，而不是 obj*
>
> []{#37pjbh1489459857779 .anchor}const testObj = test.bind({});
>
> []{#12pskj1489459857780 .anchor}test.apply(obj);    *// true*
>
> []{#92tkon1489459857780 .anchor} 
>
> []{#80whim1489459857781 .anchor}*// 期望 this 是 obj，即输出 true*
>
> []{#97zseo1489459857781 .anchor}*// 但是因为 testObj 绑定了不是 obj
> 的对象，所以会输出 false*
>
> []{#14djsb1489459857783 .anchor}testObj.apply(obj); *// false*

[]{#94jfsn1489459857783 .anchor}

[]{#34atnj1489459857783 .anchor}由此可见，bind()
对函数的影响是深远的，慎用！

[]{#37puad1489459857784 .anchor}

[]{#95uyyg1489459857784 .anchor}**方法调用**

[]{#31enor1489459857784 .anchor}

[]{#14odiq1489459857784
.anchor}方法调用是指通过对象来调用其方法函数，它是 对象.方法函数(...)
这样的调用形式。这种情况下，函数中的 this
指向调用该方法的对象。但是，同样需要注意 bind() 的影响。

[]{#7xbeu1489459857786 .anchor}

> []{#39exiy1489459857787 .anchor}const obj = {
>
> []{#83gvyr1489459857787 .anchor}    *//
> 第一种方式，定义对象的时候定义其方法*
>
> []{#46fzpt1489459857788 .anchor}    test() {
>
> []{#63nnwp1489459857790 .anchor}        console.log(**this** === obj);
>
> []{#23kfxe1489459857791 .anchor}    }
>
> []{#34jnlm1489459857791 .anchor}};
>
> []{#52ifsj1489459857791 .anchor} 
>
> []{#33hzvr1489459857791 .anchor}*//
> 第二种方式，对象定义好之后为其附加一个方法(函数表达式)*
>
> []{#9uojb1489459857793 .anchor}obj.test2 = **function**() {
>
> []{#91zfxq1489459857794 .anchor}    console.log(**this** === obj);
>
> []{#90vwph1489459857795 .anchor}};
>
> []{#1bsht1489459857795 .anchor} 
>
> []{#14qxwj1489459857795 .anchor}*// 第三种方式和第二种方式原理相同*
>
> []{#7yepg1489459857795 .anchor}*//
> 是对象定义好之后为其附加一个方法(函数定义)*
>
> []{#11qtod1489459857796 .anchor}**function** t() {
>
> []{#8vwhc1489459857797 .anchor}    console.log(**this** === obj);
>
> []{#82nufl1489459857798 .anchor}}
>
> []{#29mjuf1489459857800 .anchor}obj.test3 = t;
>
> []{#59xcwh1489459857800 .anchor} 
>
> []{#3oeay1489459857800 .anchor}*// 这也是为对象附加一个方法函数*
>
> []{#94zxvy1489459857800 .anchor}*// 但是这个函数绑定了一个不是 obj
> 的其它对象*
>
> []{#53sjyy1489459857802 .anchor}obj.test4 = (**function**() {
>
> []{#43blez1489459857803 .anchor}    console.log(**this** === obj);
>
> []{#21tbgs1489459857804 .anchor}}).bind({});
>
> []{#14ynzg1489459857804 .anchor} 
>
> []{#28cadk1489459857805 .anchor}obj.test();     *// true*
>
> []{#81nsol1489459857806 .anchor}obj.test2();    *// true*
>
> []{#25wzjb1489459857807 .anchor}obj.test3();    *// true*
>
> []{#85oqri1489459857807 .anchor} 
>
> []{#67lchk1489459857808 .anchor}*// 受 bind() 影响，test4 中的 this
> 指向不是 obj*
>
> []{#92bjjh1489459857809 .anchor}obj.test4();    *// false*

[]{#15srws1489459857810 .anchor}

[]{#27jxeo1489459857810
.anchor}这里需要注意的是，后三种方式都是预定定义函数，再将其附加给 obj
对象作为其方法。再次强调，函数内部的 this
指向与定义无关，受调用方式的影响。

[]{#85xpjn1489459857811 .anchor}

[]{#56uesp1489459857811 .anchor}**方法中 this 指向全局对象的情况**

[]{#77vkem1489459857812 .anchor}

[]{#99mzhu1489459857812
.anchor}注意这里说的是方法中而不是方法调用中。方法中的 this
指向全局对象，如果不是因为
bind()，那就一定是因为不是用的方法调用方式，比如

[]{#47bkeg1489459857812 .anchor}

> []{#4ijdo1489459857813 .anchor}const obj = {
>
> []{#56spto1489459857815 .anchor}    test() {
>
> []{#78zedi1489459857817 .anchor}        console.log(**this** === obj);
>
> []{#62namb1489459857818 .anchor}    }
>
> []{#17ptgp1489459857818 .anchor}};
>
> []{#39snlc1489459857818 .anchor} 
>
> []{#17ykjd1489459857820 .anchor}const t = obj.test;
>
> []{#75nmyi1489459857820 .anchor}t();    *// false*

[]{#22hmtg1489459857821 .anchor}

[]{#23hwuv1489459857821 .anchor}t 就是 obj 的 test 方法，但是 t()
调用时，其中的 this 指向了全局。

[]{#84alph1489459857821 .anchor}

[]{#99pvxv1489459857821
.anchor}之所以要特别提出这种情况，主要是因为常常将一个对象方法作为回调传递给某个函数之后，却发现运行结果与预期不符——因为忽略了调用方式对
this
的影响。比如下面的例子是在页面中对某些事情进行封装之后特别容易遇到的问题：

[]{#36txvu1489459857823 .anchor}

> []{#54rbjy1489459857824 .anchor}**class** Handlers {
>
> []{#66cujd1489459857824 .anchor}    *// 这里 \$button
> 假设是一个指向某个按钮的 jQuery 对象*
>
> []{#84pofp1489459857825 .anchor}    **constructor**(data, \$button) {
>
> []{#74grkk1489459857827 .anchor}        **this**.data = data;
>
> []{#98ucya1489459857828
> .anchor}        \$button.on("click", **this**.onButtonClick);
>
> []{#92htpm1489459857829 .anchor}    }
>
> []{#77tfha1489459857829 .anchor} 
>
> []{#64ived1489459857830 .anchor}    onButtonClick(e) {
>
> []{#80vqtq1489459857832 .anchor}        console.log(**this**.data);
>
> []{#1zgaz1489459857832 .anchor}    }
>
> []{#13ihgn1489459857833 .anchor}}
>
> []{#85uben1489459857833 .anchor} 
>
> []{#45jzhf1489459857834
> .anchor}const handlers = **new** Handlers("string
> data", \$("\#someButton"));
>
> []{#5bkna1489459857835 .anchor}*// 对 \#someButton 进行点击操作之后*
>
> []{#51phmn1489459857836 .anchor}*// 输出 undefined*
>
> []{#49akdg1489459857836 .anchor}*// 但预期是输出 string data*

[]{#65nwhz1489459857836 .anchor}

[]{#87wwfn1489459857836 .anchor}很显然 this.onButtonClick
作为一个参数传入 on()
之后，事件触发时，是对这个函数进行的直接调用，而不是方法调用，所以其中的
this 会指向全局对象。要解决这个问题有很多种方法

[]{#99oxcf1489459857837 .anchor}

> []{#56uioy1489459857837 .anchor}*// 这是在 es5 中的解决办法之一*
>
> []{#48vmyj1489459857838 .anchor}**var** \_this = **this**;
>
> []{#93tbyn1489459857840 .anchor}\$button.on("click", **function**() {
>
> []{#67zvoe1489459857841 .anchor}    \_this.onButtonClick();
>
> []{#10quch1489459857842 .anchor}});
>
> []{#81cfbj1489459857842 .anchor} 
>
> []{#62lolc1489459857842 .anchor}*// 也可以通过 bind() 来解决*
>
> []{#54hzes1489459857844
> .anchor}\$button.on("click", **this**.onButtonClick.bind(**this**));
>
> []{#49brnz1489459857845 .anchor} 
>
> []{#56rbam1489459857845 .anchor}*// es6 中可以通过箭头函数来处理，在
> jQuery 中慎用*
>
> []{#92ykfk1489459857847
> .anchor}\$button.on("click", e =&gt; **this**.onButtonClick(e));

[]{#16zyem1489459857848 .anchor}

[]{#22xnxj1489459857848 .anchor}不过请注意，将箭头函数用作 jQuery
的回调时造成要小心函数内对 this 的使用。jQuery
大多数回调函数(非箭头函数)中的 this 都是表示调用目标，所以可以写
\$(this).text() 这样的语句，但 jQuery 无法改变箭头函数的 this
指向，同样的语句语义完全不同。

[]{#96evwb1489459857849 .anchor}

[]{#37evsq1489459857849 .anchor}**new 调用**

[]{#32wgps1489459857849 .anchor}

[]{#24eluk1489459857849 .anchor}在 es6
之前，每一个函数都可以当作是构造函数，通过 new
调用来产生新的对象(函数内无特定返回值的情况下)。而 es6
改变了这种状态，虽然 class 定义的类用 typeof 运算符得到的仍然是
"function"，但它不能像普通函数一样直接调用；同时，class
中定义的方法函数，也不能当作构造函数用 new 来调用。

[]{#58hupv1489459857851 .anchor}

[]{#54cllw1489459857851 .anchor}而在 es5 中，用 new
调用一个构造函数，会创建一个新对象，而其中的 this
就指向这个新对象。这没有什么悬念，因为 new 本身就是设计来创建新对象的。

[]{#77zoee1489459857852 .anchor}

> []{#54qftj1489459857853 .anchor}**var** data = "Hi";    *// 全局变量*
>
> []{#33vunx1489459857853 .anchor} 
>
> []{#83dhgd1489459857854 .anchor}**function** AClass(data) {
>
> []{#68llqh1489459857855 .anchor}    **this**.data = data;
>
> []{#96elmi1489459857855 .anchor}}
>
> []{#78nkre1489459857855 .anchor} 
>
> []{#78irup1489459857857 .anchor}**var** a = **new** AClass("Hello
> World");
>
> []{#52cnty1489459857858 .anchor}console.log(a.data);    *// Hello
> World*
>
> []{#90pxri1489459857860 .anchor}console.log(data);      *// Hi*
>
> []{#38nxrl1489459857860 .anchor} 
>
> []{#29ircm1489459857862 .anchor}**var** b = **new** AClass("Hello
> World");
>
> []{#65gibr1489459857863 .anchor}console.log(a === b);   *// false*

[]{#98truq1489459857863 .anchor}

[]{#38slop1489459857864 .anchor}**箭头函数中的 this**

[]{#81wqhg1489459857864 .anchor}

[]{#59nuva1489459857864 .anchor}先来看看 MDN 上对箭头函数的说明

[]{#48jgjp1489459857865 .anchor}

> []{#27jmhf1489459857865 .anchor}An arrow function expression has a
> shorter syntax than a function expression and does not bind its own
> this, arguments,super, or new.target. Arrow functions are always
> anonymous. These function expressions are best suited for non-method
> functions, and they cannot be used as constructors.

[]{#89mtne1489459857867 .anchor}

[]{#57gxde1489459857867 .anchor}这里已经清楚了说明了，箭头函数没有自己的
this 绑定。箭头函数中使用的
this，其实是直接包含它的那个函数或函数表达式中的 this。比如

[]{#61vmbr1489459857868 .anchor}

> []{#69dior1489459857869 .anchor}const obj = {
>
> []{#66onjd1489459857870 .anchor}    test() {
>
> []{#82fmnc1489459857871 .anchor}        const arrow = () =&gt; {
>
> []{#65eokl1489459857872 .anchor}            *// 这里的 this 是 test()
> 中的 this，*
>
> []{#1myvk1489459857872 .anchor}            *// 由 test()
> 的调用方式决定*
>
> []{#96drsp1489459857873
> .anchor}            console.log(**this** === obj);
>
> []{#92ebkk1489459857874 .anchor}        };
>
> []{#28ywhi1489459857874 .anchor}        arrow();
>
> []{#7ixdf1489459857875 .anchor}    },
>
> []{#13znok1489459857875 .anchor} 
>
> []{#91pvrp1489459857876 .anchor}    getArrow() {
>
> []{#83goww1489459857877 .anchor}        **return** () =&gt; {
>
> []{#83vuzv1489459857877 .anchor}            *// 这里的 this 是
> getArrow() 中的 this，*
>
> []{#15tflb1489459857878 .anchor}            *// 由 getArrow()
> 的调用方式决定*
>
> []{#31fjbp1489459857880
> .anchor}            console.log(**this** === obj);
>
> []{#92wlky1489459857880 .anchor}        };
>
> []{#92pnkt1489459857881 .anchor}    }
>
> []{#2kfeb1489459857881 .anchor}};
>
> []{#90aeyg1489459857881 .anchor} 
>
> []{#40jkgs1489459857882 .anchor}obj.test();     *// true*
>
> []{#75xjak1489459857882 .anchor} 
>
> []{#39ikwm1489459857883 .anchor}const arrow = obj.getArrow();
>
> []{#91dafj1489459857884 .anchor}arrow();        *// true*

[]{#73jipo1489459857884 .anchor}

[]{#40zvsq1489459857884 .anchor}示例中的两个 this
都是由箭头函数的直接外层函数(方法)决定的，而方法函数中的 this
是由其调用方式决定的。上例的调用方式都是方法调用，所以 this
都指向方法调用的对象，即 obj。

[]{#49suml1489459857885 .anchor}

[]{#38owdq1489459857885
.anchor}箭头函数让大家在使用闭包的时候不需要太纠结 this，不需要通过像
\_this 这样的局部变量来临时引用 this 给闭包函数使用。来看一段 Babel
对箭头函数的转译可能能加深理解：

[]{#94dpbm1489459857886 .anchor}

> []{#40eqpg1489459857887 .anchor}*// ES6*
>
> []{#58vywf1489459857888 .anchor}const obj = {
>
> []{#7gjrs1489459857889 .anchor}    getArrow() {
>
> []{#38txxv1489459857890 .anchor}        **return** () =&gt; {
>
> []{#79itza1489459857891
> .anchor}            console.log(**this** === obj);
>
> []{#80obqw1489459857891 .anchor}        };
>
> []{#4lhto1489459857892 .anchor}    }
>
> []{#61dwdl1489459857892 .anchor}}

[]{#75keyu1489459857892 .anchor}

> []{#86mgjm1489459857893 .anchor}*// ES5，由 Babel 转译*
>
> []{#84unek1489459857894 .anchor}**var** obj = {
>
> []{#57raju1489459857895
> .anchor}    getArrow: **function** getArrow() {
>
> []{#65cvro1489459857897 .anchor}        **var** \_this = **this**;
>
> []{#72xmpv1489459857899 .anchor}        **return** **function** () {
>
> []{#31nnwj1489459857900
> .anchor}            console.log(\_this === obj);
>
> []{#31fqhg1489459857900 .anchor}        };
>
> []{#45yrfq1489459857901 .anchor}    }
>
> []{#47fxot1489459857901 .anchor}};

[]{#57yvec1489459857901 .anchor}

[]{#95vbgn1489459857901 .anchor}另外需要注意的是，箭头函数不能用 new
调用，不能 bind() 到某个对象(虽然 bind()
方法调用没问题，但是不会产生预期效果)。不管在什么情况下使用箭头函数，它本身是没有绑定
this
的，它用的是直接外层函数(即包含它的最近的一层函数或函数表达式)绑定的
this。

[]{#45cnyr1489459768595 .anchor}

[]{#53xffc1488963958810 .anchor}
