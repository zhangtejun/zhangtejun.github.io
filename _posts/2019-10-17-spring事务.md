---
layout: post
title:  "类加载及Spring 事务"
date:   2019-10-17 15:13:34
author: zhangtejun
categories: Java
---
##### 类加载器
JVM中的类加载器（ClassLoader）负责加载来自文件系统，网络或其他来源的类文件。默认使用双亲委派加载，有3中默认类加载器
分别是Bootstrap ClassLoader,Extension ClassLoader和System ClassLoader(Application ClassLoader),每种类加载器都已经确定从哪个位置
加载类文件。

* Bootstrap ClassLoader： 负责加载JDK自带的rt.jar包中的类文件，它是所有类加载器的父加载器。
* Extension ClassLoader：负责加载java扩展类库，即jre/lib/ext目录下或者由java.ext.dirs系统属性指定。
* System ClassLoader：负责从classpath环境变量中加载类文件，通常由-classpath指定或者由JAR中的manifest文件的classpath属性指定。

当第一次访问类中的静态字段时，会触发类加载，并且同一个类只加载一次，静态内部类也是如此，故可以采用此方式创建单例模式。


##### Transaction
Mybatis使用Transaction接口对事务进行抽象，有JdbcTransaction，ManagedTransaction 2个实现，其对象分别由JdbcTransactionFactory，ManagedTransactionFactory
来负责创建。JdbcTransaction 依赖于JDBC Connection进行事务控制和事务提交回滚，

```java
public interface Transaction {
    Connection getConnection() throws SQLException; // 获取数据库链接对象
    void commit() throws SQLException; // 提交事务
    void rollback() throws SQLException;// 回滚事务
    void close() throws SQLException;// 关闭数据库连接
    Integer getTimeout() throws SQLException;// 获取事务超时时间
}

public class JdbcTransaction implements Transaction {
    protected Connection connection; // 事务对应数据库连接
    protected DataSource dataSource; // 数据库连接所属的DataSource
    protected TransactionIsolationLevel level; // 事务隔离级别
    protected boolean autoCommmit; // 是否自动提交
}

public class ManagedTransaction implements Transaction {
    private DataSource dataSource;
    private TransactionIsolationLevel level;
    private Connection connection;
    private final boolean closeConnection;
 }
```
在JdbcTransaction构造函数中会初始化除connection之外的3个字段，connection会延迟初始化，它会在调用getConnection()时通过
dataSource.getConnection()方法初始化，并同时设置autoCommit和事务隔离级别。

ManagedTransaction实现更简单，它的rollback和commit都是空方法，事务的提交和回滚依赖于管理的容器。

mybatis通常和spring集成，事务交与spring容器管理，其实现为SpringManagedTransaction。
```java
public class SpringManagedTransaction implements Transaction {
    private final DataSource dataSource;
    private Connection connection;
    private boolean isConnectionTransactional; //标志该数据库连接对象是否由spring的事务管理器管理
    private boolean autoCommit;

    private void openConnection() throws SQLException {
          // 从spring事务管理器中获取数据库连接对象，实际上，先尝试从事务上下文中获取数据库连接
          // 如果成功则返回该连接，否则从数据源获取并返回该连接
          this.connection = DataSourceUtils.getConnection(this.dataSource);
          // 记录事务是否自动提交，当使用spring来管理事务时，并不会由SpringManagedTransaction
          // 的commit和rollback方法来管理事务
          this.autoCommit = this.connection.getAutoCommit();
          // 记录当前连接是否由spring事务管理器管理
          this.isConnectionTransactional = DataSourceUtils.isConnectionTransactional(this.connection, this.dataSource);
          //...
    }
    public void commit() throws SQLException {
            if (this.connection != null && !this.isConnectionTransactional && !this.autoCommit) {
                //当事务不是由spring事务管理器管理，并且不需要自动提交时，在此处提交事务
                this.connection.commit();
            }
        }
    public void rollback() throws SQLException {
        if (this.connection != null && !this.isConnectionTransactional && !this.autoCommit) {
            //...
            this.connection.rollback();
        }

    }
}
```

##### binding
```java
public class MapperRegistry {
    private final Configuration config; // Configuration对象，mybatis全局唯一配置
    // 记录Mapper接口和对应MapperProxyFactory之间的关系
    private final Map<Class<?>, MapperProxyFactory<?>> knownMappers = new HashMap();
}
```
在需要执行sql时，会先调用MapperRegistry.getMapper()方法获取 实现了Mapper接口的代理对象。例如session.getMapper(BlogMapper.class)
得到的是Mybatis通过JDK动态代理为BlogMapper接口生成的代理对象。

MapperProxyFactory主要负责创建代理对象，
```java
public T newInstance(SqlSession sqlSession) {
    // 每次调用产生新的MapperProxy对象
    MapperProxy<T> mapperProxy = new MapperProxy(sqlSession, this.mapperInterface, this.methodCache);
    return this.newInstance(mapperProxy);
}

public class MapperProxy<T> implements InvocationHandler, Serializable {
    private final SqlSession sqlSession; // 记录关联的sqlSession对象
    private final Class<T> mapperInterface; // Mapper接口对应的class对象
    // 用于缓存MapperMethod对象，MapperMethod对象会完成参数转换和SQL语句的执行功能
    private final Map<Method, MapperMethod> methodCache;

    // 代理对象执行的主要逻辑
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            try {
                // 如果目标方法继承至Object，直接调用目标方法（）
                if (Object.class.equals(method.getDeclaringClass())) {
                    return method.invoke(this, args);
                }

                if (this.isDefaultMethod(method)) {
                    // java 7以上版本支持动态类型语言
                    return this.invokeDefaultMethod(proxy, method, args);
                }
            } catch (Throwable var5) {
                throw ExceptionUtil.unwrapThrowable(var5);
            }
            // 从缓存中获取MapperMethod，没有就创建
            MapperMethod mapperMethod = this.cachedMapperMethod(method);
            // 执行SQL语句
            return mapperMethod.execute(this.sqlSession, args);
        }
}
// MapperMethod 封装了Mapper接口中对应的方法信息，以及对应的SQL信息
public class MapperMethod {
    private final MapperMethod.SqlCommand command; // 记录SQL语句的名称和类型
    private final MapperMethod.MethodSignature method;// Mapper接口中对应的方法相关信息
    // 核心方法。根据sql类型完成数据库的操作
    public Object execute(SqlSession sqlSession, Object[] args) {
          Object param;
          Object result;
          switch(this.command.getType()) {
          case INSERT:
              param = this.method.convertArgsToSqlCommandParam(args);
              // INSERT/UPDATE/DELETE 由sqlSession返回的都是int值，需要通过rowCountResult方法将其转换成Mapper接口方法中对应的返回值
              result = this.rowCountResult(sqlSession.insert(this.command.getName(), param));
              break;
          case UPDATE:
              param = this.method.convertArgsToSqlCommandParam(args);
              result = this.rowCountResult(sqlSession.update(this.command.getName(), param));
              break;
          case DELETE:
              param = this.method.convertArgsToSqlCommandParam(args);
              result = this.rowCountResult(sqlSession.delete(this.command.getName(), param));
              break;
          case SELECT:
              if (this.method.returnsVoid() && this.method.hasResultHandler()) {
                  this.executeWithResultHandler(sqlSession, args);
                  result = null;
              } else if (this.method.returnsMany()) {
                  result = this.executeForMany(sqlSession, args);
              } else if (this.method.returnsMap()) {
                  result = this.executeForMap(sqlSession, args);
              } else if (this.method.returnsCursor()) {
                  result = this.executeForCursor(sqlSession, args);
              } else {
                  param = this.method.convertArgsToSqlCommandParam(args);
                  result = sqlSession.selectOne(this.command.getName(), param);
              }
              break;
          case FLUSH:
              result = sqlSession.flushStatements();
              break;
          default:
              throw new BindingException("Unknown execution method for: " + this.command.getName());
          }

          if (result == null && this.method.getReturnType().isPrimitive() && !this.method.returnsVoid()) {
              throw new BindingException("Mapper method '" + this.command.getName() + " attempted to return null from a method with a primitive return type (" + this.method.getReturnType() + ").");
          } else {
              return result;
          }
      }
 }

 public static class MethodSignature {
   // 解析Mapper接口参数列表，参数名称可以使用@Param注解指定，如果没有指定该注解，则使用参数
   // 索引作为其名称
   private final ParamNameResolver paramNameResolver;
}
```


#### spring 事务
spring事务处理是通过AOP功能来实现声明式事务处理的，比如事务的配置和读取，事务对象的抽象等。

* 声明式事务：结合ioc容器和TransactionProxyFactoryBean对事务管理进行配置，


声明式事务是用事务参数来定义的。一个事务参数就是事务策略应该如何应用到某个方法的一段描述。

5个事务参数：
* 传播行为：用于定义客户端和被调用方法的事务边界。spring定义了7种传播行为，由TransactionDefinition接口常量定义。
* 隔离级别：定义一个事务可能受其他并发事务活动影响的程度。5种隔离级别，由TransactionDefinition接口常量定义。
* 是否只读：是否为一个只读事务，如果一个事务只读后端数据库进行读操作，那么数据库可能会利用事务的可读属性，进行一些优化措施
            ，优化措施由后端数据库实施，因此只有对于那些具有可能启动一个新事务的传播行为的方法来说，将事务设置为读才有意义。
            比如Hibernate，如何把一个事务设置为只读，将使Hibernate的flush模式被设置为FLUSH_NEVER。这就告诉Hibernate避免和数据库进行不必要的
            对象同步，从而把所有更新延迟到事务结束。
* 事务超时：一个应用程序很好的运行，它的事务执行时间不能太长，长时间运行的事务会占用数据库资源，设置超时时间，可以使事务在特定数秒后进行自动回滚
            默认情况下事务只在出现运行时异常（runtime Exception）时回滚，出现受阻异常（check Exception）不回滚。

在spring2.0以前，声明式事务通过TransactionProxyFactoryBean 代理POJO来完成。
```xml
<bean id="newsDaoTransProxy"
    class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean">
    <!-- 1. 配置事务管理器： 为事务代理工厂Bean注入事务管理器 -->
    <property name="transactionManager" ref="transactionManager" />
    <!-- 2. 装配事务目标： 要在哪个Bean上面创建事务代理对象 -->
    <property name="target" ref="newsDao" />
    <!-- 3. 配置事务规则，边界： 指定事务属性 -->
    <property name="transactionAttributes">
        <props>
            <prop key="add*">PROPAGATION_REQUIRED</prop>
            <prop key="*">PROPAGATION_SUPPORTS,readOnly</prop>
            <prop key="*">传播行为,隔离级别(可选),是否只读(可选),回滚规则(可选)</prop>
            <prop key="*">PROPAGATION_SUPPORTS,ISOLATION,readOnly,-Exception,+Exception</prop>
        </props>
    </property>
</bean>
// 调用
NewsDao dao = (NewsDao)applicationContext.getBean("newsDaoTransProxy"，NewsDao.class);
dao.insert("");
```

以上实例为TransactionProxyFactoryBean代理单个bean，如何代理多个bean？ 可以使用事务代理模板

**事务代理模板**
1. 创建一个抽象TransactionProxyFactoryBean声明
```
<bean id="txProxyTemplate"
    class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean" abstract=true>
    <!-- 1. 配置事务管理器： 为事务代理工厂Bean注入事务管理器 -->
    <property name="transactionManager" ref="transactionManager" />
    <!-- 2. 配置事务规则，边界： 指定事务属性 -->
    <property name="transactionAttributes">
        <props>
            <prop key="add*">PROPAGATION_REQUIRED</prop>
            <prop key="*">PROPAGATION_SUPPORTS,readOnly</prop>
            <prop key="*">传播行为,隔离级别(可选),是否只读(可选),回滚规则(可选)</prop>
            <prop key="*">PROPAGATION_SUPPORTS,ISOLATION,readOnly,-Exception,+Exception</prop>
        </props>
    </property>
</bean>
```
2. 把txProxyTemplate作为相应bean的父类
```
<bean id="newsDaoTrans" parent="txProxyTemplate">
      <!--装配事务目标： 要在哪个Bean上面创建事务代理对象 -->
      <property name="target" ref="newsDao" />
</bean>
```

**在spring2.0中的配置**
使用TransactionProxyFactoryBean 会导致很长的xml配置文件，spring2.0为声明式事务提供了一些新的配置元素，位于tx命名空间，也包括aop的名称。

1. 使用`<tx:advice>`声明事务性策略
```xml
<tx:advice id="txAdvice" transaction-manager="txManager">
  <tx:attributes>
    <tx:method name="add*" propagation="REQUIRED">
    <tx:method name="*" propagation="REQUIRED" read-only=true>
  <tx:attributes>
</tx:advice>
```
2. 定义通知器
```
<aop:config>
  <aop:advisor pointcut="execuion(* *..newsDao.*(..))" advice-ref="txAdvice"/>
</aop:config>
```
3. 声明事务管理器
```
<tx:advice id="txAdvice" transaction-manager="txManager">
  <tx:attributes>
    <tx:method name="add*" propagation="REQUIRED">
    <tx:method name="*" propagation="REQUIRED" read-only=true>
  <tx:attributes>
</tx:advice>
```

**注解事务**
声明注解事务并指定一个特定的transactionManager
```
<tx:annotation-driven transaction-manager="txManager">
```
`<tx:annotation-driven>`告诉spring在类层面或者方法层面检查应用程序上下文中的所有bean,并寻找被@Transaction 注解的Bean。

```java
@Service
@Transactional(propagation = Propagation.SUPPORTS,readOnly = true)
public class SysUserServiceImpl implements SysUserService {
    @Override
    @Transactional(propagation = Propagation.REQUIRED,readOnly = false)
    public void addUser(SysUser sysUser) {

    }
}
```
在SysUserServiceImpl类上注解，说明该类的所有方法都支持事务并且是可读的，在方法addUser增加注释，说明这个方法要求一个事务上下文。
@Transactional同样可注解到SysUserService接口上。


##### 事务管理器
不管是JPA还是JDBC等都实现自接口 PlatformTransactionManager。 spring boot 框架会默认注入 DataSourceTransactionManager 实例。
如果你添加的是 spring-boot-starter-data-jpa 依赖，框架会默认注入 JpaTransactionManager 实例。

DefaultTransactionDefinition类是一个默认的TransactionDefinition实现，它的传播行为是
PROPAGATION_REQUIRED(如果当前没事务，则创建一个，否则加入到当前事务中)，隔离级别是数据库默认级别。

如果我们手动配置了事务管理器，Spring boot就不会再为我们自动配置事务管理器。
如果要使用多个事务管理器的话，那么需要手动配置多个。Spring给我们提供了一个
TransactionManagementConfigurer接口，该接口只有一个方法返回PlatformTransactionManager。其中返回的PlatformTransactionManager
就表示这是默认的事务处理器，这样在Transactional注解上就不需要声明是使用哪个事务管理器了。
```
  @Resource(name="txManager2")
  private PlatformTransactionManager txManager2;

  // 手动创建事务管理器1 datasource框架会自动注入
  @Bean(name = "txManager1")
  public PlatformTransactionManager txManager(DataSource dataSource) {
    return new DataSourceTransactionManager(dataSource);
  }

  // 创建事务管理器2
  @Bean(name = "txManager2")
  public PlatformTransactionManager txManager2(EntityManagerFactory factory) {
    return new JpaTransactionManager(factory);
  }

  // 实现接口 TransactionManagementConfigurer 方法，其返回值代表在拥有多个事务管理器的情况下默认使用的事务管理器
  @Override
  public PlatformTransactionManager annotationDrivenTransactionManager() {
    return txManager2;
  }
```

##### 注解@EnableTransactionManagement
```
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Import({TransactionManagementConfigurationSelector.class})
public @interface EnableTransactionManagement {
    boolean proxyTargetClass() default false;
    AdviceMode mode() default AdviceMode.PROXY;
    int order() default 2147483647;
}
```

**基于proxy模式解析类**
TransactionManagementConfigurationSelector
总共注入了4个类到Spring中
* 在AutoProxyRegistrar中添加：InfrastructureAdvisorAutoProxyCreator
* 在ProxyTransactionManagementConfiguration中添加：BeanFactoryTransactionAttributeSourceAdvisor/TransactionAttributeSource/TransactionInterceptor

```java
@Configuration
public class ProxyTransactionManagementConfiguration extends AbstractTransactionManagementConfiguration {
    public ProxyTransactionManagementConfiguration() {
    }
    @Bean(name = {"org.springframework.transaction.config.internalTransactionAdvisor"})
    @Role(2)
    public BeanFactoryTransactionAttributeSourceAdvisor transactionAdvisor() {
        // 创建BeanFactoryTransactionAttributeSourceAdvisor
        BeanFactoryTransactionAttributeSourceAdvisor advisor = new BeanFactoryTransactionAttributeSourceAdvisor();
        // 设置transactionAttributeSource
        advisor.setTransactionAttributeSource(this.transactionAttributeSource());
        // 设置拦截器
        advisor.setAdvice(this.transactionInterceptor());
        if (this.enableTx != null) {
            advisor.setOrder((Integer)this.enableTx.getNumber("order"));
        }
        return advisor;
    }

    @Bean
    @Role(2)
    public TransactionAttributeSource transactionAttributeSource() {
        return new AnnotationTransactionAttributeSource();
    }

    @Bean
    @Role(2)
    public TransactionInterceptor transactionInterceptor() {
        // 创建事务拦截器
        TransactionInterceptor interceptor = new TransactionInterceptor();
        interceptor.setTransactionAttributeSource(this.transactionAttributeSource());
        if (this.txManager != null) {
            // 设置事务管理器
            interceptor.setTransactionManager(this.txManager);
        }
        return interceptor;
    }
}
```

**基于aspectj模式的解析类**
```java
@Configuration
public class AspectJTransactionManagementConfiguration extends AbstractTransactionManagementConfiguration {
   @Bean(name = TransactionManagementConfigUtils.TRANSACTION_ASPECT_BEAN_NAME)
   @Role(BeanDefinition.ROLE_INFRASTRUCTURE)
   public AnnotationTransactionAspect transactionAspect() {
      //创建事务注解切面
      AnnotationTransactionAspect txAspect = AnnotationTransactionAspect.aspectOf();
      //设置事务管理器
      if (this.txManager != null) {
         txAspect.setTransactionManager(this.txManager);
      }
      return txAspect;
   }
```

**internalAutoProxyCreator（AutoProxyRegistrar）**
参照缓存一文

**ProxyTransactionManagementConfiguration（事务核心bean的构建）**
`AnnotationTransactionAttributeSource`和`TransactionInterceptor`这两个bean又都注册到了`BeanFactoryTransactionAttributeSourceAdvisor`中。

**代理的实现核心拦截器**
```
// 1.
public Object invoke(MethodInvocation invocation) throws Throwable {
		Class<?> targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null);
		return invokeWithinTransaction(invocation.getMethod(), targetClass, invocation::proceed);
	}
// 2.TransactionAspectSupport
protected Object invokeWithinTransaction(Method method, @Nullable Class<?> targetClass,
			final InvocationCallback invocation) throws Throwable {

		// 获取 @Transactional 注解事务属性
		TransactionAttributeSource tas = getTransactionAttributeSource();
		// 根据方法和class获取事务属性
		final TransactionAttribute txAttr = (tas != null ? tas.getTransactionAttribute(method, targetClass) : null);
		// 获取事务管理器 defaultTransactionManager = this.beanFactory.getBean(PlatformTransactionManager.class);
		final PlatformTransactionManager tm = determineTransactionManager(txAttr);
		// 获取需要执行的目标方法 com.example.demo.service.impl.SysUserServiceImpl.addUser
		final String joinpointIdentification = methodIdentification(method, targetClass, txAttr);
    //声明式事务
		if (txAttr == null || !(tm instanceof CallbackPreferringPlatformTransactionManager)) {
			// 1. 创建TransactionInfo
			TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);
			Object retVal;
			try {
			  // 2. 调用执行链
				retVal = invocation.proceedWithInvocation();
			}
			catch (Throwable ex) {
				// 3. 异常回滚
				completeTransactionAfterThrowing(txInfo, ex);
				throw ex;
			}
			finally {
			  // 4. 清除事务信息(重置线程局部变量的事务信息)
				cleanupTransactionInfo(txInfo);
			}
			// 5. 提交事务
			commitTransactionAfterReturning(txInfo);
			return retVal;
		}

		else {
			final ThrowableHolder throwableHolder = new ThrowableHolder();

			// It's a CallbackPreferringPlatformTransactionManager: pass a TransactionCallback in.
			try {
				Object result = ((CallbackPreferringPlatformTransactionManager) tm).execute(txAttr, status -> {
					TransactionInfo txInfo = prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);
					try {
						return invocation.proceedWithInvocation();
					}
					catch (Throwable ex) {
						if (txAttr.rollbackOn(ex)) {
							// A RuntimeException: will lead to a rollback.
							if (ex instanceof RuntimeException) {
								throw (RuntimeException) ex;
							}
							else {
								throw new ThrowableHolderException(ex);
							}
						}
						else {
							// A normal return value: will lead to a commit.
							throwableHolder.throwable = ex;
							return null;
						}
					}
					finally {
						cleanupTransactionInfo(txInfo);
					}
				});

				// Check result state: It might indicate a Throwable to rethrow.
				if (throwableHolder.throwable != null) {
					throw throwableHolder.throwable;
				}
				return result;
			}
			catch (ThrowableHolderException ex) {
				throw ex.getCause();
			}
			catch (TransactionSystemException ex2) {
				if (throwableHolder.throwable != null) {
					logger.error("Application exception overridden by commit exception", throwableHolder.throwable);
					ex2.initApplicationException(throwableHolder.throwable);
				}
				throw ex2;
			}
			catch (Throwable ex2) {
				if (throwableHolder.throwable != null) {
					logger.error("Application exception overridden by commit exception", throwableHolder.throwable);
				}
				throw ex2;
			}
		}
	}

// 创建事务
protected TransactionInfo createTransactionIfNecessary(@Nullable PlatformTransactionManager tm,
			@Nullable TransactionAttribute txAttr, final String joinpointIdentification) {
		//如果事务没有指定名称则使用方法标识
		if (txAttr != null && txAttr.getName() == null) {
			txAttr = new DelegatingTransactionAttribute(txAttr) {
				@Override
				public String getName() {
					return joinpointIdentification;
				}
			};
		}

		TransactionStatus status = null;
		if (txAttr != null) {
			if (tm != null) {
			  //1. 获取事务
				status = tm.getTransaction(txAttr);
			}
			else {
				if (logger.isDebugEnabled()) {
					logger.debug("Skipping transactional joinpoint [" + joinpointIdentification +
							"] because no transaction manager has been configured");
				}
			}
		}
		// 2. 构建事务信
		return prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);
	}

// 获取事务
public final TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException {
		// //1. 获取事务
		Object transaction = doGetTransaction();
		boolean debugEnabled = logger.isDebugEnabled();
		if (definition == null) {
			// Use defaults if no transaction definition given.
			definition = new DefaultTransactionDefinition();
		}
    //2. 判断当前线程是否存在事务
		if (isExistingTransaction(transaction)) {
		  // 存在事务则使用嵌套事务处理
			return handleExistingTransaction(definition, transaction, debugEnabled);
		}

		// 事务超时
		if (definition.getTimeout() < TransactionDefinition.TIMEOUT_DEFAULT) {
			throw new InvalidTimeoutException("Invalid transaction timeout", definition.getTimeout());
		}

		// 如果当前没有事务，但是事务的传播行为被定义为PROPAGATION_MANDATORY，则抛出异常
		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) {
			throw new IllegalTransactionStateException(
					"No existing transaction found for transaction marked with propagation 'mandatory'");
		}// 当事务的传播行为需要新建事务时的处理
		else if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||
				definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||
				definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {
			SuspendedResourcesHolder suspendedResources = suspend(null);
			if (debugEnabled) {
				logger.debug("Creating new transaction with name [" + definition.getName() + "]: " + definition);
			}
			try {
				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);
				DefaultTransactionStatus status = newTransactionStatus(
						definition, transaction, true, newSynchronization, debugEnabled, suspendedResources);
				doBegin(transaction, definition);//3. 准备事务
				prepareSynchronization(status, definition);//4. 记录事务状态
				return status;
			}
			catch (RuntimeException | Error ex) {
				resume(null, suspendedResources);
				throw ex;
			}
		}
		else {
			// 创建空事务
			if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT && logger.isWarnEnabled()) {
				logger.warn("Custom isolation level specified but no actual transaction initiated; " +
						"isolation level will effectively be ignored: " + definition);
			}
			boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);
			return prepareTransactionStatus(definition, null, true, newSynchronization, debugEnabled, null);
		}
	}
```


##### Spring框架通过使用以下方法提供了两种编程事务管理方法：
* TransactionTemplate
```
// TransactionCallback()可以返回一个值,TransactionCallbackWithoutResult没有返回值。
Object execute = transactionTemplate.execute((transactionStatus) -> {
    try {
        sysUserMapper.insert(sysUser);
        sysUserMapper.insert(sysUser);
    } catch (Exception e) {
        transactionStatus.setRollbackOnly();
    }
    return null;
});
```

* A PlatformTransactionManager implementation directly
```
DefaultTransactionDefinition def = new DefaultTransactionDefinition();
// explicitly setting the transaction name is something that can be done only programmatically
def.setName("SomeTxName");
def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);

TransactionStatus status = txManager.getTransaction(def);
try {
    // execute your business logic here
}
catch (MyException ex) {
    txManager.rollback(status);
    throw ex;
}
txManager.commit(status);
```

**事务绑定事件**
从Spring4.2开始，事件的侦听器可以绑定到事务的一个阶段。

**事务提交成功后进行异步操作**
Spring它非常友好的提供了两种解决方案来处理：
* 事务同步管理器TransactionSynchronizationManager
* @TransactionalEventListener注解（需要Spring4.2+）
```
TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronizationAdapter() {
        @Override
        public void afterCommit() {
            System.out.println("send email after transaction commit...");
        }
});

//
@Transactional(propagation = Propagation.SUPPORTS,readOnly = true)
public class SysUserServiceImpl implements SysUserService {
    @Autowired
    private SysUserMapper sysUserMapper;
    @Autowired
    private ApplicationEventPublisher applicationEventPublisher;
    @Override
    @Transactional()
    public void addUser(SysUser sysUser) {
        sysUserMapper.insert(sysUser);
        sysUserMapper.insert(sysUser);
        // 1. 发布一个自定义的事件
        applicationEventPublisher.publishEvent(new MyAfterTransactionEvent("事务相关的事件，事务操作","msg"));
    }
}
//2. Listener
@Slf4j
@Component
public   class MyTransactionListener {
    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMPLETION)
    private void onHelloEvent(MyAfterTransactionEvent event) {
        Object source = event.getSource();
        Object msg = event.getMsg();
        log.info(source + "@@@@" + msg.toString());
    }
}
// 3. 定义一个事件，继承自ApplicationEvent
@Data
public class MyAfterTransactionEvent extends ApplicationEvent {
    protected   Object msg;

    public MyAfterTransactionEvent(Object source, String msg) {
        super(source);
        this.msg = msg;
    }
}
```


spring的TransactionInterceptor配置什么时候被启动并成为Advisor通知器的一部分？

方法createMainInterceptor()在IOC容器完成依赖注入时，通过Initializbean方法被调用，该类实现了InitializingBean接口
在其方法afterPropertiesSet()中完成ProxyFactory生成代理对象，配置通知器，设置代理接口等

```
public void afterPropertiesSet() {
		if (this.target == null) {
			throw new IllegalArgumentException("Property 'target' is required");
		}
		if (this.target instanceof String) {
			throw new IllegalArgumentException("'target' needs to be a bean reference, not a bean name as value");
		}
		if (this.proxyClassLoader == null) {
			this.proxyClassLoader = ClassUtils.getDefaultClassLoader();
		}
		// TransactionProxyFactoryBean使用ProxyFactory完成AOP功能，ProxyFactory提供proxy对象
		// 并将TransactionInterceptor设置为target方法调用的拦截器
		ProxyFactory proxyFactory = new ProxyFactory();

		if (this.preInterceptors != null) {
			for (Object interceptor : this.preInterceptors) {
				proxyFactory.addAdvisor(this.advisorAdapterRegistry.wrap(interceptor));
			}
		}

		// spring在这里添加通知器,可以加入2种通知器：DefaultPointcutAdvisor 和TransactionAttributeSourceAdvisor
		proxyFactory.addAdvisor(this.advisorAdapterRegistry.wrap(createMainInterceptor()));

		if (this.postInterceptors != null) {
			for (Object interceptor : this.postInterceptors) {
				proxyFactory.addAdvisor(this.advisorAdapterRegistry.wrap(interceptor));
			}
		}

		proxyFactory.copyFrom(this);
		// 创建AOP的目标源
		TargetSource targetSource = createTargetSource(this.target);
		proxyFactory.setTargetSource(targetSource);

		if (this.proxyInterfaces != null) {
			proxyFactory.setInterfaces(this.proxyInterfaces);
		}
		else if (!isProxyTargetClass()) {
			// Rely on AOP infrastructure to tell us what interfaces to proxy.
			Class<?> targetClass = targetSource.getTargetClass();
			if (targetClass != null) {
				proxyFactory.setInterfaces(ClassUtils.getAllInterfacesForClass(targetClass, this.proxyClassLoader));
			}
		}

		postProcessProxyFactory(proxyFactory);

		this.proxy = proxyFactory.getProxy(this.proxyClassLoader);
	}
```


#### 事务的创建
TransactionAspectSupport的createTransactionIfNecessary()方法作为事务创建的入口，在该方法调用中。会向AbstractPlatformTransactionManager
执行getTransaction(),这个是获取Transaction事务对象的过程，在AbstractPlatformTransactionManager实现中 需要对事务的情况做出不同的处理，然后创建
一个TransactionStatus,并将其设置到TransactionInfo中去，同时将TransactionInfo和当前线程绑定，从而完成事务的创建。

TransactionStatus封装了底层事务对象的创建，事务创建的结果是生成一个TransactionStatus对象，其是TransactionInfo的一个属性，TransactionInfo会保存在ThreadLocal
对象中。

* 新事务创建：首先吧创建的任务交给具体的事务处理器来完成，比如DataSourceTransactionManager，把创建d的事务对象在TransactionInfo中保存下来，然后把
其他的事务属性，和线程ThreadLocal变量进行绑定。

* 创建当前事务时，线程中已存在事务，当线程调用事务方法时，会考虑事务的创建处理，会涉及对现有事务的处理包括事务的传播特性。
```java
private TransactionStatus handleExistingTransaction(TransactionDefinition definition, Object transaction, boolean debugEnabled)
			throws TransactionException {
    //1. 如果当前线程已有事务存在，并且当前事务的传播特性是never,那么抛出异常。
    //   说明这种情况是有问题的，Spring无法处理当前事务的创建。
    //   即这个属性如果在调用者上，则直接以非事务运行。如果作用在被调用者上，则看调用者是否有事务，
    //   如果调用者有事务，则抛出异常，如果没有事务，则以非事务运行。
		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NEVER) {
			throw new IllegalTransactionStateException(
					"Existing transaction found for transaction marked with propagation 'never'");
		}
    // 2. 如果当前事务的配置属性是PROPAGATION_NOT_SUPPORTED，同时当前线程已经存在事务，那么将事务挂起。
    //    即如果当前存在事务，就把当前事务挂起，然后以非事务方式执行操作（挂起后的操作出现异常不回滚，在挂起点前的操作仍然可以回滚）。
		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NOT_SUPPORTED) {
			if (debugEnabled) {
				logger.debug("Suspending current transaction");
			}
			Object suspendedResources = suspend(transaction);
			boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);
			// 这里的参数transaction是null，newTransaction是false，意味着方法不需要在事务环境下运行，
			// 同时挂起的事务的信息j记录y也保存在TransactionStatus中，包括对ThreadLoLocal对事务的记录。
			return prepareTransactionStatus(
					definition, null, false, newSynchronization, debugEnabled, suspendedResources);
		}
    // 3. 如果当前事务的配置是PROPAGATION_REQUIRES_NEW，创建新事务，同时把当前线程中的事务挂起
    //    不管调用者是否存在事务，被调用者都会新开一个事务，相当于被调用者始终存在于自己的事务，该事务和调用者是否有事务并没有关系。
    //    换句话说，它们是不同的事务，相互不会影响。
		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW) {
			if (debugEnabled) {
				logger.debug("Suspending current transaction, creating new transaction with name [" +
						definition.getName() + "]");
			}
			SuspendedResourcesHolder suspendedResources = suspend(transaction);
			try {
				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);
				DefaultTransactionStatus status = newTransactionStatus(
						definition, transaction, true, newSynchronization, debugEnabled, suspendedResources);
				doBegin(transaction, definition);
				prepareSynchronization(status, definition);
				return status;
			}
			catch (RuntimeException | Error beginEx) {
				resumeAfterBeginException(transaction, suspendedResources, beginEx);
				throw beginEx;
			}
		}
    // 4. 嵌套事务的创建，如果当前存在事务，则在嵌套事务内执行。如果当前没有事务，则执行与PROPAGATION_REQUIRED类似的操作。
		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {
			if (!isNestedTransactionAllowed()) {
				throw new NestedTransactionNotSupportedException(
						"Transaction manager does not allow nested transactions by default - " +
						"specify 'nestedTransactionAllowed' property with value 'true'");
			}
			if (debugEnabled) {
				logger.debug("Creating nested transaction with name [" + definition.getName() + "]");
			}
			if (useSavepointForNestedTransaction()) {
				// Create savepoint within existing Spring-managed transaction,
				// through the SavepointManager API implemented by TransactionStatus.
				// Usually uses JDBC 3.0 savepoints. Never activates Spring synchronization.
				// 在Spring事务管理中，创建事务保存点
				DefaultTransactionStatus status = prepareTransactionStatus(definition, transaction, false, false, debugEnabled, null);
				status.createAndHoldSavepoint();
				return status;
			}
			else {
				// Nested transaction through nested begin and commit/rollback calls.
				// Usually only for JTA: Spring synchronization might get activated here
				// in case of a pre-existing JTA transaction.
				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);
				DefaultTransactionStatus status = newTransactionStatus(
						definition, transaction, true, newSynchronization, debugEnabled, null);
				doBegin(transaction, definition);
				prepareSynchronization(status, definition);
				return status;
			}
		}

		// Assumably PROPAGATION_SUPPORTS or PROPAGATION_REQUIRED.
		if (debugEnabled) {
			logger.debug("Participating in existing transaction");
		}
		if (isValidateExistingTransaction()) {
			if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT) {
				Integer currentIsolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel();
				if (currentIsolationLevel == null || currentIsolationLevel != definition.getIsolationLevel()) {
					Constants isoConstants = DefaultTransactionDefinition.constants;
					throw new IllegalTransactionStateException("Participating transaction with definition [" +
							definition + "] specifies isolation level which is incompatible with existing transaction: " +
							(currentIsolationLevel != null ?
									isoConstants.toCode(currentIsolationLevel, DefaultTransactionDefinition.PREFIX_ISOLATION) :
									"(unknown)"));
				}
			}
			if (!definition.isReadOnly()) {
				if (TransactionSynchronizationManager.isCurrentTransactionReadOnly()) {
					throw new IllegalTransactionStateException("Participating transaction with definition [" +
							definition + "] is not marked as read-only but existing transaction is");
				}
			}
		}
		boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);
		return prepareTransactionStatus(definition, transaction, false, newSynchronization, debugEnabled, null);
	}
```
#### 事务挂起
事务的挂起涉及线程和事务信息的保存，
```java
protected final SuspendedResourcesHolder suspend(@Nullable Object transaction) throws TransactionException {
		if (TransactionSynchronizationManager.isSynchronizationActive()) {
			List<TransactionSynchronization> suspendedSynchronizations = doSuspendSynchronization();
			try {
				Object suspendedResources = null;
				// 1. 把挂起的事务交给具体的事务管理器去完成，如果具体的事务处理器不支持事务挂起，则抛出异常
				if (transaction != null) {
					suspendedResources = doSuspend(transaction);
				}
				// 这里在线程中保存和事务处理相关的信息，重置线程中相关的ThreadLocal变量
				String name = TransactionSynchronizationManager.getCurrentTransactionName();
				TransactionSynchronizationManager.setCurrentTransactionName(null);
				boolean readOnly = TransactionSynchronizationManager.isCurrentTransactionReadOnly();
				TransactionSynchronizationManager.setCurrentTransactionReadOnly(false);
				Integer isolationLevel = TransactionSynchronizationManager.getCurrentTransactionIsolationLevel();
				TransactionSynchronizationManager.setCurrentTransactionIsolationLevel(null);
				boolean wasActive = TransactionSynchronizationManager.isActualTransactionActive();
				TransactionSynchronizationManager.setActualTransactionActive(false);
				return new SuspendedResourcesHolder(
						suspendedResources, suspendedSynchronizations, name, readOnly, isolationLevel, wasActive);
			}
			catch (RuntimeException | Error ex) {
				// doSuspend failed - original transaction is still active...
				// doSuspend 失败，初始的事务仍然存在
				doResumeSynchronization(suspendedSynchronizations);
				throw ex;
			}
		}
		else if (transaction != null) {
			// Transaction active but no synchronization active.
			Object suspendedResources = doSuspend(transaction);
			return new SuspendedResourcesHolder(suspendedResources);
		}
		else {
			// Neither transaction nor synchronization active.
			return null;
		}
	}
```

#### 事务提交
```
TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);
commitTransactionAfterReturning(txInfo);

// 直接调用事务管理器完成提交
protected void commitTransactionAfterReturning(@Nullable TransactionInfo txInfo) {
		if (txInfo != null && txInfo.getTransactionStatus() != null) {
			if (logger.isTraceEnabled()) {
				logger.trace("Completing transaction for [" + txInfo.getJoinpointIdentification() + "]");
			}
			txInfo.getTransactionManager().commit(txInfo.getTransactionStatus());
		}
	}

// 提交方法类似getTransaction
public final void commit(TransactionStatus status) throws TransactionException {
    // TransactionStatus中的事务标识是否已完成
		if (status.isCompleted()) {
			throw new IllegalTransactionStateException(
					"Transaction is already completed - do not call commit or rollback more than once per transaction");
		}
    // 如果事务处理过程中出现异常，调用回滚
		DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status;
		if (defStatus.isLocalRollbackOnly()) {
			if (defStatus.isDebug()) {
				logger.debug("Transactional code has requested rollback");
			}
			// 回滚处理
			processRollback(defStatus, false);
			return;
		}

		if (!shouldCommitOnGlobalRollbackOnly() && defStatus.isGlobalRollbackOnly()) {
			if (defStatus.isDebug()) {
				logger.debug("Global transaction is marked as rollback-only but transactional code requested commit");
			}
			processRollback(defStatus, true);
			return;
		}
    // 提交事务处理
		processCommit(defStatus);
	}

private void processCommit(DefaultTransactionStatus status) throws TransactionException {
		try {
			boolean beforeCompletionInvoked = false;

			try {
			  // 事务提交前的准备，由具体的事务管理器来完成
				boolean unexpectedRollback = false;
				prepareForCommit(status);
				triggerBeforeCommit(status);
				triggerBeforeCompletion(status);
				beforeCompletionInvoked = true;
        // 嵌套事务处理
				if (status.hasSavepoint()) {
					if (status.isDebug()) {
						logger.debug("Releasing transaction savepoint");
					}
					unexpectedRollback = status.isGlobalRollbackOnly();
					status.releaseHeldSavepoint();
				}
				// 根据当前线程事务状态进行处理，如果当前事务是一个新事务，则调用具体的事务处理器完成提交，
				// 如果当前线程持有的事务不是一个新事务，则不提交，由已经存在的事务来完成提交。
				else if (status.isNewTransaction()) {
					if (status.isDebug()) {
						logger.debug("Initiating transaction commit");
					}
					unexpectedRollback = status.isGlobalRollbackOnly();
					doCommit(status);
				}
				else if (isFailEarlyOnGlobalRollbackOnly()) {
					unexpectedRollback = status.isGlobalRollbackOnly();
				}

				// Throw UnexpectedRollbackException if we have a global rollback-only
				// marker but still didn't get a corresponding exception from commit.
				if (unexpectedRollback) {
					throw new UnexpectedRollbackException(
							"Transaction silently rolled back because it has been marked as rollback-only");
				}
			}
			catch (UnexpectedRollbackException ex) {
				// can only be caused by doCommit
				triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK);
				throw ex;
			}
			catch (TransactionException ex) {
				// can only be caused by doCommit
				if (isRollbackOnCommitFailure()) {
					doRollbackOnCommitException(status, ex);
				}
				else {
					triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);
				}
				throw ex;
			}
			catch (RuntimeException | Error ex) {
				if (!beforeCompletionInvoked) {
					triggerBeforeCompletion(status);
				}
				doRollbackOnCommitException(status, ex);
				throw ex;
			}

			// Trigger afterCommit callbacks, with an exception thrown there
			// propagated to callers but the transaction still considered as committed.
			try {
				triggerAfterCommit(status);
			}
			finally {
				triggerAfterCompletion(status, TransactionSynchronization.STATUS_COMMITTED);
			}

		}
		finally {
			cleanupAfterCompletion(status);
		}
	}
```


#### 事务回滚
```
public final void rollback(TransactionStatus status) throws TransactionException {
		if (status.isCompleted()) {
			throw new IllegalTransactionStateException(
					"Transaction is already completed - do not call commit or rollback more than once per transaction");
		}

		DefaultTransactionStatus defStatus = (DefaultTransactionStatus) status;
		processRollback(defStatus, false);
	}

private void processRollback(DefaultTransactionStatus status, boolean unexpected) {
		try {
			boolean unexpectedRollback = unexpected;

			try {
				triggerBeforeCompletion(status);
        // 嵌套事务回滚
				if (status.hasSavepoint()) {
					if (status.isDebug()) {
						logger.debug("Rolling back transaction to savepoint");
					}
					status.rollbackToHeldSavepoint();
				}
				// 当前调用方法中新建事务回滚
				else if (status.isNewTransaction()) {
					if (status.isDebug()) {
						logger.debug("Initiating transaction rollback");
					}
					doRollback(status);
				}
				else {
					// Participating in larger transaction
					if (status.hasTransaction()) {
						if (status.isLocalRollbackOnly() || isGlobalRollbackOnParticipationFailure()) {
							if (status.isDebug()) {
								logger.debug("Participating transaction failed - marking existing transaction as rollback-only");
							}
							doSetRollbackOnly(status);
						}
						else {
							if (status.isDebug()) {
								logger.debug("Participating transaction failed - letting transaction originator decide on rollback");
							}
						}
					}
					else {
						logger.debug("Should roll back transaction but cannot - no transaction available");
					}
					// Unexpected rollback only matters here if we're asked to fail early
					if (!isFailEarlyOnGlobalRollbackOnly()) {
						unexpectedRollback = false;
					}
				}
			}
			catch (RuntimeException | Error ex) {
				triggerAfterCompletion(status, TransactionSynchronization.STATUS_UNKNOWN);
				throw ex;
			}

			triggerAfterCompletion(status, TransactionSynchronization.STATUS_ROLLED_BACK);

			// Raise UnexpectedRollbackException if we had a global rollback-only marker
			if (unexpectedRollback) {
				throw new UnexpectedRollbackException(
						"Transaction rolled back because it has been marked as rollback-only");
			}
		}
		finally {
			cleanupAfterCompletion(status);
		}
	}
```

#### spring 中事务管理器的设计和实现
Spring的事务处理分2部分完成，通用的事务处理框架在AbstractPlatformTransactionManager中完成，而事务接口和数据源实现的接口大多由具体的事务处理器来完成
它们都是作为AbstractPlatformTransactionManager子类来使用的。

DataSourceTransactionManager在事务开始的时候会调用doBegin()方法,首先的到Connection，如何根据事务的需要，设置Connection属性（比如设置自动提交为false）
最后通过TransactionSynchronizationManager来进行资源绑定。

DataSourceTransactionManager实现事务的创建，提交，回滚和单独使用Connection实现事务处理基本一致。

