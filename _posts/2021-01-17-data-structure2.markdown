---
layout: post
title:  "算法2"
date:   2021-01-17 15:12:42
author: zhangtj
categories: zhangtj
---
##### 冒泡排序
1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
2. 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。完成后，最后的元素应该是最大的数。
3. 针对所有的元素重复以上的步骤，除了最后一个。 

```java
public static void bubbleSort(int arr[]) {
    // 比较相邻元素，所以不需要循环最后一个元素
    for(int i = 0;i<arr.length-1;i++){
        // 最后一个 已经有序（最大）
        for(int j = 0;j<arr.length-i-1;j++){
            if (arr[j] > arr[j+1]){
                int temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
            }
        }
    }
}
```
N个数字要排序完成，总共进行N-1趟排序，每i趟的排序次数为(N-i)次,外层控制循环多少趟，内层控制每一趟的循环次数。

冒泡排序的优点：每进行一趟排序，就会少比较一次，因为每进行一趟排序都会找出一个较大值。

如上例：第一趟比较之后，排在最后的一个数一定是最大的一个数，第二趟排序的时候，只需要比较除了最后一个数以外的其他的数，
同样也能找出一个最大的数排在参与第二趟比较的数后面，
第三趟比较的时候，只需要比较除了最后两个数以外的其他的数，
以此类推……也就是说，每进行一趟比较，每一趟少比较一次，。

冒泡排序的效率：  
其执行步骤包含比较和交换，对于N个元素，需要`(N-1)+(N-2)+(N-3)+···+1`次比较；3*((N-1)+(N-2)+(N-3)+···+1)次交换

时间复杂度：O(n²) 

1. 如果数据正序，只需要走一趟即可完成排序。所需的比较次数C和记录移动次数M均达到最小值，即：Cmin=n-1;Mmin=0;所以，冒泡排序最好的时间复杂度为O(n)。
2. 如果数据是反序的，则需要进行n-1趟排序。每趟排序要进行n-i次比较(1≤i≤n-1)，且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值：
即：Cmax=(N-1)+(N-2)+(N-3)+···+1; Mmax=3*((N-1)+(N-2)+(N-3)+···+1);

冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，是不会再交换的；
如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。

##### 选择排序
第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，
然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。
以此类推，直到全部待排序的数据元素的个数为零。

```java
public static void selectionSort(int arr[]) {
    // 需要比较的次数，数组长度减一
    for (int i = 0; i < arr.length-1; i++) {
        int lowestIndex = i; // 先假设每次循环时，最小数的索引为i
        for (int j = i+1; j < arr.length; j++) {
            if (arr[j] <arr[lowestIndex]){
                // 寻找最小数
                lowestIndex = j;
            }
        }
        if (i != lowestIndex){
            // 找到最小值，放到开始的位置，第一个位置的数字已经是有序了
            int temp = arr[i];
            arr[i] = arr[lowestIndex];
            arr[lowestIndex] = temp;
        }
    }
    System.out.println();
    for (int count : arr){
        System.out.print(count);
    }
}
```

选择排序的效率：  O(n²/2) = O(n²)
其执行步骤包含比较和交换，对于N个元素，需要`(N-1)+(N-2)+(N-3)+···+1`次比较；但是每轮交换最多只需要一次。
选择排序的步数大概只有冒泡排序的一半，但是其大O记法和冒泡排序是一样的O(n²)，大O记法常数。

稳定性：

如果一个元素比当前元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。
举个例子，序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中两个5的相对前后顺序就被破坏了，所以选择排序是一个不稳定的排序算法。

##### 插入排序
外层循环对除了第一个元素之外的所有元素，内层循环对当前元素前面有序表进行待插入位置查找，并进行移动；
即从第二个元素开始，和其左侧的数据比较（其左侧可以看做是已有序的元素）。

```java
public static void insertSort(int arr[]) {
    for (int i = 1; i < arr.length; i++) {
        for(int j = i;j>0 && arr[j-1]>arr[j];j--){ // 对比左侧列表,如果j-1 > j 则交换位置
            int temp = arr[j];
            arr[j] = arr[j-1];
            arr[j-1] = temp;
        }
    }
    System.out.println();
    for (int count : arr){
        System.out.print(count);
    }
}
```
插入排序的效率：  
其执行步骤包含移除，比较，平移和交换，对于N个元素，需要`n²/2`次比较；需要`n²/2`次平移，N-1次移除，N-1次插入，插入排序和冒泡，选择一样，时间复杂度都是O(n²)
实际上最坏的情况下，选择排序需要的步数是n²/2步，冒泡排序是n²步，插入排序n²+2N-2步

插入排序再不同场景下差异较大；最坏，平均，最好的情况下，分别是n²，n²/2，N步。

选择排序无论何种情况下，都是n²/2步。


时间复杂度：

在插入排序中，当待排序数组是有序时，是最优的情况，只需当前数跟前一个数比较一下就可以了，这时一共需要比较N- 1次，时间复杂度为O(n)；

最坏的情况是待排序数组是逆序的，此时需要比较次数最多，总次数记为：1+2+3+…+N-1，所以，插入排序最坏情况下的时间复杂度为 O(n²)；

稳定性分析：

如果待排序的序列中存在两个或两个以上具有相同关键词的数据，排序后这些数据的相对次序保持不变，即它们的位置保持不变，通俗地讲，就是两个相同的数的相对顺序不会发生改变，则该算法是稳定的；如果排序后，数据的相对次序发生了变化，则该算法是不稳定的。关键词相同的数据元素将保持原有位置不变，所以该算法是稳定的


哪种算法更好？

对于平均情况（数组里随机分配），选择和插入排序性能相近，如果数组大致有序，那么插入比较好，如果数组大致倒序，那么选择排序较好，无法判断数据的什么样，就选平均情况，都可以选择。

常用的二分查找算法需要用数组来存储数据，如果使用链表来存储，就无法使用二分查找法，因为链表不支持随机访问。
