---
layout: post
title:  "算法2"
date:   2021-01-17 15:12:42
author: zhangtj
categories: zhangtj
---
##### 数组
数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。

第一是线性表（Linear List）。顾名思义，线性表就是数据排成像一条线一样的结构。
每个线性表上的数据最多只有前和后两个方向。其实除了数组，链表、队列、栈等也是线性表结构。

而与它相对立的概念是非线性表，比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。

第二个是连续的内存空间和相同类型的数据。正是因为这两个限制，它才有了一个堪称“杀手锏”的特性：“随机访问”。
但有利就有弊，这两个限制也让数组的很多操作变得非常低效，比如要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。

低效的“插入”和“删除”：

假设数组的长度为 n，现在，如果我们需要将一个数据插入到数组中的第 k 个位置。
为了把第 k 个位置腾出来，给新来的数据，我们需要将第 k～n 这部分的元素都顺序地往后挪一位。
如果在数组的末尾插入元素，那就不需要移动数据了，这时的时间复杂度为 O(1)。但如果在数组的开头插入元素，
那所有的数据都需要依次往后移动一位，所以最坏时间复杂度是 O(n)。 因为我们在每个位置插入元素的概率是一样的，所以平均情况时间复杂度为 (1+2+...n)/n=O(n)。

##### 链表（Linked list）
经典的链表应用场景，那就是 LRU 缓存淘汰算法；。常见的缓存淘汰策略有三种：先进先出策略 FIFO（First In，First Out）、最少使用策略 LFU（Least Frequently Used）、
最近最少使用策略 LRU（Least Recently Used）。

单链表、双向链表和循环链表

如果你的代码对内存的使用非常苛刻，那数组就更适合你。因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下
一个结点的指针，所以内存消耗会翻倍。而且，对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片，
如果是 Java 语言，就有可能会导致频繁的 GC（Garbage Collection，垃圾回收）

##### 冒泡排序
1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
2. 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。完成后，最后的元素应该是最大的数。
3. 针对所有的元素重复以上的步骤，除了最后一个。 

```java
public static void bubbleSort(int arr[]) {
    // 比较相邻元素，所以不需要循环最后一个元素
    for(int i = 0;i<arr.length-1;i++){
        // 最后一个 已经有序（最大）
        for(int j = 0;j<arr.length-i-1;j++){
            if (arr[j] > arr[j+1]){
                int temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
            }
        }
    }
}

public static void bubbleSort(int arr[]) {
    // 比较相邻元素，所以不需要循环最后一个元素
        int[] arr = new int[]{7,6,3,2,1};
       //int[] arr = new int[]{1,4,3,5,8};
       boolean flag = true; // flag 用作标记是否需要排序
       for(int i = 0;i<arr.length-1 && flag;i++){
           flag = false;  // 初始化为 false
           for(int j = 0 ;j<arr.length-1-i;j++){
               if (arr[j] > arr[j+1]){
                   int temp = arr[j];
                   arr[j] = arr[j+1];
                   arr[j+1] = temp;
                   flag = true;
               }
           }
       }
}

```
N个数字要排序完成，总共进行N-1趟排序，每i趟的排序次数为(N-i)次,外层控制循环多少趟，内层控制每一趟的循环次数。

冒泡排序的优点：每进行一趟排序，就会少比较一次，因为每进行一趟排序都会找出一个较大值。

如上例：第一趟比较之后，排在最后的一个数一定是最大的一个数，第二趟排序的时候，只需要比较除了最后一个数以外的其他的数，
同样也能找出一个最大的数排在参与第二趟比较的数后面，
第三趟比较的时候，只需要比较除了最后两个数以外的其他的数，
以此类推……也就是说，每进行一趟比较，每一趟少比较一次，。

冒泡排序的效率：  
其执行步骤包含比较和交换，对于N个元素，需要`(N-1)+(N-2)+(N-3)+···+1`次比较；3*((N-1)+(N-2)+(N-3)+···+1)次交换

时间复杂度：O(n²) 

1. 如果数据正序，只需要走一趟即可完成排序【需要设置一个flag方可实现】。所需的比较次数C和记录移动次数M均达到最小值，即：Cmin=n-1;Mmin=0;所以，冒泡排序最好的时间复杂度为O(n)。
2. 如果数据是反序的，则需要进行n-1趟排序。每趟排序要进行n-i次比较(1≤i≤n-1)，且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值：
即：Cmax=(N-1)+(N-2)+(N-3)+···+1; Mmax=3*((N-1)+(N-2)+(N-3)+···+1);

冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，是不会再交换的；
如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。

##### 选择排序
第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，
然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。
以此类推，直到全部待排序的数据元素的个数为零。

```java
public static void selectionSort(int arr[]) {
    // 需要比较的次数，数组长度减一
    for (int i = 0; i < arr.length-1; i++) {
        int lowestIndex = i; // 先假设每次循环时，最小数的索引为i
        for (int j = i+1; j < arr.length; j++) {
            if (arr[j] <arr[lowestIndex]){
                // 寻找最小数
                lowestIndex = j;
            }
        }
        if (i != lowestIndex){
            // 找到最小值，放到开始的位置，第一个位置的数字已经是有序了
            int temp = arr[i];
            arr[i] = arr[lowestIndex];
            arr[lowestIndex] = temp;
        }
    }
    System.out.println();
    for (int count : arr){
        System.out.print(count);
    }
}
```

选择排序的效率：  O(n²/2) = O(n²)
其执行步骤包含比较和交换，对于N个元素，需要`(N-1)+(N-2)+(N-3)+···+1`次比较；但是每轮交换最多只需要一次。
选择排序的步数大概只有冒泡排序的一半，但是其大O记法和冒泡排序是一样的O(n²)，大O记法常数。

稳定性：

如果一个元素比当前元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。
举个例子，序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中两个5的相对前后顺序就被破坏了，所以选择排序是一个不稳定的排序算法。

##### 插入排序
外层循环对除了第一个元素之外的所有元素，内层循环对当前元素前面有序表进行待插入位置查找，并进行移动；
即从第二个元素开始，和其左侧的数据比较（其左侧可以看做是已有序的元素）。

```java
public static void insertSort(int arr[]) {
    for (int i = 1; i < arr.length; i++) {
        for(int j = i;j>0 && arr[j-1]>arr[j];j--){ // 对比左侧列表,如果j-1 > j 则交换位置
            int temp = arr[j];
            arr[j] = arr[j-1];
            arr[j-1] = temp;
        }
    }
    System.out.println();
    for (int count : arr){
        System.out.print(count);
    }
}
```
插入排序的效率：  
其执行步骤包含移除，比较，平移和交换，对于N个元素，需要`n²/2`次比较；需要`n²/2`次平移，N-1次移除，N-1次插入，插入排序和冒泡，选择一样，时间复杂度都是O(n²)
实际上最坏的情况下，选择排序需要的步数是n²/2步，冒泡排序是n²步，插入排序n²+2N-2步

插入排序再不同场景下差异较大；最坏，平均，最好的情况下，分别是n²，n²/2，N步。

选择排序无论何种情况下，都是n²/2步。


时间复杂度：

在插入排序中，当待排序数组是有序时，是最优的情况，只需当前数跟前一个数比较一下就可以了，这时一共需要比较N- 1次，时间复杂度为O(n)；

最坏的情况是待排序数组是逆序的，此时需要比较次数最多，总次数记为：1+2+3+…+N-1，所以，插入排序最坏情况下的时间复杂度为 O(n²)；

稳定性分析：

如果待排序的序列中存在两个或两个以上具有相同关键词的数据，排序后这些数据的相对次序保持不变，即它们的位置保持不变，通俗地讲，就是两个相同的数的相对顺序不会发生改变，则该算法是稳定的；如果排序后，数据的相对次序发生了变化，则该算法是不稳定的。关键词相同的数据元素将保持原有位置不变，所以该算法是稳定的


哪种算法更好？

对于平均情况（数组里随机分配），选择和插入排序性能相近，如果数组大致有序，那么插入比较好，如果数组大致倒序，那么选择排序较好，无法判断数据的什么样，就选平均情况，都可以选择。

常用的二分查找算法需要用数组来存储数据，如果使用链表来存储，就无法使用二分查找法，因为链表不支持随机访问。




合理的思考路径或者说思考方向，

对一组数据排序，
回答点
1. 这组数据有什么特征？
有没有包含大量的重复元素？
如果是，3路归并排序是更好的选择,如果可以肯定数据中所有元素都是普通的，那么普通的快速排更好。
很多语言的排序接口，基本都是3路归并排序。
2. 是否大部分数据距离他正确的位置很近？是否几乎有序？
比如数据的时间排序，可以看作是几乎有序？ 可能插入排序是更好的。
3. 数据的取值范围是否有限？比如学生成绩 （0-100分)
这种情况下，或许计数排序是更好的选择

4. 对排序的是否有额外的要求？
 是否需要满足稳定性？ 如果是，快速排序不是一个更好的选择，而归并排序是更好的选择

5。 数据的存储状况是什么样的？
快速排序非常依赖数据的随机存储的，然后是使用链表存储的？那么归并排序是更好的选择。
数据有多少?是否可以装载在内存中？如果数据量很大或者条件较小，即不能全放内存中，需要使用外排序算法。

6.  OJ (online judge)在线判题系统
leetCode  HackerRank

7. 没有思路的情况？不用忽视暴力解法? 暴力解法通常是思考的起点。

8. 从字符串中找出一个最长的不包含重复字符的子字符串。 
如果没有思路？不妨使用暴力法？ 是否可以遍历字符串中的所有子串？
对于字符串s的子串`s[i...j]`，可以使用O(n^2)的算法遍历i,j，可以得到所有子串`s[i...j]`。
接着使用`O(length(s[i...j]))`的算法判断，字串中是否包含重复字符
这个算法的时间复杂度是O(n^3),对于n=100的数据，可行。（3层循环），我知道这个算法不是最优的，我们现有的业务场景并不需要
处理这么长的字符，所以它也是一个可行的方法。

最难的是优化算法：
首先可以在脑海李遍历下常见的算法思路，看看是不是适用这个问题？
是否需要使用数据结构来辅助，
空间和时间的交换（比如哈希表，对于非常多的算法都有效）
数据预处理（比如排序）

实际编写问题，极端条件判断，比如数组为空，字符串为空数量为0等等
变量的命名规范，模块的复用性

时间复杂度

二分查找发O(logn)

在学术界，严格说大O表示的是算法执行的上界，归并排序算法时间复杂度是O(nlogn),同时也是O(n^2)。
在业界，我们用大O表示算法执行的最低上界。所以一般不会说归并排序算法是O(n^2)

数据规模的概念

对10^5的数据进行选择排序O(n^2)，结果计算机假死？

如果姚想在1s内解决问题：
O(n^2)的算法可以处理大约10^4级别的数据；
O(n)的算法可以处理大约10^8级别的数据；
O(nlogn)的算法可以处理大约10^7级别的数据；

空间复杂度

多开了一个辅助的数组 O(n);
多开了一个辅助的二维数组 O(n^2);
多开常数时间O(1);

递归是由空间代价的，比如求和使用for循环 空间复杂度为O(1);如果使用递归实现，空间复杂度为O(n),即递归的深度。

常见的复杂度分析
```java
// O(1) 没数据规模变化
void swap(int a,int b){
    int temp = a;
    a=b;
    b=temp;
}

// O(n) 典型特点存在一个循环,循环的次数和n相关
int swap(int a,int b){
    int ret = 0;
    for(int i=0;i<=n;i++){
     ret +=i;
    }
  return ret;
}

// 翻转字符串  1/2*n 次swap操作：O(n)
void reverse(String[] s){
    int n = s.size();
    for(int i=0;i<=n/2;i++){
     swap(s[i],s[n-1-i])
    }
}

// O(n^2)
function selectionSort(arr) {
    var len = arr.length;
    var minIndex, temp;
    for (var i = 0; i < len - 1; i++) {
        minIndex = i;
        for (var j = i + 1; j < len; j++) {
            // 执行次数  (n-1) +(n-2) + ....+0 = (0+n-1)*n/2 = 1/2*n^2 - 1/2*n =O(n^2)
            if (arr[j] < arr[minIndex]) {     // 寻找最小的数
                minIndex = j;                 // 将最小数的索引保存
            }
        }
        temp = arr[i];
        arr[i] = arr[minIndex];
        arr[minIndex] = temp;
    }
    return arr;
}
// 30n次基本操作：O(n),因为内层循环 和数据规模n没有关系
void printInfo(int n){
    for(int i=0;i<=n;i++){
        for(int j=0;j<=30;j++){
        System.out.print("")
    }
}
}

// O(logn) 开始在n个元素中查找，接着在n/2个元素中查找 ... 在一个元素中查找，
// 相当于 计算n经过几次“除以2”操作后，等于1？ log2n=O(logn)
int binarySearch(int[] nums, int target) {
    int left = 0; 
    int right = nums.length - 1; // 

    while(left <= right) { // 注意
        int mid = (right + left) / 2;
        if(nums[mid] == target)
            return mid; 
        else if (nums[mid] < target)
            left = mid + 1; // 
        else if (nums[mid] > target)
            right = mid - 1; // 
        }
    return -1;
}

// n经过几次“除以10”操作后，等于1？ log10n=O(logn)
int intToString(int num) {
  String s ="";
    while(num) { // 注意
       s += '0' + num%10;
        num /= 10;
        }
    reverse(s); // 时间复杂度和s有关， s有多少位，和外层循环次数是一致的
    return s;
}
// logaN = logab(常数) * logbN

// O(nlogn)
void hello(int n){
    // O(logn)次
    for(int sz=0;sz<=n;sz +=sz){ // 相当于sz*2 ,和之前的反过来看，计算sz经过几次“乘以2”操作后，大于n？
        // 循环n次
        for(int j=0;j<=n;j++){
        System.out.print("")
    }
}
}

// O(sqrt(n)) 根号n
boolean isPrime(int n){
    for(int x=2;x*x<=n;x++){
    if(n%x == 0) return false;
   return true;
}
}

```

不是有递归的函数就是一定是O(nlogn)。
递归中进行一次递归调用，



数据结构
暴力匹配， KMP算法，部分匹配表

线性结构：其特点是数据元素之间存在一对一的线性关系。常见的线性结构包括：数组、队列、链表、栈
非线性结构：维数组、多维数组、广义表、树结构、图结构

稀疏数组和队列
当一个数组中大部分元素为0，或者为同一值的数组时，可以使用稀疏数组来保存该数组。

稀疏数组的处理方式是:记录数组一共有几行几列，有多少个不同值；把具有不同值的元素和行列及值记录在一个小规模的数组中，从而缩小程序的规模。
```
原始的二维数组
0	0	0	0	0	0	0	0	0	0	0	
0	0	1	0	0	0	0	0	0	0	0	
0	0	0	2	0	0	0	0	0	0	0	
0	0	0	0	0	0	0	0	0	0	0	
0	0	0	0	0	2	0	0	0	0	0	
0	0	0	0	0	0	0	0	0	0	0	
0	0	0	0	0	0	0	0	0	0	0	
0	0	0	0	0	0	0	0	0	0	0	
0	0	0	0	0	0	0	0	0	0	0	
0	0	0	0	0	0	0	0	0	0	0	
0	0	0	0	0	0	0	0	0	0	0

稀疏数组为
row col value
11	11	3
1	2	1
2	3	2
4	5	2
```

稀疏数组转二维数组
先读取稀疏数组的第一行，根据第一行的数据，创建原始的二维数组，比如上面的 `chessArr2 = int [11] [11]`
在读取稀疏数组的第二行开始读取数据，并赋给 原始的二维数组 即可。

二维数组转稀疏数组
先遍历二维数组 得到非0数据的个数m,创建对应的稀疏数组`int[m+1][3]`,遍历二维数组，将非0的值存放到 sparseArr中

**队列**
队列是一个有序的列表，可以用数组或链表来实现。

队列的数据元素又称为队列元素。在队列中插入一个队列元素称为入队，从队列中删除一个队列元素称为出队。因为队列只允许在一端插入，
在另一端删除，所以只有最早进入队列的元素才能最先从队列中删除，故队列又称为先进先出（FIFO—first in first out）线性表。
