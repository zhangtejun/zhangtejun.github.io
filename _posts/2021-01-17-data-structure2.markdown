---
layout: post
title:  "算法2"
date:   2021-01-17 15:12:42
author: zhangtj
categories: zhangtj
---
##### 数组
数组（Array）是一种线性表数据结构。它用一组连续的内存空间，来存储一组具有相同类型的数据。

第一是线性表（Linear List）。顾名思义，线性表就是数据排成像一条线一样的结构。
每个线性表上的数据最多只有前和后两个方向。其实除了数组，链表、队列、栈等也是线性表结构。

而与它相对立的概念是非线性表，比如二叉树、堆、图等。之所以叫非线性，是因为，在非线性表中，数据之间并不是简单的前后关系。

第二个是连续的内存空间和相同类型的数据。正是因为这两个限制，它才有了一个堪称“杀手锏”的特性：“随机访问”。
但有利就有弊，这两个限制也让数组的很多操作变得非常低效，比如要想在数组中删除、插入一个数据，为了保证连续性，就需要做大量的数据搬移工作。

低效的“插入”和“删除”：

假设数组的长度为 n，现在，如果我们需要将一个数据插入到数组中的第 k 个位置。
为了把第 k 个位置腾出来，给新来的数据，我们需要将第 k～n 这部分的元素都顺序地往后挪一位。
如果在数组的末尾插入元素，那就不需要移动数据了，这时的时间复杂度为 O(1)。但如果在数组的开头插入元素，
那所有的数据都需要依次往后移动一位，所以最坏时间复杂度是 O(n)。 因为我们在每个位置插入元素的概率是一样的，所以平均情况时间复杂度为 (1+2+...n)/n=O(n)。

##### 链表（Linked list）
经典的链表应用场景，那就是 LRU 缓存淘汰算法；。常见的缓存淘汰策略有三种：先进先出策略 FIFO（First In，First Out）、最少使用策略 LFU（Least Frequently Used）、
最近最少使用策略 LRU（Least Recently Used）。

单链表、双向链表和循环链表

如果你的代码对内存的使用非常苛刻，那数组就更适合你。因为链表中的每个结点都需要消耗额外的存储空间去存储一份指向下
一个结点的指针，所以内存消耗会翻倍。而且，对链表进行频繁的插入、删除操作，还会导致频繁的内存申请和释放，容易造成内存碎片，
如果是 Java 语言，就有可能会导致频繁的 GC（Garbage Collection，垃圾回收）

##### 冒泡排序
1. 比较相邻的元素。如果第一个比第二个大，就交换他们两个。
2. 对每一对相邻元素做同样的工作，从开始第一对到结尾的最后一对。完成后，最后的元素应该是最大的数。
3. 针对所有的元素重复以上的步骤，除了最后一个。 

```java
public static void bubbleSort(int arr[]) {
    // 比较相邻元素，所以不需要循环最后一个元素
    for(int i = 0;i<arr.length-1;i++){
        // 最后一个 已经有序（最大）
        for(int j = 0;j<arr.length-i-1;j++){
            if (arr[j] > arr[j+1]){
                int temp = arr[j];
                arr[j] = arr[j+1];
                arr[j+1] = temp;
            }
        }
    }
}

public static void bubbleSort(int arr[]) {
    // 比较相邻元素，所以不需要循环最后一个元素
        int[] arr = new int[]{7,6,3,2,1};
       //int[] arr = new int[]{1,4,3,5,8};
       boolean flag = true; // flag 用作标记是否需要排序
       for(int i = 0;i<arr.length-1 && flag;i++){
           flag = false;  // 初始化为 false
           for(int j = 0 ;j<arr.length-1-i;j++){
               if (arr[j] > arr[j+1]){
                   int temp = arr[j];
                   arr[j] = arr[j+1];
                   arr[j+1] = temp;
                   flag = true;
               }
           }
       }
}

```
N个数字要排序完成，总共进行N-1趟排序，每i趟的排序次数为(N-i)次,外层控制循环多少趟，内层控制每一趟的循环次数。

冒泡排序的优点：每进行一趟排序，就会少比较一次，因为每进行一趟排序都会找出一个较大值。

如上例：第一趟比较之后，排在最后的一个数一定是最大的一个数，第二趟排序的时候，只需要比较除了最后一个数以外的其他的数，
同样也能找出一个最大的数排在参与第二趟比较的数后面，
第三趟比较的时候，只需要比较除了最后两个数以外的其他的数，
以此类推……也就是说，每进行一趟比较，每一趟少比较一次，。

冒泡排序的效率：  
其执行步骤包含比较和交换，对于N个元素，需要`(N-1)+(N-2)+(N-3)+···+1`次比较；3*((N-1)+(N-2)+(N-3)+···+1)次交换

时间复杂度：O(n²) 

1. 如果数据正序，只需要走一趟即可完成排序【需要设置一个flag方可实现】。所需的比较次数C和记录移动次数M均达到最小值，即：Cmin=n-1;Mmin=0;所以，冒泡排序最好的时间复杂度为O(n)。
2. 如果数据是反序的，则需要进行n-1趟排序。每趟排序要进行n-i次比较(1≤i≤n-1)，且每次比较都必须移动记录三次来达到交换记录位置。在这种情况下，比较和移动次数均达到最大值：
即：Cmax=(N-1)+(N-2)+(N-3)+···+1; Mmax=3*((N-1)+(N-2)+(N-3)+···+1);

冒泡排序就是把小的元素往前调或者把大的元素往后调。比较是相邻的两个元素比较，交换也发生在这两个元素之间。所以，如果两个元素相等，是不会再交换的；
如果两个相等的元素没有相邻，那么即使通过前面的两两交换把两个相邻起来，这时候也不会交换，所以相同元素的前后顺序并没有改变，所以冒泡排序是一种稳定排序算法。

##### 选择排序
第一次从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，
然后再从剩余的未排序元素中寻找到最小（大）元素，然后放到已排序的序列的末尾。
以此类推，直到全部待排序的数据元素的个数为零。

```java
public static void selectionSort(int arr[]) {
    // 需要比较的次数，数组长度减一
    for (int i = 0; i < arr.length-1; i++) {
        int lowestIndex = i; // 先假设每次循环时，最小数的索引为i
        for (int j = i+1; j < arr.length; j++) {
            if (arr[j] <arr[lowestIndex]){
                // 寻找最小数
                lowestIndex = j;
            }
        }
        if (i != lowestIndex){
            // 找到最小值，放到开始的位置，第一个位置的数字已经是有序了
            int temp = arr[i];
            arr[i] = arr[lowestIndex];
            arr[lowestIndex] = temp;
        }
    }
    System.out.println();
    for (int count : arr){
        System.out.print(count);
    }
}
```

选择排序的效率：  O(n²/2) = O(n²)
其执行步骤包含比较和交换，对于N个元素，需要`(N-1)+(N-2)+(N-3)+···+1`次比较；但是每轮交换最多只需要一次。
选择排序的步数大概只有冒泡排序的一半，但是其大O记法和冒泡排序是一样的O(n²)，大O记法常数。

稳定性：

如果一个元素比当前元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。
举个例子，序列5 8 5 2 9，我们知道第一遍选择第1个元素5会和2交换，那么原序列中两个5的相对前后顺序就被破坏了，所以选择排序是一个不稳定的排序算法。

##### 插入排序
外层循环对除了第一个元素之外的所有元素，内层循环对当前元素前面有序表进行待插入位置查找，并进行移动；
即从第二个元素开始，和其左侧的数据比较（其左侧可以看做是已有序的元素）。

```java
public static void insertSort(int arr[]) {
    for (int i = 1; i < arr.length; i++) {
        for(int j = i;j>0 && arr[j-1]>arr[j];j--){ // 对比左侧列表,如果j-1 > j 则交换位置
            int temp = arr[j];
            arr[j] = arr[j-1];
            arr[j-1] = temp;
        }
    }
    System.out.println();
    for (int count : arr){
        System.out.print(count);
    }
}
```
插入排序的效率：  
其执行步骤包含移除，比较，平移和交换，对于N个元素，需要`n²/2`次比较；需要`n²/2`次平移，N-1次移除，N-1次插入，插入排序和冒泡，选择一样，时间复杂度都是O(n²)
实际上最坏的情况下，选择排序需要的步数是n²/2步，冒泡排序是n²步，插入排序n²+2N-2步

插入排序再不同场景下差异较大；最坏，平均，最好的情况下，分别是n²，n²/2，N步。

选择排序无论何种情况下，都是n²/2步。


时间复杂度：

在插入排序中，当待排序数组是有序时，是最优的情况，只需当前数跟前一个数比较一下就可以了，这时一共需要比较N- 1次，时间复杂度为O(n)；

最坏的情况是待排序数组是逆序的，此时需要比较次数最多，总次数记为：1+2+3+…+N-1，所以，插入排序最坏情况下的时间复杂度为 O(n²)；

稳定性分析：

如果待排序的序列中存在两个或两个以上具有相同关键词的数据，排序后这些数据的相对次序保持不变，即它们的位置保持不变，通俗地讲，就是两个相同的数的相对顺序不会发生改变，则该算法是稳定的；如果排序后，数据的相对次序发生了变化，则该算法是不稳定的。关键词相同的数据元素将保持原有位置不变，所以该算法是稳定的


哪种算法更好？

对于平均情况（数组里随机分配），选择和插入排序性能相近，如果数组大致有序，那么插入比较好，如果数组大致倒序，那么选择排序较好，无法判断数据的什么样，就选平均情况，都可以选择。

常用的二分查找算法需要用数组来存储数据，如果使用链表来存储，就无法使用二分查找法，因为链表不支持随机访问。




合理的思考路径或者说思考方向，

对一组数据排序，
回答点
1. 这组数据有什么特征？
有没有包含大量的重复元素？
如果是，3路归并排序是更好的选择,如果可以肯定数据中所有元素都是普通的，那么普通的快速排更好。
很多语言的排序接口，基本都是3路归并排序。
2. 是否大部分数据距离他正确的位置很近？是否几乎有序？
比如数据的时间排序，可以看作是几乎有序？ 可能插入排序是更好的。
3. 数据的取值范围是否有限？比如学生成绩 （0-100分)
这种情况下，或许计数排序是更好的选择

4. 对排序的是否有额外的要求？
 是否需要满足稳定性？ 如果是，快速排序不是一个更好的选择，而归并排序是更好的选择

5。 数据的存储状况是什么样的？
快速排序非常依赖数据的随机存储的，然后是使用链表存储的？那么归并排序是更好的选择。
数据有多少?是否可以装载在内存中？如果数据量很大或者条件较小，即不能全放内存中，需要使用外排序算法。




