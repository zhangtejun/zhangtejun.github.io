---
layout: post
title:  "Css 布局!"
date:   2017-05-21 10:25:39 +0800
author: zhang
categories: zhang
---

算法的定义：算法是解决特定问题求解步骤的描述，在计算机中为指令的有限序列，并且每条指令表示一个或多个操作。
 
 算法的特性：有穷性，确定性，可行性，输入，输出.
	
算法设计的要求：正确性，可读性，健壮性，高效率和低存储量的需求。
	
函数的渐进增长：给定2个函数f(n)和g(0),如果存在一个整数N，使得对于所有的n>N，f(n)总是比g(n)大,
那么我们就说f(n)的增长渐近快于g(n)。
#### 算法时间复杂度定义
在进行算法分析时，语句总的执行次数T(n)是关于问题规模n的函数，进而分析T(n)随n的变化情况并确定T(n)的数量级。
算法的时间复杂度，也就是算法的时间复杂度，记作：T(0)=O(f(n))。它表示随问题规模n的增大，算法执行时间的增长率和f(n)的增长率相同，
称作算法的渐进时间复杂度，简称为时间复杂度。
其中f(n)是问题规模n的某个函数。

这样用写大O()来体现的时间复杂度的记法，我们称之为大O记法。

一般情况下，随n增大，T(0)增长最慢的算法为最优算法。

显然由时间复杂度的定义可知，算法的时间复杂度分别为O(1),O(n),O(n²)，
用非官方的名称来叫它们，O(1)常数阶，O(n)线性阶，O(n²)平方阶，当然还有一些其他的阶。
#### 推导大O阶的方法
1. 用常数1取代运行时间中所有的加法常数。
2. 在修改后的运行次数函数中，只保留最高阶项。
3. 如果最高阶项存在且不是1，则去除与这个项相乘的常熟。
4. 得到的结果就是大O阶。
常用的时间复杂度所耗费的时间从小到大依次是：
O(1)<O(logn)<O(n)<O(nlogn)<O(n²)<O(n³)<O(2^n)<O(n!)<O(n^n)
#### 算法的空间复杂度
通过计算算法所需的存储空间实现，算法的空间复杂度的计算公式：S(n)=O(f(n)),其中n为问题的规模，
f(n)为语句关于n所占存储空间的函数。

### 树(Tree)
##### 树是n(n>>0)个结点的有限集。n=0时称为空树。
在任意一棵非空树中：(1)有且仅有一个特定的称为根(Root)的结点；(2)当n>1时，其余结点可分为m(m>0)个
互不相交的有限集T1,T2,...,Tm,其中每个集合本身又是一棵树，并且称为根的子树(SubTree)。

结点拥有子树数称为结点的度(degree)。树的度是树内各结点的度的最大值。

### 二叉树 Binary Tree
在计算机科学中，二叉树是每个结点最多有两个子树的有序树。
通常子树的根被称作“左子树”（left subtree）和“右子树”（right subtree）。

左/右斜树：所有结点都只有左/右子树的二叉树。

满二叉树：所有结点都有左右子树，并且所有叶子都在同一层上。

完全二叉树：对一棵右n个结点的二叉树按层序编号，
如果编号为i(0<=i<=n)的结点于同样深度的满二叉树中编号为i的结点在二叉树中的位置完全相同，则这棵二叉树称为完全二叉树。
