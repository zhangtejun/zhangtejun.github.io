---
layout: post
title:  "MYSQL"
date:   2019-05-19 08:53:16
author: zhangtejun
categories: sql
---
##### 安装
使用apt-get安装MySQL,中途会让输入root密码。
```
apt-get install mysql-server
```
##### 基本操作
开启MySQL服务
```
ervice mysql start
```
关闭服务
```
service mysql stop
```
重启服务
```
service mysql restart
```

##### 登陆连接
```
mysql -u root -p zhtjun1234.
```
* 登陆成功后，新建用户
   ```
    CREATE USER 'username'@'%' IDENTIFIED BY 'password';
   ```
*  为该用户分配权限
   ```
    GRANT ALL PRIVILEGES ON *.* TO 'username'@'%';
   ```
*  刷新
   ```
   FLUSH PRIVILEGES;
   ```
MYSQL可以查看数据库实例启动时加载的配置
```bash
root@10-9-53-220:~# mysql --help | grep my.cnf
                      order of preference, my.cnf, $MYSQL_TCP_PORT,
/etc/my.cnf /etc/mysql/my.cnf /usr/etc/my.cnf ~/.my.cnf
```
MYSQL按`/etc/my.cnf -> /etc/mysql/my.cnf -> /usr/etc/my.cnf -> ~/.my.cnf`的顺序读取配置，如果多个文件有相同参数，已最后一个读取为准。

查看数据库所在路径datadir
```bash
mysql> show variables like 'datadir'\G
*************************** 1. row ***************************
Variable_name: datadir
        Value: /var/lib/mysql/
1 row in set (0.00 sec)
```
MySQL由以下几部分组成：
* 连接池组件
* 管理服务和工具组件
* SQL接口组件
* 查询分析器组件
* 优化器组件
* 缓冲（Cache）组件e
* 插件式存储引擎
* 物理文件

InnoDB存储引擎是多线程模型，后台有不同的线程，负责处理不同的业务。
* Master Thread：负责将缓冲池中的数据异步刷新到磁盘，保证数据的一致性，包括脏页的刷新，合并插入缓冲，UNDO页的回收等。
* IO Thread：在InnoDB存储引擎中大量使用AIO(Async IO)来处理写IO请求，可以提高数据库性能。而IO Thread主要负责这些IO请求的回调处理。
* Purge Thread：事务提交后，其所使用的undolog可能不再需要，需要Purge Thread来回收已经使用并分配的undo页。

内存
* 缓冲池：InnoDB存储引擎是基于磁盘存储的，并将其所有的记录按照页的方式进行管理。由于CPU和磁盘速度之间的鸿沟，基于磁盘的数据库系统使用缓冲池
  技术来提高数据库的整体性能。缓冲池简单来说就是一块内存区域，通过内存来弥补磁盘速度较慢对数据库的影响。

  在数据库中进行读取页的操作，首先将从磁盘读到的页放在缓冲池中，这个过程称为将页”FIX“在缓冲池中。下次读取相同页的时候，首先判断是否子啊缓冲池中，
  若在，则称该页缓冲池命中，直接读取该页。否则读取磁盘上的页。对数据库中页的修改操作，则首先修改缓冲池中的页，然后以一定的频率刷新到磁盘。不是在每次页发送更新触发
  ，而是同过一种Checkpoint的机制刷新回磁盘。

  综上，缓冲池的大小直接影响数据库的整体性能。对于innodb引擎来说可以通过参数(innodb_buffer_pool_size)来设置缓冲池大小
  ```bash
  mysql> show variables like 'innodb_buffer_pool_size'\G
  *************************** 1. row ***************************
  Variable_name: innodb_buffer_pool_size
          Value: 134217728
  1 row in set (0.00 sec)
  ```

具体来看，缓冲池中缓存的数据页类型有：索引页，数据页，undo页，插入缓存，自适应哈希索引，Innodb存储的锁信息，数据字典信息等。

缓冲池如何管理？
一般来说，数据库的缓冲池是通过LRU(latest Recent Used,最近最少使用)算法来进行管理的。即频繁使用的页在LRU列表的最前端，而最少使用的在LRU列表的尾端
。当缓冲池不能存放新读取到的页时，将首先释放LRU列表中尾端的页。

在Innodb存储引擎中，缓冲池的页大小默认是16KB,同样使用LRU算法对缓冲池进行管理。稍有不同的是，Innodb存储引擎对传统的LRU算法做了优化，在LRU列表中加入了midpoint
位置，新读取到的页，虽然是最新访问的页，但并不直接放入列表首部，而是放到midpoint位置，默认配置下，该位置在LRU列表的5/8处。
```
mysql> show variables like 'innodb_old_blocks_pct'\G
*************************** 1. row ***************************
Variable_name: innodb_old_blocks_pct
        Value: 37
1 row in set (0.00 sec)
```
表示新读取的页插入到LRU列表尾端的37%的位置，在Innodb存储引擎中,把midpoint之后的页称为old列表，之前的称为new列表。

为什么要采用这种方法？
这是因为若直接将读取到的页放入到LRU的首部，那么某些SQL操作可能会使缓冲池中的页被刷新出，从而影响缓冲池的效率。常见的这类操作为索引或数据的扫描操作。
这类操作需要访问表中的许多页，甚至是全部的页，而这些页通常来说又仅在这次查询操作中需要，并不是活跃的热点数据。如果页被放入LRU列表的首部，那么非常可
能将所需要的热点数据页从LRU列表中移除，而在下一次需要读取该页时，InnoDB存储引擎需要再次访问磁盘。

为了解决这个问题，InnoDB存储引擎引入了另一个参数来进一步管理LRU列表，这个参数是innodb_old_blocks_time，用于表示页读取到mid位置后需要等待多久才会被加
入到LRU列表的热端。因此当需要执行上述所说的sql操作时，可以通过以下方法尽可能保证LRU热点数据不被刷出。如果用户预估自己的热点数据不止63%，那么在执行sql前
还可以通过减少midpoint位置的位置来减少被刷出的概率。

数据库刚启动的时候，LRU 列表为空，此时需要用到的时候直接将Free列表中的页删除，在LRU列表中增加相应的页，维持页数守恒。

InnoDB存储引擎从1.0.x版本开始支持压缩页选项，即将原本16KB的页压缩为1K,2k,4k和8KB。由于页的大小改变，LRU列表也有许多改变，对于非16Kb的页，
是通过unzip_LRU列表进行管理的。

unzip_LRU是怎样从缓冲池中分配内存的呢？
首先，在unzip_LRU列表中对不同压缩页大小的页进行分别管理。其次，通过伙伴算法进行内存的分配。例如对需要从缓冲池中申请页为4KB的大小，其过程如下：
* 1）检查4KB的unzip_LRU列表，检查是否有可用的空闲页；
* 2）若有，则直接使用；
* 3）否则，检查8KB的unzip_LRU列表；
* 4）若能够得到空闲页，将页分成2个4KB页，存放到4KB的unzip_LRU列表；
* 5）若不能得到空闲页，从LRU列表中申请一个16KB的页，将页分为1个8KB的页、2个4KB的页，分别存放到对应的unzip_LRU列表中。

在LRU列表中的页被修改后，称该页为脏页，即缓冲池中的页和磁盘上的页的数据产生了不一致。这时数据库会通过checkpoint机制将脏页刷新回磁盘，而Flush列表中的页即
为脏页列表。LRU列表用来管理缓冲池中页的可用性，Flush列表用来管理将页刷新回磁盘，二者互不影响。

**重做日志缓冲**
InnoDB存储引擎的内存区域除了有缓冲池外，还有重做日志缓存。首先将重做日志信息先放到这个缓冲区，然后按一定的频率将其刷新到重做日志文件。
默认为8M,由参数innodb_log_buffer_size控制。

在通常情况下，8MB的重做日志缓冲池足以满足绝大部分的应用，因为重做日志在下列三种情况下会将重做日志缓冲中的内容刷新到外部磁盘的重做日志文件中。
* Master Thread每一秒将重做日志缓冲刷新到重做日志文件；
* 每个事务提交时会将重做日志缓冲刷新到重做日志文件；
* 当重做日志缓冲池剩余空间小于1/2时，重做日志缓冲刷新到重做日志文件。

**额外的内存池**
在InnoDB存储引擎中，对内存的管理是通过一种称为 内存堆 的方式进行的。在对一些数据结构本身的内存进行分配时，需要从额外的内存池中进行申请，当该区域的内存不够时，
会从缓冲池中进行申请。例如，分配了缓冲池（innodb_buffer_pool），但是每个缓冲池中的帧缓冲（frame buffer）还有对应的缓冲控制对象（buffer control block），这些对
象记录了一些诸如LRU、锁、等待等信息，而这个对象的内存需要从额外内存池中申请。因此，在申请了很大的InnoDB缓冲池时，也应考虑相应地增加这个值。


**checkpoint**
缓冲池的设计目的为了协调CPU速度与磁盘速度的鸿沟。因此页的操作首先都是在缓冲池中完成的。如果一条DML语句，如Update或Delete改变了页中的记录，那么此时页是脏的，
即缓冲池中的页的版本要比磁盘的新。数据库需要将新版本的页从缓冲池刷新到磁盘。

倘若每次一个页发生变化，就将新页的版本刷新到磁盘，那么这个开销是非常大的。若热点数据集中在某几个页中，那么数据库的性能将变得非常差。同时，如果在从缓冲池将页
的新版本刷新到磁盘时发生了宕机，那么数据就不能恢复了。为了避免发生数据丢失的问题，当前事务数据库系统普遍都采用了Write Ahead Log策略，即当事务提交时，先写重做
日志，再修改页。当由于发生宕机而导致数据丢失时，通过重做日志来完成数据的恢复。这也是事务ACID中D（Durability持久性）的要求。

因此Checkpoint（检查点）技术的目的是解决以下几个问题：
* 缩短数据库的恢复时间；
* 缓冲池不够用时，将脏页刷新到磁盘；
* 重做日志不可用时，刷新脏页。
当数据库发生宕机时，数据库不需要重做所有的日志，因为Checkpoint之前的页都已经刷新回磁盘。故数据库只需对Checkpoint后的重做日志进行恢复。这样就大大缩短了恢复的时间。
此外，当缓冲池不够用时，根据LRU算法会溢出最近最少使用的页，若此页为脏页，那么需要强制执行Checkpoint，将脏页也就是页的新版本刷回磁盘。

在Innodb中有2种checkpoint
* sharp checkpoint 发生在数据库关闭时将所有脏页都刷新回磁盘，这是默认的工作方式。
* fuzzy checkpoint 指刷新一部分脏页，不一次性刷新所有脏页。


##### Innodb 数据页结构
页是Innodb存储引擎管理数据库的最小磁盘单位。页类型为B-tree Node 的页存放的即是表中行的实际数据。

InnoDB数据页由以下7个部分组成
* File Header（文件头）
* Page Header（页头）
* Infimun和Supremum Records
* User Records（用户记录，即行记录）
* Free Space（空闲空间）
* Page Directory（页目录）
* File Trailer（文件结尾信息）

select 0=0   =>1

select 0='a'  (不能转数字 就转成0)=>1

字符转数字

触发器的作用是在执行INSERT、DELETE和UPDATE命令之前或之后自动调用SQL命令或存储过程。MySQL 5.0对触发器的实现还不是非常完善，限制比较多，
而从MySQL 5.1开始触发器已经相对稳定，功能也较之前有了大幅的提高。创建触发器的命令是CREATE TRIGGER，只有具备Super权限的MySQL数据库用户
才可以执行这条命令。

最多可以为一个表建立6个触发器，即分别为INSERT、UPDATE、DELETE的BEFORE和AFTER各定义一个。BEFORE和AFTER代表触发器发生的时间，表示是在每
行操作的之前发生还是之后发生。当前MySQL数据库只支持FOR EACH ROW的触发方式，即按每行记录进行触发，不支持像DB2的FOR EACH STATEMENT的触发方式。

#### 索引
InnoDB存储引擎支持以下几种常见的索引：
* B+树索引
  非叶子结点不存在数据，只存索引。 一次性I/o 16kb，也是叶节点的大小。 16kb /(8+6)b = 1170  即一个结点放满时的索引个数。8+6 索引加指针
  mysql 根节点常驻内存，2次磁盘I/O即可（树高度为3）
* 全文索引
* 哈希索引
InnoDB存储引擎支持的哈希索引是自适应的，InnoDB存储引擎会根据表的使用情况自动为表生成哈希索引，不能人为干预是否在一张表中生成哈希索引。

B+树索引就是传统意义上的索引，这是目前关系型数据库系统中查找最为常用和最为有效的索引。B+树索引的构造类似于二叉树，根据键值（Key Value）快速找到数据。

B+树索引并不能找到一个给定键值的具体行。B+树索引能找到的只是被查找数据行所在的页。然后数据库通过把页读入到内存，再在内存中进行查找，最后得到要查找的数据。

每页Page Directory 中的槽是按主键顺序存放的，对于具体记录的查询是通过对Page Directory 进行二分查找得到的。


查看表中索引信息`show index from table_a`
* Table 索引所在表面。
* Non_unique 非唯一的索引， primary key 是 0 ，因此必须唯一。
* Key_name 索引的名字，可以通过这个名字来执行 DROP INDEX key_name ON table_name。
* Column_name 索引列的名称。
* Collation 列以什么方式存储在索引中。可以是A或NULL。B+树索引总是A，排序的。如果使用Head存储引擎，并且建立了Hash索引，这里就是NULL,Hash根据Hash桶存放，不排序。
* Cardinality  很重要的一个值，表示索引中唯一值的数目的估计值。如果表中的行数接近1，如果非常小，那么用户需要考虑是否可以删除此索引。
* Sub_part 是否是列的部分索引。如果这里显示100，表示只对b列的前100字符进行索引。如果索引整个列，则该字段为NULL。
* Packed 关键字如何被压缩。没有压缩就是NULL。
* Null 是否索引的列含有NULL值。
* Index_type 索引的类型。
* Comment 注释

Cardinality值非常关键，优化器会根据职工值来判断是否使用这个索引。但是这个值不是实时更新的，即不是每次索引更新都会更新这个值，因为这样代价太大。
所以这个值不太准确，只是一个估计值，可以使用analyze table table_name来更新这个值。

* 红黑树在数据量大的情况下，树的高度太高，作为索引查询效率也低。 横向扩容  B树
B+树在相邻的叶子结点维护一个双向指针（B树的区别在这）





##### 索引
如果让你存储索引？怎么设计？
索引是否是一个文件？ 是
索引是否需要持久化？ 是

检索某个key,需要知道
key(键)，fileName（位于哪个文件），offsets（文件中的偏移量）。 存在的弊端，扫描太慢。耗费内存空间

OLAP：联机分析处理，对历史数据的分析，产生决策影响。需要将数据都读到内存中处理。
OLTP：联机事务处理，必须要在很短的时间内反馈结果。

只是用来存储数据，可以用的数据结构很多：
hash表：插入数据时，先计算当前key的hash值，会被分配到某一个地址上，如果重复，往其上的链表上增加，查询也是一样，数据存储不均匀，
        会造成存储空间浪费，要设计一个优秀的hash算法，保证数据尽可能多的散列；在继续hash表存储时，需要把整个hash表加载到内存，
        需要占用很多的内存空间，耗费内存。查找某一个key,可以快速找到，这是等值查询，如果是范围查询，只能遍历整个hash表，这时是非常慢的。
        适合等值查询，不适合范围查询。

mysql 中是否有hash索引？
索引是和对应的存储引擎相关的，memory使用hash索引；innodb这种存储引擎支持自适应hash。

二叉树：树的每个分支都只有2个节点

BST：插入数据时自动排序，每个节点的值大于其任意左侧子节点的值，小于其任意右节点的值。
     查找时可以使用二分查找，

如果这棵树是递增或者递减的序列，会慢慢的由一棵二叉树退化成链表，链表 On的时间复杂度，
绝决方案，插入的时候能不能尽可能多的保证这棵树的平衡，在次基础上有了 AVL二叉平衡树，插入时会自动旋转，
旋转是插入、删除时进行的，AVL 损失了一部分插入的性能来满足查询的性能提升。
查询和插入是差不多的情况下，不能满足。 绝决方法 红黑树，插入和查询的性能尽可能的得到平衡。

红黑树：
AVL二叉平衡树：
B树：

为什么索引不用这3种数据结构？
最大的问题是 每个节点有且仅存了一个值的数据，如果要保证插入更多的数据，只能加深树的深度，佳森树的深度，会产生什么影响？
读取数据到底是怎么读取的？实际就是IO问题。要提高IO效率，只能从硬件上改，很难控制，所以只能通过程序来控制，
1.尽量减少IO的次数，2. 尽量减少IO的的量，读一次和10次，读1M和100M肯定是不一样的。
磁盘和内存在交互时，1. 局部性原理： 经常被查询的数据有聚集成群的倾向，同时刚被查询的数据，有可能很快会被再次查询；
2. 磁盘预读，如果我们需要一个字符a,我们是真的只取一个字符a吗？肯定不是。
磁盘和内存进行交互的最小逻辑单位，一般都是和操作系统相关的，是4k或8k。 可以称为datapage或者叫页。

每个节点里能不能多存储几条数据？可以，不管红黑树。BST,AVL 都会变成树的深度变深，为什么变深？因为其中一个节点有且只有2个
分支，能不能变成多个分支，或者说N个分支， 即B树。如果是4阶，每个结点最多存3个数据。树的深度随着插入的元素逐渐变多，
能不能控制每个节点都是4kB，那么每个节点存储的数据就比较多了，对应到mysql 一个结点中不止放一个key值，还可以存放更多的信息，

每次数据读取时，可以是4k,8k,一般情况下都是4kb的整数倍，innodb每次读取数据时，读取16kb,

在3层B树中，如果查找一个数据，进行3次IO,共16k x 3 = 48kB, 支持多少数据量的查询？ 比如一行记录1kb,
假如可以存在16条记录，指向16个范围，即16 x 16 x 16 = 4096 条数据。合理吗？不合理，表里数据量肯定不止4k条，就会
加深树的深度，就会带了磁盘IO的次数，如何调整？？？ 存储数据量少的根本原因在哪？哪里占用了很多的额外存储空间，
是节点中的data记录，能不能把data去掉，不占用。即B+树， 和B树最大的区别？B+树，只有叶子节点存数据，有些key的值是重复的（主要）。
实际存储时，非叶子节点不存储实际的数据（data）,这种方式的好处？？？  叶子节点 一个节点中可以存放16条数据（假设一行记录为1k）,
在3层B+树中,加入指针和key 占用10字节，16kB / 10 字节 =  1600 个范围。支持多少数据量的查询？  1600 x 1600 x 16 = 40960000 （4千万数据量）
每次进行数据检索时，依然只读取48k数据。

建索引时，到底应该给哪些字段建立索引？？  整型，字符串，日期，哪种数据类型？  整型，因为我们再进行数据插入的时候，key占用的空间越小，意味着每个磁盘块划分的范围越大，
范围越大意味着 固定层数的B+树，可存放的数据越多，所以是越小越好。

注： 在B+树中，有2个头指针，一个指向根节点，另一个指向关键字最小的叶子节点，而且所有的叶子节点之间是一种双向链式结构，
因此在B+树中，有2种查找运算，一种是对于主键的范围查找和分页查找，另一种从根节点开始，进行随机查找。

一般情况下mysql的索引B+树是几层？？？  千万级别的数据量，一般情况下3层到4层就可以满足，具体情况下还需要看每个key值得大小。 key越小存放得数据越多。

一般情况最好是3层，如果是4层，相对于3层来说，加一个16kb(4层),对整体影响大，数据库得查询 不是一个人在操作，是N个，每个请求多一个16K,。

刚建好一张表，第一次插入数据，B+树是几层？？？   数据只能存储到叶子节点，索引只能存在非叶子节点，所有是2层。 
插入数据在叶子节点，是会影响B+树得树高的。  为什么？ 索引维护？？ 主键要不要设置成自增？？？   尽量保持自增，自增时的好处，再插入数据时，只需要在叶子节点增加数据，非叶子节点不需要
改变， 如果不是递增，往中间某一个节点增加数据， 比如一个磁盘块最多放4条记录，并且当前磁盘块已满，再插入时，这个块就需要分裂，从一个块变成2个磁盘块，
该叶子节点有指针指向该节点，那么非叶子节点，也需要随着修改（分裂等），这个维护的成本很高。


存储引擎，innoDb 和MyISAM 都是B+树。
什么是存储引擎？  不同的存储引擎表示的是不同的文件在 我们的磁盘上的不同的组织形式。  在mysql安装的data目录中可以查看到， tablename.frm（表结构） 或者.ibd （数据和索引存储数据文件）
当看到是ibd，就说明这张表是innodb存储引擎，聚簇索引。
如果是 tablename.frm,tablename.MYI（索引文件）,tablename.MYD（数据文件）,说明索引文件和数据文件是分开的。即在磁盘上的不同的组织形式。

事物？
innoDb 支持；MyISAM不支持

锁
MyISAM 只支持表锁；innoDb支持表锁和行锁。

外键
innoDb 支持；MyISAM不支持

全文索引
老版本innoDb 不支持， 后面的版本都支持了（5.6）

log 
都支持的log是binlog
undolog  innoDb 支持；MyISAM不支持

5.5 之后都是默认innoDb存储引擎。


InnoDB 引擎，非叶子节点存储的是key, 叶子节点存储的整行的行记录；MyISAM 叶子节点存储的是地址（行记录所在的地址）， InnoDB就一个ibd文件。MyISAM索引文件和数据文件是分开的。

进行数据插入时，是否必须包含一个key值？？？  是 ，没有key 就没法存数据，这个key可能是主键，也可能是唯一键，也可能是row_id。

一个表里可以有多少个索引？？？ 
一般来说索引的数量是没有限制的，InnoDB的索引是和数据绑定再一起的，如果有5个索引，那就有5种key, 每个索引都和数据绑定再一起吗？？？ 不是， 会导致冗余太多。
数据和索引是不是一起存放的,如果是就是聚簇索引，如果不是就是非聚簇索引。 如果一个表有主键，那么就是聚簇索引。 聚簇索引 一定是主键索引吗？ 不一定，因为没有主键可以选择唯一键，没有唯一键可以是row_id。

InnoDB是否一定包含一个聚簇索引？ 是

MyISAM包含聚簇索引吗？？ 不包含

表  id（主键）  name 

给name加上索引，再叶子节点中存储的是什么？ 存储的是id这列的值，即聚簇索引的key值，
即name 列是非聚簇索引，因为数据和索引不是一起存放的。

一句话表示：
聚簇索引： 数据和索引是一起存放的，聚簇索引的key可以是主键，唯一键，rowid,如果一个表的普通列创建了索引，那么叶子节点中存储的是聚簇索引的key值。

表  id（主键）  name （普通索引） age 

select * from table where name ='zhang'

进行数据检索时，应该怎么检索，先根据name 去name所在B+树找到name=zhang,可以得到相应的id值(1)。 再通过id=1,去主键索引里得到相应的数据，共查询了2次B+树，
这个过程就叫回表，回的是聚簇索引的那张表。

InnoDB对主键创建索引，然后叶子节点中存储记录，如果没有主键，那么会选择唯一键，如果没有唯一键，那么会生成一个6字节的row_id来作为主键。（6字节够存吗？ 够，int占4个字节，正负21亿，表李的数据一般不会超过21亿）
如果创建索引的字段是其他字段，那么叶子节点存储的是该记录的主键，然后再通过主键索引找到对应的记录，叫回表。

select id from table where name ='zhang'
进行数据检索时，应该怎么检索，先根据name 去name所在B+树找到name=zhang,可以得到相应的id值(1)。还不继续回表查询吗？？？ 不用，  不需要回表时叫覆盖索引。

回表无形之中回增加成本。

如果字段长度非常长，可以使用hash进行截取，目的是减少存储空间，尽可能多的存储数据。

组合索引（最左匹配）：
where name= ？ and age = ？  ，建立组合索引（name,age）,
最左匹配原则，先匹配name,再匹配age,

索引下推：
select * from table where name =？ and age = ?

数据存储再存储引擎中，server负责数据的筛选，
没有索引下推的情况下，先根据name的值从存储引擎中把所有符合条件的记录都滤出来，过滤完后再server层对age进行筛选；   存储引擎做name筛选，执行器做age筛选。
有索引下推：直接根据name和age的值从存储引擎中过滤出来，不需要server层做任何处理。

减少了server和存储引擎之间的IO量。

5.7版本是默认开启的（optimizer_switch='index_condition_pushdown=off'）

8.1 去掉了查询缓存，命中率太低

索引是有顺序的，如果索引上信息已经满足了我们的需求，那么就不需要使用filsort了。
索引排序，不需要额外的内存，表空间，缓存，文件来进行排序。 fileSort 必然要借助外部文件系统进行排序。



mysql 索引 相关技术名词：
* 回表
* 索引覆盖
* 最左匹配
* 索引下推


























































































