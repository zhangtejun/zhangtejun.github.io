---
layout: post
title:  "dubbo"
date:   2019-08-29 14:12:23
author: zhangtejun
categories: Java
---
##### 代理模式
普通对象可以通过公共接口来完成自己需要的工作，然而有些对象却由于部分原因无法履行自己的职责。比如有的对象加载时间长，
有些对象运行在其他计算机上，有些对象需要先拦截发送到对象的信息等，这些情况下可以引入代理对象，通过代理对象来承担客户需要的职责，
并将相应的请求转发给底层目标对象。

代理对象通常有一个几乎和目标对象相同的接口，它常常控制访问，并将请求合理的转发给底层目标对象。

**远程代理**
需要调用的对象方法在其他机器上运行，不能直接调用，可以在远程机器上打开一socket套接字，并设计出一些协议来与远程对象进行消息传递。

理想情况下，这种方法可以像在你本地一样传输消息。可以调用代理对象的方法，将镇上对象的调用转发给远程机器。比如CORBA，RMI等已实现这张方式。

远程过程调用（Remote Procedure Call, RPC）可以用于一个进程调用另一个进程（很可能在另一个远程主机上）中的过程，从而提供了过程的分布能力。
Java 的 RMI 则在 RPC 的基础上向前又迈进了一步，即提供分布式对象间的通讯。
RMI（Remote Method Invocation）为远程方法调用，是允许运行在一个Java虚拟机的对象调用运行在另一个Java虚拟机上的对象的方法。

RMI目前使用Java远程消息交换协议 JRMP（Java Remote Messaging Protocol ）进行通信。

RMI的 用途是为分布式Java应用程序之间的远程通信提供服务，提供分布式服务。

Remote interface：是一个不定义方法的标记接口，在RMI中，远程接口声明了可以从远程Java虚拟机中调用的方法集。

LocateRegistry：final类用于获得特定主机的引导远程对象注册服务器程序的引用（即创建stub），或者创建能在特定端口接收调用的远程对象注册服务程序。
在服务端表现为向其他客户机提供远程对象服务。

RMISecurityManager：在RMI引用程序中，如果没有设置安全管理器，则只能从本地类路径加载stub和类，这可以确保应用程序不受由远程方法调用所下载的代码侵害。

在从远程主机下载代码之前必须执行以下代码来安装RMISecurityManager:
System.setSecurityManager(new RMISecurityManager())；
该类已被废弃,使用它的父类SecurityManager代替

Java RMI技术是伴随着分布式处理的需求而诞生出来，虽然从RMI的字面翻译没有看出来。
在这一点上DCOM（Distributed Object Component Model，分布式对象组件模型，RPC就是通过DCOM机制来实现）似乎表现得更直白一些。
分布式处理的构架就决定了无论是RMI还是RPC都至少是C/S模型，即Server作为对象（远程对象或者COM对象）提供者，而Client端作为使用者。

同样，RMI也像DCOM一样，Server端需要先注册服务，而Client端调用远程方法之前需要查找已经注册的服务，由此获得通信端口和传递参数等后续工作

不同的是，Java平台与生俱来的安全性和良好的扩展性就决定了Java RMI比RPC更加安全和灵活，例如Java RMI可以穿透防火墙，而DCOM机制则不能；
Java RMI可以支持嵌入更高级的连接应用，例如结合JNDI，XML技术等。


远程接口需满足下列要求：
1. 远程接口必须直接或间接扩展`Java.rmi.Remote`接口，且必须声明为public，除非客户端于远程接口在同一包中
2. 在远程接口中的方法在声明时，除了要抛出与应用程序有关的异常之外，还必须包括RemoteException（或它的超类，IOExcepion或Exception）异常
3. 在远程方法声明中，作为参数或返回值声明的远程对象必须声明为远程接口，而非该接口的实现类。

RemoteObject抽象类：实现了Remote接口和序列化Serializable接口，它和它的子类提供RMI服务器函数。

提供了创建远程对象并将其导出（也就是使他们能够被远程客户机所调用），所需的方法由类UnicastRemoteObject和Activatable提供。

Stub是客户端的代理，它实现了所有远程对象的接口；Skeleton是服务器端的实体，它包括了一个被具体远程对象所支持的接口。

在与远程对象的通信过程中，RMI 使用标准机制：stub 和skeleton 。
远程对象的stub 担当远程对象的客户本地代表或代理人角色。
调用程序将调用本地stub 的方法，而本地stub 将负责执行对远程对象的方法调用。

在RMI 中，远程对象的stub与该远程对象所实现的远程接口集相同。
调 用stub 的方法时将执行下列操作：
1. 初始化与包含远程对象的远程虚拟机的连接；
2. 对远程虚拟机的参数进行编组（写入并传输）；
3. 等待方法调用结果；
4. 解编（读取）返回值或返回的异常；
5. 将值返回给调用程序。

它在接收方法调用时执行下列操作:
1. 解编（读取）远程方法的参数；
2. 调用实际远程对象实现上的方法；
3. 将结果（返回值或异常）编组（写入并传输）给调用程序

##### 动态代理
动态代理依赖对象所实现的接口。接口中定义什么调用，代理就拦截什么调用。

为了创建动态代理，必须列出所要拦截的接口。
```java
// 获取所有接口
Class<?>[] classes = obj.getClass().getInterfaces();
// 类加载器和当代理拦截调用时，需要执行的行为类
ClassLoader loader = obj.getClass().getClassLoader();
// 最后一个元素是代理对象本身，这个对象必须实现invocationHandler接口，接口声明为：
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;
// 对包装对象的调用会转发给你所提供类的invoke()方法，该方法会将调用转发给被包装对象
result = m.invoke(obj, args);
// 在方法执行前后，对调用进行拦截，并创建增加行为的思想属于面向切面编（AOP）,在AOP中，切面就是所谓的“建议”（advic）和“切入点”的组合。

// **例子**
// 1. 定义了一个Subject类型的接口
public interface Subject
{
    public void doSomething();
}
// 2. 定义了一个类来实现这个接口，这个类就是我们的真实对象，RealSubject
public class RealSubject implements Subject
{
    @Override
    public void doSomething()
    {
        System.out.println("doSomething...");
    }
}
// 3. 定义一个动态代理类，需要实现invocationHandler接口
public class DynamicProxy implements InvocationHandler
{
    //　这个就是我们要代理的真实对象
    private Object subject;

    // 构造方法，给要代理的真实对象赋初值
    public DynamicProxy(Object subject)
    {
        this.subject = subject;
    }

    @Override
    public Object invoke(Object object, Method method, Object[] args)
            throws Throwable
    {
        //　在代理真实对象前我们可以添加一些自己的操作
        System.out.println("before invoke ...");

        // 当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用
        method.invoke(subject, args);

        //　在代理真实对象后我们也可以添加一些自己的操作
        System.out.println("after invoke ...");

        return null;
    }
}
// 4. 调用
// 4.1 要代理的真实对象
Subject realSubject = new RealSubject();//这里指定被代理类

// 4.2 要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法的
InvocationHandler handler = new DynamicProxy(realSubject);

/* 4.3
 * 通过Proxy的newProxyInstance方法来创建我们的代理对象
 * 第一个参数realSubject.getClass().getClassLoader()，我们这里使用代理类的类加载器，也就是被代理的那个真实对象
 * 第二个参数realSubject.getClass().getInterfaces()，我们这里为代理对象提供的接口是真实对象所实行的接口，表示我要代理的是该真实对象，这样我就能调用这组接口中的方法了
 * 第三个参数handler，我们这里将这个代理对象关联到了上方的InvocationHandler 这个对象上
 */
Subject subject = (Subject) Proxy.newProxyInstance(realSubject.getClass().getClassLoader(),
        realSubject.getClass().getInterfaces(), handler);
subject.doSomething();
```

JDK动态代理的入口是`Proxy.newProxyInstance(ClassLoader loader,Class<?>[] interfaces,InvocationHandler h)`这个静态方法。
参数分别是加载动态生成的代理类的类加载器，业务类实现的接口，InvocationHandler对象（需要开发人员开发）。
```java
public static Object newProxyInstance(ClassLoader loader,Class<?>[] interfaces,InvocationHandler h)throws IllegalArgumentException
    {
        Objects.requireNonNull(h);

        final Class<?>[] intfs = interfaces.clone();// clone接口类对象数组
        final SecurityManager sm = System.getSecurityManager(); // 权限检查
        if (sm != null) {
            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);
        }

        /*
         * Look up or generate the designated proxy class.
         */
        Class<?> cl = getProxyClass0(loader, intfs);// 查找或者是生成一个特定的代理类对象

        /*
         * Invoke its constructor with the designated invocation handler.
         */
        try {
            if (sm != null) {
                checkNewProxyPermission(Reflection.getCallerClass(), cl);
            }

            final Constructor<?> cons = cl.getConstructor(constructorParams);
            final InvocationHandler ih = h;
            if (!Modifier.isPublic(cl.getModifiers())) {
                AccessController.doPrivileged(new PrivilegedAction<Void>() {
                    public Void run() {
                        cons.setAccessible(true);
                        return null;
                    }
                });
            }
            return cons.newInstance(new Object[]{h});
        } catch (IllegalAccessException|InstantiationException e) {
            throw new InternalError(e.toString(), e);
        } catch (InvocationTargetException e) {
            Throwable t = e.getCause();
            if (t instanceof RuntimeException) {
                throw (RuntimeException) t;
            } else {
                throw new InternalError(t.toString(), t);
            }
        } catch (NoSuchMethodException e) {
            throw new InternalError(e.toString(), e);
        }
    }

//查找或者是生成一个特定的代理类对象
private static Class<?> getProxyClass0(ClassLoader loader,Class<?>... interfaces) {
        // length 是 int 类型
        if (interfaces.length > 65535) {// 接口数限制
            throw new IllegalArgumentException("interface limit exceeded");
        }

        // 如果在指定的类加载器中已经创建了实现指定接口的代理类，则查找缓存，
        // 否则通过ProxyClassFactory创建实现指定接口的代理类
        return proxyClassCache.get(loader, interfaces);
    }

public V get(K key, P parameter) {
    Objects.requireNonNull(parameter);
    expungeStaleEntries();// 删除过时的缓存
    // 将ClassLoader包装成CacheKey, 作为一级缓存的key
    // 生成缓存key对象实例，如果key = null，cacheKey = new Object();
    Object cacheKey = CacheKey.valueOf(key, refQueue);
    // lazily install the 2nd level valuesMap for the particular cacheKey
    // 从缓存map中读取指定cacheKey的缓存数据valuesMap，该值为二级缓存
    ConcurrentMap<Object, Supplier<V>> valuesMap = map.get(cacheKey);
    if (valuesMap == null) {
         // 以CAS方式put, 如果不存在则新建一个，否则返回原来的值
        ConcurrentMap<Object, Supplier<V>> oldValuesMap
            = map.putIfAbsent(cacheKey,valuesMap = new ConcurrentHashMap<>());
        // 如果 oldValuesMap 不为null，说明原来是有值的
        if (oldValuesMap != null) {
            valuesMap = oldValuesMap;
        }
    }
    // create subKey and retrieve the possible Supplier<V> stored by that
    // subKey from valuesMap
    // 根据代理类实现的接口数组来生成二级缓存key
    Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));
    // 这里通过subKey获取到二级缓存的值
    Supplier<V> supplier = valuesMap.get(subKey);
    Factory factory = null;

    while (true) {
        // 如果通过subKey取出来的值不为null
        if (supplier != null) {
            // supplier might be a Factory or a CacheValue<V> instance
            // 如果缓存里有supplier ，那就直接通过get方法，得到代理类对象，返回
            // supplier可能是一个Factory也可能会是一个CacheValue
            V value = supplier.get();
            if (value != null) {
                return value;
            }
        }
        // else no supplier in cache
        // or a supplier that returned null (could be a cleared CacheValue
        // or a Factory that wasn't successful in installing the CacheValue)

        // lazily construct a Factory
        // 如果缓存中没有supplier，则创建一个Factory对象，作为键subKey的值
        // 然后把factory对象在多线程的环境下安全的赋给supplier。
        // 赋值成功后，接着下一次循环开始，又回到上面去调get方法，返回才结束。
        if (factory == null) {
            factory = new Factory(key, parameter, subKey, valuesMap);
        }

        if (supplier == null) {
            // 就将factory作为subKey的值放入
            // putIfAbsent：如果传入key对应的value已经存在，就返回存在的value，不进行替换。如果不存在，就添加key和value，返回null
            supplier = valuesMap.putIfAbsent(subKey, factory);
            if (supplier == null) {
                // successfully installed Factory
                // 到这里表明成功将factory放入缓存
                supplier = factory;
            }
            // else retry with winning supplier
        } else {
            // 期间可能其他线程修改了值, 那么就将原先的值替换
            if (valuesMap.replace(subKey, supplier, factory)) {
                // successfully replaced
                // cleared CacheEntry / unsuccessful Factory
                // with our Factory
                // factory替换成功
                supplier = factory;
            } else {
                // 替换失败, 继续使用原先的值
                // retry with current supplier
                supplier = valuesMap.get(subKey);
            }
        }
    }
}

private final class Factory implements Supplier<V> {
    //一级缓存key, 根据ClassLoader生成
    private final K key;
    //代理类实现的接口数组
    private final P parameter;
    //二级缓存key, 根据接口数组生成
    private final Object subKey;
    //二级缓存
    private final ConcurrentMap<Object, Supplier<V>> valuesMap;

    Factory(K key, P parameter, Object subKey,
            ConcurrentMap<Object, Supplier<V>> valuesMap) {
        this.key = key;
        this.parameter = parameter;
        this.subKey = subKey;
        this.valuesMap = valuesMap;
    }

    @Override
    public synchronized V get() {
        //这里再一次去二级缓存里面获取Supplier, 用来验证是否是Factory本身
        Supplier<V> supplier = valuesMap.get(subKey);
        if (supplier != this) {
            //在这里验证supplier是否是Factory实例本身, 如果不则返回null让调用者继续轮询重试
            //期间supplier可能替换成了CacheValue, 或者由于生成代理类失败被从二级缓存中移除了
            return null;
        }
        V value = null;
        try {
            //委托valueFactory去生成代理类, 这里会通过传入的ProxyClassFactory去生成代理类
            value = Objects.requireNonNull(valueFactory.apply(key, parameter));
        } finally {
            //如果生成代理类失败, 就将这个二级缓存删除
            if (value == null) {
                valuesMap.remove(subKey, this);
            }
        }
        //只有value的值不为空才能到达这里
        assert value != null;
        //使用弱引用包装生成的代理类
        CacheValue<V> cacheValue = new CacheValue<>(value);
        //将包装后的cacheValue放入二级缓存中, 这个操作必须成功, 否则就报错
        if (valuesMap.replace(subKey, this, cacheValue)) {
            //将cacheValue成功放入二级缓存后, 再对它进行标记
            reverseMap.put(cacheValue, Boolean.TRUE);
        } else {
            throw new AssertionError("Should not reach here");
        }
        //最后返回没有被弱引用包装的代理类
        return value;
    }
}

// BiFunction<T, U, R>是个函数式接口，可以理解为用T，U两种类型做参数，得到R类型的返回值
private static final class ProxyClassFactory
    implements BiFunction<ClassLoader, Class<?>[], Class<?>>
{
    // 代理类的前缀名$Proxy
    private static final String proxyClassNamePrefix = "$Proxy";

    // 使用唯一的编号给作为代理类名的一部分，如$Proxy0,$Proxy1等
    private static final AtomicLong nextUniqueNumber = new AtomicLong();

    @Override
    public Class<?> apply(ClassLoader loader, Class<?>[] interfaces) {

        Map<Class<?>, Boolean> interfaceSet = new IdentityHashMap<>(interfaces.length);
        for (Class<?> intf : interfaces) {
            // 验证指定的类加载器(loader)加载接口所得到的Class对象(interfaceClass)是否与intf对象相同
            Class<?> interfaceClass = null;
            try {
                interfaceClass = Class.forName(intf.getName(), false, loader);
            } catch (ClassNotFoundException e) {
            }
            if (interfaceClass != intf) {
                throw new IllegalArgumentException(
                    intf + " is not visible from class loader");
            }
            // 验证该Class对象是不是接口
            if (!interfaceClass.isInterface()) {
                throw new IllegalArgumentException(
                    interfaceClass.getName() + " is not an interface");
            }
            /*
             * Verify that this interface is not a duplicate.
             */
            if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) {
                throw new IllegalArgumentException(
                    "repeated interface: " + interfaceClass.getName());
            }
        }

        //声明代理类所在包中的位置
        String proxyPkg = null;     // package to define proxy class in
        //代理类访问控制符: public ,final
        int accessFlags = Modifier.PUBLIC | Modifier.FINAL;

       // 验证你传入的接口中是否有非public接口，只要有一个接口是非public的，那么这些接口都必须在同一包中
        for (Class<?> intf : interfaces) {
            int flags = intf.getModifiers();
            if (!Modifier.isPublic(flags)) {
                accessFlags = Modifier.FINAL;
                String name = intf.getName();
                int n = name.lastIndexOf('.');
                String pkg = ((n == -1) ? "" : name.substring(0, n + 1));
                if (proxyPkg == null) {
                    proxyPkg = pkg;
                } else if (!pkg.equals(proxyPkg)) {
                    throw new IllegalArgumentException(
                        "non-public interfaces from different packages");
                }
            }
        }

        if (proxyPkg == null) {
            // if no non-public proxy interfaces, use com.sun.proxy package
            // 如果都是public接口，那么生成的代理类就在com.sun.proxy包下
            proxyPkg = ReflectUtil.PROXY_PACKAGE + ".";
        }

        /*
         * Choose a name for the proxy class to generate.
         */
        //将当前nextUniqueNumber的值以原子的方式的加1，所以第一次生成代理类的名字为$Proxy0.class
        long num = nextUniqueNumber.getAndIncrement();
        //代理类的完全限定名，如com.sun.proxy.$Proxy0.calss
        String proxyName = proxyPkg + proxyClassNamePrefix + num;

        /*
         * Generate the specified proxy class.
         */
        //生成代理类字节码文件
        byte[] proxyClassFile = ProxyGenerator.generateProxyClass(
            proxyName, interfaces, accessFlags);
        try {
        // 根据二进制字节码返回相应的Class实例，即加载代理类到JVM中
            return defineClass0(loader, proxyName,
                                proxyClassFile, 0, proxyClassFile.length);
        } catch (ClassFormatError e) {
            /*
             * A ClassFormatError here means that (barring bugs in the
             * proxy class generation code) there was some other
             * invalid aspect of the arguments supplied to the proxy
             * class creation (such as virtual machine limitations
             * exceeded).
             */
            throw new IllegalArgumentException(e.toString());
        }
    }
}

public static byte[] generateProxyClass(final String var0, Class<?>[] var1, int var2) {
    ProxyGenerator var3 = new ProxyGenerator(var0, var1, var2);
    // 生成代理类字节码文件的真正方法
    final byte[] var4 = var3.generateClassFile();
    // 这里根据参数配置，决定是否把生成的字节码（.class文件）保存到本地磁盘 默认路径和代理类的包名相关并且是在项目根路径下
    // System.getProperties().put("sun.misc.ProxyGenerator.saveGeneratedFiles", "true");
    if (saveGeneratedFiles) {
        AccessController.doPrivileged(new PrivilegedAction<Void>() {
            public Void run() {
                try {
                    int var1 = var0.lastIndexOf(46);
                    Path var2;
                    if (var1 > 0) {
                        Path var3 = Paths.get(var0.substring(0, var1).replace('.', File.separatorChar));
                        Files.createDirectories(var3);
                        var2 = var3.resolve(var0.substring(var1 + 1, var0.length()) + ".class");
                    } else {
                        var2 = Paths.get(var0 + ".class");
                    }

                    Files.write(var2, var4, new OpenOption[0]);
                    return null;
                } catch (IOException var4x) {
                    throw new InternalError("I/O exception saving generated file: " + var4x);
                }
            }
        });
    }

    return var4;
}

private byte[] generateClassFile() {
    /* addProxyMethod系列方法就是将接口的方法和Object的hashCode,equals,toString方法添加到代理方法容器(proxyMethods),
       其中方法签名作为key,proxyMethod作为value
    */
    this.addProxyMethod(hashCodeMethod, Object.class);
    this.addProxyMethod(equalsMethod, Object.class);
    this.addProxyMethod(toStringMethod, Object.class);
    Class[] var1 = this.interfaces;
    int var2 = var1.length;

    int var3;
    Class var4;
    // 获得所有接口中的所有方法，并将方法添加到代理方法中
    for(var3 = 0; var3 < var2; ++var3) {
        var4 = var1[var3];
        Method[] var5 = var4.getMethods();
        int var6 = var5.length;

        for(int var7 = 0; var7 < var6; ++var7) {
            Method var8 = var5[var7];
            this.addProxyMethod(var8, var4);
        }
    }

    Iterator var11 = this.proxyMethods.values().iterator();

    List var12;
    while(var11.hasNext()) {
        var12 = (List)var11.next();
        // 验证具有相同方法签名的的方法的返回值类型是否一致，因为不可能有两个方法名相同,参数相同，而返回值却不同的方法
        checkReturnTypes(var12);
    }

    Iterator var15;
    //写代理类文件步骤
    try {
        //1. 生成代理类的构造函数
        this.methods.add(this.generateConstructor());
        var11 = this.proxyMethods.values().iterator();

        while(var11.hasNext()) {
            var12 = (List)var11.next();
            var15 = var12.iterator();

            while(var15.hasNext()) {
                ProxyGenerator.ProxyMethod var16 = (ProxyGenerator.ProxyMethod)var15.next();
                 /* 将代理字段声明为Method，10为ACC_PRIVATE和ACC_STATAIC的与运算，表示该字段的修饰符为private static
                    所以代理类的字段都是private static Method ...
                 */
                this.fields.add(new ProxyGenerator.FieldInfo(var16.methodFieldName, "Ljava/lang/reflect/Method;", 10));
                 //生成代理类的代理方法
                this.methods.add(var16.generateMethod());
            }
        }
        //为代理类生成静态代码块，对一些字段进行初始化
        this.methods.add(this.generateStaticInitializer());
    } catch (IOException var10) {
        throw new InternalError("unexpected I/O Exception", var10);
    }

    if (this.methods.size() > 65535) {
        throw new IllegalArgumentException("method limit exceeded");
    } else if (this.fields.size() > 65535) {
        throw new IllegalArgumentException("field limit exceeded");
    } else {
        this.cp.getClass(dotToSlash(this.className));
        this.cp.getClass("java/lang/reflect/Proxy");
        var1 = this.interfaces;
        var2 = var1.length;

        for(var3 = 0; var3 < var2; ++var3) {
            var4 = var1[var3];
            this.cp.getClass(dotToSlash(var4.getName()));
        }

        this.cp.setReadOnly();
        ByteArrayOutputStream var13 = new ByteArrayOutputStream();
        DataOutputStream var14 = new DataOutputStream(var13);

        try {
            var14.writeInt(-889275714);
            var14.writeShort(0);
            var14.writeShort(49);
            this.cp.write(var14);
            var14.writeShort(this.accessFlags);
            var14.writeShort(this.cp.getClass(dotToSlash(this.className)));
            var14.writeShort(this.cp.getClass("java/lang/reflect/Proxy"));
            var14.writeShort(this.interfaces.length);
            Class[] var17 = this.interfaces;
            int var18 = var17.length;

            for(int var19 = 0; var19 < var18; ++var19) {
                Class var22 = var17[var19];
                var14.writeShort(this.cp.getClass(dotToSlash(var22.getName())));
            }

            var14.writeShort(this.fields.size());
            var15 = this.fields.iterator();

            while(var15.hasNext()) {
                ProxyGenerator.FieldInfo var20 = (ProxyGenerator.FieldInfo)var15.next();
                var20.write(var14);
            }

            var14.writeShort(this.methods.size());
            var15 = this.methods.iterator();

            while(var15.hasNext()) {
                ProxyGenerator.MethodInfo var21 = (ProxyGenerator.MethodInfo)var15.next();
                var21.write(var14);
            }

            var14.writeShort(0);
            return var13.toByteArray();
        } catch (IOException var9) {
            throw new InternalError("unexpected I/O Exception", var9);
        }
    }
}
```

##### 基于CGLIB的动态代理
CGLib动态代理能代理类和接口，但是不能代理final类。final修饰的方法也不能被代理，但是可以被直接调用。
JDK动态代理和CGLib动态代理都是运行时增强，通过将横切代码植入代理类的方式增强。
```java
@Slf4j
public class TestCglib  {
    public static void main(String[] args) {
        //代理类class文件存入本地磁盘
        System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, "/code");
        RealSubjectA subjectA = new RealSubjectA();
        Enhancer en = new Enhancer();
        // 定义要代理的对象，继承被代理类
        en.setSuperclass(subjectA.getClass());
        /*en.setCallback((MethodInterceptor) (o1, method, objects, methodProxy) -> {
            log.info("-----before-------");
            methodProxy.invokeSuper(o1, args);
            log.info("-----after--------");
            return null;

        });*/

        // 设置回调
        // 实现MethodInterceptor接口生成方法拦截器：
        en.setCallback(new MethodInterceptor() {
            @Override
            public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
                log.info("-----before-------");
                Object o1 = methodProxy.invokeSuper(o, args);
                log.info(o1.toString());
                log.info("-----after--------");
                return o1;
            }
        });
        // 设置代理类对象，生成代理对象
        RealSubjectA o1 = (RealSubjectA) en.create();
        String s = o1.doSomething();
        log.info(s);
        log.info(o1.doSomething1().toString());
    }
}
/*
CGLIB debugging enabled, writing to 'C:\class'
[INFO ] [com.example.demo.weixin.TestCglib$1.intercept(TestCglib.java:32)] -----before-------
[INFO ] [com.example.demo.weixin.TestCglib$1.intercept(TestCglib.java:34)] RealSubjectA
[INFO ] [com.example.demo.weixin.TestCglib$1.intercept(TestCglib.java:35)] -----after--------
[INFO ] [com.example.demo.weixin.TestCglib.main(TestCglib.java:42)] RealSubjectA
[INFO ] [com.example.demo.weixin.TestCglib$1.intercept(TestCglib.java:32)] -----before-------
[INFO ] [com.example.demo.weixin.TestCglib$1.intercept(TestCglib.java:34)] doSomething1
[INFO ] [com.example.demo.weixin.TestCglib$1.intercept(TestCglib.java:35)] -----after--------
[INFO ] [com.example.demo.weixin.TestCglib.main(TestCglib.java:43)] doSomething1
*/
```

```java
// 1. 生成代理类
RealSubjectA o1 = (RealSubjectA) en.create();

//
public Object create() {
		classOnly = false;
		argumentTypes = null;
		return createHelper();
	}

private Object createHelper() {
		preValidate();
		Object key = KEY_FACTORY.newInstance((superclass != null) ? superclass.getName() : null,
				ReflectUtils.getNames(interfaces),
				filter == ALL_ZERO ? null : new WeakCacheKey<CallbackFilter>(filter),
				callbackTypes,
				useFactory,
				interceptDuringConstruction,
				serialVersionUID);
		this.currentKey = key;
		Object result = super.create(key);
		return result;
}
```

CGLIB生成代理类只需要一个目标类和一个回调函数即增强执行逻辑。

JDK动态代理使用的是反射技术，而CGLIB则使用了FastClass构建方法索引+继承的方式访问目标类的方法。

反编译class文件可以发现代理了Object中的equals, toString,hashCode,clone方法。

