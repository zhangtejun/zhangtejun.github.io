---
layout: post
title:  "dubbo"
date:   2019-08-29 14:12:23
author: zhangtejun
categories: Java
---
##### 代理模式
普通对象可以通过公共接口来完成自己需要的工作，然而有些对象却由于部分原因无法履行自己的职责。比如有的对象加载时间长，
有些对象运行在其他计算机上，有些对象需要先拦截发送到对象的信息等，这些情况下可以引入代理对象，通过代理对象来承担客户需要的职责，
并将相应的请求转发给底层目标对象。

代理对象通常有一个几乎和目标对象相同的接口，它常常控制访问，并将请求合理的转发给底层目标对象。

**远程代理**
需要调用的对象方法在其他机器上运行，不能直接调用，可以在远程机器上打开一socket套接字，并设计出一些协议来与远程对象进行消息传递。

理想情况下，这种方法可以像在你本地一样传输消息。可以调用代理对象的方法，将镇上对象的调用转发给远程机器。比如CORBA，RMI等已实现这张方式。

远程过程调用（Remote Procedure Call, RPC）可以用于一个进程调用另一个进程（很可能在另一个远程主机上）中的过程，从而提供了过程的分布能力。
Java 的 RMI 则在 RPC 的基础上向前又迈进了一步，即提供分布式对象间的通讯。
RMI（Remote Method Invocation）为远程方法调用，是允许运行在一个Java虚拟机的对象调用运行在另一个Java虚拟机上的对象的方法。

RMI目前使用Java远程消息交换协议 JRMP（Java Remote Messaging Protocol ）进行通信。

RMI的 用途是为分布式Java应用程序之间的远程通信提供服务，提供分布式服务。

Remote interface：是一个不定义方法的标记接口，在RMI中，远程接口声明了可以从远程Java虚拟机中调用的方法集。

LocateRegistry：final类用于获得特定主机的引导远程对象注册服务器程序的引用（即创建stub），或者创建能在特定端口接收调用的远程对象注册服务程序。
在服务端表现为向其他客户机提供远程对象服务。

RMISecurityManager：在RMI引用程序中，如果没有设置安全管理器，则只能从本地类路径加载stub和类，这可以确保应用程序不受由远程方法调用所下载的代码侵害。

在从远程主机下载代码之前必须执行以下代码来安装RMISecurityManager:
System.setSecurityManager(new RMISecurityManager())；
该类已被废弃,使用它的父类SecurityManager代替

Java RMI技术是伴随着分布式处理的需求而诞生出来，虽然从RMI的字面翻译没有看出来。
在这一点上DCOM（Distributed Object Component Model，分布式对象组件模型，RPC就是通过DCOM机制来实现）似乎表现得更直白一些。
分布式处理的构架就决定了无论是RMI还是RPC都至少是C/S模型，即Server作为对象（远程对象或者COM对象）提供者，而Client端作为使用者。

同样，RMI也像DCOM一样，Server端需要先注册服务，而Client端调用远程方法之前需要查找已经注册的服务，由此获得通信端口和传递参数等后续工作

不同的是，Java平台与生俱来的安全性和良好的扩展性就决定了Java RMI比RPC更加安全和灵活，例如Java RMI可以穿透防火墙，而DCOM机制则不能；
Java RMI可以支持嵌入更高级的连接应用，例如结合JNDI，XML技术等。


远程接口需满足下列要求：
1. 远程接口必须直接或间接扩展`Java.rmi.Remote`接口，且必须声明为public，除非客户端于远程接口在同一包中
2. 在远程接口中的方法在声明时，除了要抛出与应用程序有关的异常之外，还必须包括RemoteException（或它的超类，IOExcepion或Exception）异常
3. 在远程方法声明中，作为参数或返回值声明的远程对象必须声明为远程接口，而非该接口的实现类。

RemoteObject抽象类：实现了Remote接口和序列化Serializable接口，它和它的子类提供RMI服务器函数。

提供了创建远程对象并将其导出（也就是使他们能够被远程客户机所调用），所需的方法由类UnicastRemoteObject和Activatable提供。

Stub是客户端的代理，它实现了所有远程对象的接口；Skeleton是服务器端的实体，它包括了一个被具体远程对象所支持的接口。

在与远程对象的通信过程中，RMI 使用标准机制：stub 和skeleton 。
远程对象的stub 担当远程对象的客户本地代表或代理人角色。
调用程序将调用本地stub 的方法，而本地stub 将负责执行对远程对象的方法调用。

在RMI 中，远程对象的stub与该远程对象所实现的远程接口集相同。
调 用stub 的方法时将执行下列操作：
1. 初始化与包含远程对象的远程虚拟机的连接；
2. 对远程虚拟机的参数进行编组（写入并传输）；
3. 等待方法调用结果；
4. 解编（读取）返回值或返回的异常；
5. 将值返回给调用程序。

它在接收方法调用时执行下列操作:
1. 解编（读取）远程方法的参数；
2. 调用实际远程对象实现上的方法；
3. 将结果（返回值或异常）编组（写入并传输）给调用程序

##### 远程过程调用 RPC
Dubbo 提供远程调用能力 RPC

##### 动态代理
动态代理依赖对象所实现的接口。接口中定义什么调用，代理就拦截什么调用。

为了创建动态代理，必须列出所要拦截的接口。
```java
// 获取所有接口
Class<?>[] classes = obj.getClass().getInterfaces();
// 类加载器和当代理拦截调用时，需要执行的行为类
ClassLoader loader = obj.getClass().getClassLoader();
// 最后一个元素是代理对象本身，这个对象必须实现invocationHandler接口，接口声明为：
public Object invoke(Object proxy, Method method, Object[] args) throws Throwable;
// 对包装对象的调用会转发给你所提供类的invoke()方法，该方法会将调用转发给被包装对象
result = m.invoke(obj, args);
// 在方法执行前后，对调用进行拦截，并创建增加行为的思想属于面向切面编（AOP）,在AOP中，切面就是所谓的“建议”（advic）和“切入点”的组合。

// **例子**
// 1. 定义了一个Subject类型的接口
public interface Subject
{
    public void doSomething();
}
// 2. 定义了一个类来实现这个接口，这个类就是我们的真实对象，RealSubject
public class RealSubject implements Subject
{
    @Override
    public void doSomething()
    {
        System.out.println("doSomething...");
    }
}
// 3. 定义一个动态代理类，需要实现invocationHandler接口
public class DynamicProxy implements InvocationHandler
{
    //　这个就是我们要代理的真实对象
    private Object subject;

    // 构造方法，给要代理的真实对象赋初值
    public DynamicProxy(Object subject)
    {
        this.subject = subject;
    }

    @Override
    public Object invoke(Object object, Method method, Object[] args)
            throws Throwable
    {
        //　在代理真实对象前我们可以添加一些自己的操作
        System.out.println("before invoke ...");

        // 当代理对象调用真实对象的方法时，其会自动的跳转到代理对象关联的handler对象的invoke方法来进行调用
        method.invoke(subject, args);

        //　在代理真实对象后我们也可以添加一些自己的操作
        System.out.println("after invoke ...");

        return null;
    }
}
// 4. 调用
// 4.1 要代理的真实对象
Subject realSubject = new RealSubject();//这里指定被代理类

// 4.2 要代理哪个真实对象，就将该对象传进去，最后是通过该真实对象来调用其方法的
InvocationHandler handler = new DynamicProxy(realSubject);

/* 4.3
 * 通过Proxy的newProxyInstance方法来创建我们的代理对象
 * 第一个参数realSubject.getClass().getClassLoader()，我们这里使用代理类的类加载器，也就是被代理的那个真实对象
 * 第二个参数realSubject.getClass().getInterfaces()，我们这里为代理对象提供的接口是真实对象所实行的接口，表示我要代理的是该真实对象，这样我就能调用这组接口中的方法了
 * 第三个参数handler，我们这里将这个代理对象关联到了上方的InvocationHandler 这个对象上
 */
Subject subject = (Subject) Proxy.newProxyInstance(realSubject.getClass().getClassLoader(),
        realSubject.getClass().getInterfaces(), handler);
subject.doSomething();
```

JDK动态代理的入口是`Proxy.newProxyInstance(ClassLoader loader,Class<?>[] interfaces,InvocationHandler h)`这个静态方法。
参数分别是加载动态生成的代理类的类加载器，业务类实现的接口，InvocationHandler对象（需要开发人员开发）。
```java
public static Object newProxyInstance(ClassLoader loader,Class<?>[] interfaces,InvocationHandler h)throws IllegalArgumentException
    {
        Objects.requireNonNull(h);

        final Class<?>[] intfs = interfaces.clone();// clone接口类对象数组
        final SecurityManager sm = System.getSecurityManager(); // 权限检查
        if (sm != null) {
            checkProxyAccess(Reflection.getCallerClass(), loader, intfs);
        }

        /*
         * Look up or generate the designated proxy class.
         */
        Class<?> cl = getProxyClass0(loader, intfs);// 查找或者是生成一个特定的代理类对象

        /*
         * Invoke its constructor with the designated invocation handler.
         */
        try {
            if (sm != null) {
                checkNewProxyPermission(Reflection.getCallerClass(), cl);
            }

            final Constructor<?> cons = cl.getConstructor(constructorParams);
            final InvocationHandler ih = h;
            if (!Modifier.isPublic(cl.getModifiers())) {
                AccessController.doPrivileged(new PrivilegedAction<Void>() {
                    public Void run() {
                        cons.setAccessible(true);
                        return null;
                    }
                });
            }
            return cons.newInstance(new Object[]{h});
        } catch (IllegalAccessException|InstantiationException e) {
            throw new InternalError(e.toString(), e);
        } catch (InvocationTargetException e) {
            Throwable t = e.getCause();
            if (t instanceof RuntimeException) {
                throw (RuntimeException) t;
            } else {
                throw new InternalError(t.toString(), t);
            }
        } catch (NoSuchMethodException e) {
            throw new InternalError(e.toString(), e);
        }
    }

//查找或者是生成一个特定的代理类对象
private static Class<?> getProxyClass0(ClassLoader loader,Class<?>... interfaces) {
        // length 是 int 类型
        if (interfaces.length > 65535) {// 接口数限制
            throw new IllegalArgumentException("interface limit exceeded");
        }

        // 如果在指定的类加载器中已经创建了实现指定接口的代理类，则查找缓存，
        // 否则通过ProxyClassFactory创建实现指定接口的代理类
        return proxyClassCache.get(loader, interfaces);
    }

public V get(K key, P parameter) {
    Objects.requireNonNull(parameter);
    expungeStaleEntries();// 删除过时的缓存
    // 将ClassLoader包装成CacheKey, 作为一级缓存的key
    // 生成缓存key对象实例，如果key = null，cacheKey = new Object();
    Object cacheKey = CacheKey.valueOf(key, refQueue);
    // lazily install the 2nd level valuesMap for the particular cacheKey
    // 从缓存map中读取指定cacheKey的缓存数据valuesMap，该值为二级缓存
    ConcurrentMap<Object, Supplier<V>> valuesMap = map.get(cacheKey);
    if (valuesMap == null) {
         // 以CAS方式put, 如果不存在则新建一个，否则返回原来的值
        ConcurrentMap<Object, Supplier<V>> oldValuesMap
            = map.putIfAbsent(cacheKey,valuesMap = new ConcurrentHashMap<>());
        // 如果 oldValuesMap 不为null，说明原来是有值的
        if (oldValuesMap != null) {
            valuesMap = oldValuesMap;
        }
    }
    // create subKey and retrieve the possible Supplier<V> stored by that
    // subKey from valuesMap
    // 根据代理类实现的接口数组来生成二级缓存key
    Object subKey = Objects.requireNonNull(subKeyFactory.apply(key, parameter));
    // 这里通过subKey获取到二级缓存的值
    Supplier<V> supplier = valuesMap.get(subKey);
    Factory factory = null;

    while (true) {
        // 如果通过subKey取出来的值不为null
        if (supplier != null) {
            // supplier might be a Factory or a CacheValue<V> instance
            // 如果缓存里有supplier ，那就直接通过get方法，得到代理类对象，返回
            // supplier可能是一个Factory也可能会是一个CacheValue
            V value = supplier.get();
            if (value != null) {
                return value;
            }
        }
        // else no supplier in cache
        // or a supplier that returned null (could be a cleared CacheValue
        // or a Factory that wasn't successful in installing the CacheValue)

        // lazily construct a Factory
        // 如果缓存中没有supplier，则创建一个Factory对象，作为键subKey的值
        // 然后把factory对象在多线程的环境下安全的赋给supplier。
        // 赋值成功后，接着下一次循环开始，又回到上面去调get方法，返回才结束。
        if (factory == null) {
            factory = new Factory(key, parameter, subKey, valuesMap);
        }

        if (supplier == null) {
            // 就将factory作为subKey的值放入
            // putIfAbsent：如果传入key对应的value已经存在，就返回存在的value，不进行替换。如果不存在，就添加key和value，返回null
            supplier = valuesMap.putIfAbsent(subKey, factory);
            if (supplier == null) {
                // successfully installed Factory
                // 到这里表明成功将factory放入缓存
                supplier = factory;
            }
            // else retry with winning supplier
        } else {
            // 期间可能其他线程修改了值, 那么就将原先的值替换
            if (valuesMap.replace(subKey, supplier, factory)) {
                // successfully replaced
                // cleared CacheEntry / unsuccessful Factory
                // with our Factory
                // factory替换成功
                supplier = factory;
            } else {
                // 替换失败, 继续使用原先的值
                // retry with current supplier
                supplier = valuesMap.get(subKey);
            }
        }
    }
}

private final class Factory implements Supplier<V> {
    //一级缓存key, 根据ClassLoader生成
    private final K key;
    //代理类实现的接口数组
    private final P parameter;
    //二级缓存key, 根据接口数组生成
    private final Object subKey;
    //二级缓存
    private final ConcurrentMap<Object, Supplier<V>> valuesMap;

    Factory(K key, P parameter, Object subKey,
            ConcurrentMap<Object, Supplier<V>> valuesMap) {
        this.key = key;
        this.parameter = parameter;
        this.subKey = subKey;
        this.valuesMap = valuesMap;
    }

    @Override
    public synchronized V get() {
        //这里再一次去二级缓存里面获取Supplier, 用来验证是否是Factory本身
        Supplier<V> supplier = valuesMap.get(subKey);
        if (supplier != this) {
            //在这里验证supplier是否是Factory实例本身, 如果不则返回null让调用者继续轮询重试
            //期间supplier可能替换成了CacheValue, 或者由于生成代理类失败被从二级缓存中移除了
            return null;
        }
        V value = null;
        try {
            //委托valueFactory去生成代理类, 这里会通过传入的ProxyClassFactory去生成代理类
            value = Objects.requireNonNull(valueFactory.apply(key, parameter));
        } finally {
            //如果生成代理类失败, 就将这个二级缓存删除
            if (value == null) {
                valuesMap.remove(subKey, this);
            }
        }
        //只有value的值不为空才能到达这里
        assert value != null;
        //使用弱引用包装生成的代理类
        CacheValue<V> cacheValue = new CacheValue<>(value);
        //将包装后的cacheValue放入二级缓存中, 这个操作必须成功, 否则就报错
        if (valuesMap.replace(subKey, this, cacheValue)) {
            //将cacheValue成功放入二级缓存后, 再对它进行标记
            reverseMap.put(cacheValue, Boolean.TRUE);
        } else {
            throw new AssertionError("Should not reach here");
        }
        //最后返回没有被弱引用包装的代理类
        return value;
    }
}

// BiFunction<T, U, R>是个函数式接口，可以理解为用T，U两种类型做参数，得到R类型的返回值
private static final class ProxyClassFactory
    implements BiFunction<ClassLoader, Class<?>[], Class<?>>
{
    // 代理类的前缀名$Proxy
    private static final String proxyClassNamePrefix = "$Proxy";

    // 使用唯一的编号给作为代理类名的一部分，如$Proxy0,$Proxy1等
    private static final AtomicLong nextUniqueNumber = new AtomicLong();

    @Override
    public Class<?> apply(ClassLoader loader, Class<?>[] interfaces) {

        Map<Class<?>, Boolean> interfaceSet = new IdentityHashMap<>(interfaces.length);
        for (Class<?> intf : interfaces) {
            // 验证指定的类加载器(loader)加载接口所得到的Class对象(interfaceClass)是否与intf对象相同
            Class<?> interfaceClass = null;
            try {
                interfaceClass = Class.forName(intf.getName(), false, loader);
            } catch (ClassNotFoundException e) {
            }
            if (interfaceClass != intf) {
                throw new IllegalArgumentException(
                    intf + " is not visible from class loader");
            }
            // 验证该Class对象是不是接口
            if (!interfaceClass.isInterface()) {
                throw new IllegalArgumentException(
                    interfaceClass.getName() + " is not an interface");
            }
            /*
             * Verify that this interface is not a duplicate.
             */
            if (interfaceSet.put(interfaceClass, Boolean.TRUE) != null) {
                throw new IllegalArgumentException(
                    "repeated interface: " + interfaceClass.getName());
            }
        }

        //声明代理类所在包中的位置
        String proxyPkg = null;     // package to define proxy class in
        //代理类访问控制符: public ,final
        int accessFlags = Modifier.PUBLIC | Modifier.FINAL;

       // 验证你传入的接口中是否有非public接口，只要有一个接口是非public的，那么这些接口都必须在同一包中
        for (Class<?> intf : interfaces) {
            int flags = intf.getModifiers();
            if (!Modifier.isPublic(flags)) {
                accessFlags = Modifier.FINAL;
                String name = intf.getName();
                int n = name.lastIndexOf('.');
                String pkg = ((n == -1) ? "" : name.substring(0, n + 1));
                if (proxyPkg == null) {
                    proxyPkg = pkg;
                } else if (!pkg.equals(proxyPkg)) {
                    throw new IllegalArgumentException(
                        "non-public interfaces from different packages");
                }
            }
        }

        if (proxyPkg == null) {
            // if no non-public proxy interfaces, use com.sun.proxy package
            // 如果都是public接口，那么生成的代理类就在com.sun.proxy包下
            proxyPkg = ReflectUtil.PROXY_PACKAGE + ".";
        }

        /*
         * Choose a name for the proxy class to generate.
         */
        //将当前nextUniqueNumber的值以原子的方式的加1，所以第一次生成代理类的名字为$Proxy0.class
        long num = nextUniqueNumber.getAndIncrement();
        //代理类的完全限定名，如com.sun.proxy.$Proxy0.calss
        String proxyName = proxyPkg + proxyClassNamePrefix + num;

        /*
         * Generate the specified proxy class.
         */
        //生成代理类字节码文件
        byte[] proxyClassFile = ProxyGenerator.generateProxyClass(
            proxyName, interfaces, accessFlags);
        try {
        // 根据二进制字节码返回相应的Class实例，即加载代理类到JVM中
            return defineClass0(loader, proxyName,
                                proxyClassFile, 0, proxyClassFile.length);
        } catch (ClassFormatError e) {
            /*
             * A ClassFormatError here means that (barring bugs in the
             * proxy class generation code) there was some other
             * invalid aspect of the arguments supplied to the proxy
             * class creation (such as virtual machine limitations
             * exceeded).
             */
            throw new IllegalArgumentException(e.toString());
        }
    }
}

public static byte[] generateProxyClass(final String var0, Class<?>[] var1, int var2) {
    ProxyGenerator var3 = new ProxyGenerator(var0, var1, var2);
    // 生成代理类字节码文件的真正方法
    final byte[] var4 = var3.generateClassFile();
    // 这里根据参数配置，决定是否把生成的字节码（.class文件）保存到本地磁盘 默认路径和代理类的包名相关并且是在项目根路径下
    // System.getProperties().put("sun.misc.ProxyGenerator.saveGeneratedFiles", "true");
    if (saveGeneratedFiles) {
        AccessController.doPrivileged(new PrivilegedAction<Void>() {
            public Void run() {
                try {
                    int var1 = var0.lastIndexOf(46);
                    Path var2;
                    if (var1 > 0) {
                        Path var3 = Paths.get(var0.substring(0, var1).replace('.', File.separatorChar));
                        Files.createDirectories(var3);
                        var2 = var3.resolve(var0.substring(var1 + 1, var0.length()) + ".class");
                    } else {
                        var2 = Paths.get(var0 + ".class");
                    }

                    Files.write(var2, var4, new OpenOption[0]);
                    return null;
                } catch (IOException var4x) {
                    throw new InternalError("I/O exception saving generated file: " + var4x);
                }
            }
        });
    }

    return var4;
}

private byte[] generateClassFile() {
    /* addProxyMethod系列方法就是将接口的方法和Object的hashCode,equals,toString方法添加到代理方法容器(proxyMethods),
       其中方法签名作为key,proxyMethod作为value
    */
    this.addProxyMethod(hashCodeMethod, Object.class);
    this.addProxyMethod(equalsMethod, Object.class);
    this.addProxyMethod(toStringMethod, Object.class);
    Class[] var1 = this.interfaces;
    int var2 = var1.length;

    int var3;
    Class var4;
    // 获得所有接口中的所有方法，并将方法添加到代理方法中
    for(var3 = 0; var3 < var2; ++var3) {
        var4 = var1[var3];
        Method[] var5 = var4.getMethods();
        int var6 = var5.length;

        for(int var7 = 0; var7 < var6; ++var7) {
            Method var8 = var5[var7];
            this.addProxyMethod(var8, var4);
        }
    }

    Iterator var11 = this.proxyMethods.values().iterator();

    List var12;
    while(var11.hasNext()) {
        var12 = (List)var11.next();
        // 验证具有相同方法签名的的方法的返回值类型是否一致，因为不可能有两个方法名相同,参数相同，而返回值却不同的方法
        checkReturnTypes(var12);
    }

    Iterator var15;
    //写代理类文件步骤
    try {
        //1. 生成代理类的构造函数
        this.methods.add(this.generateConstructor());
        var11 = this.proxyMethods.values().iterator();

        while(var11.hasNext()) {
            var12 = (List)var11.next();
            var15 = var12.iterator();

            while(var15.hasNext()) {
                ProxyGenerator.ProxyMethod var16 = (ProxyGenerator.ProxyMethod)var15.next();
                 /* 将代理字段声明为Method，10为ACC_PRIVATE和ACC_STATAIC的与运算，表示该字段的修饰符为private static
                    所以代理类的字段都是private static Method ...
                 */
                this.fields.add(new ProxyGenerator.FieldInfo(var16.methodFieldName, "Ljava/lang/reflect/Method;", 10));
                 //生成代理类的代理方法
                this.methods.add(var16.generateMethod());
            }
        }
        //为代理类生成静态代码块，对一些字段进行初始化
        this.methods.add(this.generateStaticInitializer());
    } catch (IOException var10) {
        throw new InternalError("unexpected I/O Exception", var10);
    }

    if (this.methods.size() > 65535) {
        throw new IllegalArgumentException("method limit exceeded");
    } else if (this.fields.size() > 65535) {
        throw new IllegalArgumentException("field limit exceeded");
    } else {
        this.cp.getClass(dotToSlash(this.className));
        this.cp.getClass("java/lang/reflect/Proxy");
        var1 = this.interfaces;
        var2 = var1.length;

        for(var3 = 0; var3 < var2; ++var3) {
            var4 = var1[var3];
            this.cp.getClass(dotToSlash(var4.getName()));
        }

        this.cp.setReadOnly();
        ByteArrayOutputStream var13 = new ByteArrayOutputStream();
        DataOutputStream var14 = new DataOutputStream(var13);

        try {
            var14.writeInt(-889275714);
            var14.writeShort(0);
            var14.writeShort(49);
            this.cp.write(var14);
            var14.writeShort(this.accessFlags);
            var14.writeShort(this.cp.getClass(dotToSlash(this.className)));
            var14.writeShort(this.cp.getClass("java/lang/reflect/Proxy"));
            var14.writeShort(this.interfaces.length);
            Class[] var17 = this.interfaces;
            int var18 = var17.length;

            for(int var19 = 0; var19 < var18; ++var19) {
                Class var22 = var17[var19];
                var14.writeShort(this.cp.getClass(dotToSlash(var22.getName())));
            }

            var14.writeShort(this.fields.size());
            var15 = this.fields.iterator();

            while(var15.hasNext()) {
                ProxyGenerator.FieldInfo var20 = (ProxyGenerator.FieldInfo)var15.next();
                var20.write(var14);
            }

            var14.writeShort(this.methods.size());
            var15 = this.methods.iterator();

            while(var15.hasNext()) {
                ProxyGenerator.MethodInfo var21 = (ProxyGenerator.MethodInfo)var15.next();
                var21.write(var14);
            }

            var14.writeShort(0);
            return var13.toByteArray();
        } catch (IOException var9) {
            throw new InternalError("unexpected I/O Exception", var9);
        }
    }
}
```

##### 基于CGLIB的动态代理
CGLib动态代理能代理类和接口，但是不能代理final类。final修饰的方法也不能被代理，但是可以被直接调用。
JDK动态代理和CGLib动态代理都是运行时增强，通过将横切代码植入代理类的方式增强。
```java
@Slf4j
public class TestCglib  {
    public static void main(String[] args) {
        //代理类class文件存入本地磁盘
        System.setProperty(DebuggingClassWriter.DEBUG_LOCATION_PROPERTY, "/code");
        RealSubjectA subjectA = new RealSubjectA();
        Enhancer en = new Enhancer();
        en.setCallbackFilter(new CallbackFilter() {
           @Override
           public int accept(Method method) {
                  // return值为被代理类的各个方法在回调数组Callback[]中的位置索引
                 if("XXX".queals(method.getName())){
                    return 0;
                 }else{
                    return 0;
                 }
            }
           });
        // 定义要代理的对象，继承被代理类
        en.setSuperclass(subjectA.getClass());
        /*en.setCallback((MethodInterceptor) (o1, method, objects, methodProxy) -> {
            log.info("-----before-------");
            methodProxy.invokeSuper(o1, args);
            log.info("-----after--------");
            return null;

        });*/


        // 设置回调
        // 实现MethodInterceptor接口生成方法拦截器：
        en.setCallback(new MethodInterceptor() {
            @Override
            public Object intercept(Object o, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {
                log.info("-----before-------");
                Object o1 = methodProxy.invokeSuper(o, args);
                log.info(o1.toString());
                log.info("-----after--------");
                return o1;
            }
        });
        // 设置代理类对象，生成代理对象
        RealSubjectA o1 = (RealSubjectA) en.create();
        String s = o1.doSomething();
        log.info(s);
        log.info(o1.doSomething1().toString());
    }
}
/*
CGLIB debugging enabled, writing to 'C:\class'
[INFO ] [com.example.demo.weixin.TestCglib$1.intercept(TestCglib.java:32)] -----before-------
[INFO ] [com.example.demo.weixin.TestCglib$1.intercept(TestCglib.java:34)] RealSubjectA
[INFO ] [com.example.demo.weixin.TestCglib$1.intercept(TestCglib.java:35)] -----after--------
[INFO ] [com.example.demo.weixin.TestCglib.main(TestCglib.java:42)] RealSubjectA
[INFO ] [com.example.demo.weixin.TestCglib$1.intercept(TestCglib.java:32)] -----before-------
[INFO ] [com.example.demo.weixin.TestCglib$1.intercept(TestCglib.java:34)] doSomething1
[INFO ] [com.example.demo.weixin.TestCglib$1.intercept(TestCglib.java:35)] -----after--------
[INFO ] [com.example.demo.weixin.TestCglib.main(TestCglib.java:43)] doSomething1
*/
```

```java
// 1. 生成代理类
RealSubjectA o1 = (RealSubjectA) en.create();

//
public Object create() {
		classOnly = false;
		argumentTypes = null;
		return createHelper();
	}

private Object createHelper() {
		preValidate();
		Object key = KEY_FACTORY.newInstance((superclass != null) ? superclass.getName() : null,
				ReflectUtils.getNames(interfaces),
				filter == ALL_ZERO ? null : new WeakCacheKey<CallbackFilter>(filter),
				callbackTypes,
				useFactory,
				interceptDuringConstruction,
				serialVersionUID);
		this.currentKey = key;
		Object result = super.create(key);
		return result;
}
```

Cglib生成的class文件，一共有三个class文件
```
Rocket$$EnhancerByCGLIB$$4201510b$$FastClassByCGLIB$$3158ca69.class
Rocket$$EnhancerByCGLIB$$4201510b.class
Rocket$$FastClassByCGLIB$$d9e2bc6a.class
```
RocketImplN$$EnhancerByCGLIB$$e9cf4fff为代理类
```java
public class RocketImplN$$EnhancerByCGLIB$$e9cf4fff extends RocketImplN implements Factory {
    private boolean CGLIB$BOUND;
    public static Object CGLIB$FACTORY_DATA;
    private static final ThreadLocal CGLIB$THREAD_CALLBACKS;
    private static final Callback[] CGLIB$STATIC_CALLBACKS;
    private MethodInterceptor CGLIB$CALLBACK_0; // 拦截器
    private static Object CGLIB$CALLBACK_FILTER;
    private static final Method CGLIB$getPrice3$0$Method;  // 被代理类的方法
    private static final MethodProxy CGLIB$getPrice3$0$Proxy;  // 代理方法
    private static final Object[] CGLIB$emptyArgs;
    private static final Method CGLIB$getPrice1$1$Method;
    private static final MethodProxy CGLIB$getPrice1$1$Proxy;
    private static final Method CGLIB$getPrice$2$Method;
    private static final MethodProxy CGLIB$getPrice$2$Proxy;
    private static final Method CGLIB$boost$3$Method;
    private static final MethodProxy CGLIB$boost$3$Proxy;
    private static final Method CGLIB$getApogee$4$Method;
    private static final MethodProxy CGLIB$getApogee$4$Proxy;
    private static final Method CGLIB$clone$5$Method;
    private static final MethodProxy CGLIB$clone$5$Proxy;
    private static final Method CGLIB$equals$6$Method;
    private static final MethodProxy CGLIB$equals$6$Proxy;
    private static final Method CGLIB$toString$7$Method;
    private static final MethodProxy CGLIB$toString$7$Proxy;
    private static final Method CGLIB$hashCode$8$Method;
    private static final MethodProxy CGLIB$hashCode$8$Proxy;
    private static final Method CGLIB$getRef$9$Method;
    private static final MethodProxy CGLIB$getRef$9$Proxy;

    static void CGLIB$STATICHOOK1() {
        CGLIB$THREAD_CALLBACKS = new ThreadLocal();
        CGLIB$emptyArgs = new Object[0];
        // 代理类
        Class var0 = Class.forName("com.example.demo.javaweb.RocketImplN$$EnhancerByCGLIB$$e9cf4fff");
        // 被代理类
        Class var1;
        Method[] var10000 = ReflectUtils.findMethods(new String[]{"getPrice3", "()Ljava/lang/Double;", "getPrice1", "()Ljava/lang/Double;", "getPrice", "()Ljava/lang/Double;", "boost", "(Ljava/lang/Double;)V", "getApogee", "()Ljava/lang/Double;"}, (var1 = Class.forName("com.example.demo.javaweb.RocketImplN")).getDeclaredMethods());
        CGLIB$getPrice3$0$Method = var10000[0];
        CGLIB$getPrice3$0$Proxy = MethodProxy.create(var1, var0, "()Ljava/lang/Double;", "getPrice3", "CGLIB$getPrice3$0");
        CGLIB$getPrice1$1$Method = var10000[1];
        CGLIB$getPrice1$1$Proxy = MethodProxy.create(var1, var0, "()Ljava/lang/Double;", "getPrice1", "CGLIB$getPrice1$1");
        CGLIB$getPrice$2$Method = var10000[2];
        CGLIB$getPrice$2$Proxy = MethodProxy.create(var1, var0, "()Ljava/lang/Double;", "getPrice", "CGLIB$getPrice$2");
        CGLIB$boost$3$Method = var10000[3];
        CGLIB$boost$3$Proxy = MethodProxy.create(var1, var0, "(Ljava/lang/Double;)V", "boost", "CGLIB$boost$3");
        CGLIB$getApogee$4$Method = var10000[4];
        CGLIB$getApogee$4$Proxy = MethodProxy.create(var1, var0, "()Ljava/lang/Double;", "getApogee", "CGLIB$getApogee$4");
        CGLIB$clone$5$Method = ReflectUtils.findMethods(new String[]{"clone", "()Ljava/lang/Object;"}, (var1 = Class.forName("java.rmi.server.UnicastRemoteObject")).getDeclaredMethods())[0];
        CGLIB$clone$5$Proxy = MethodProxy.create(var1, var0, "()Ljava/lang/Object;", "clone", "CGLIB$clone$5");
        var10000 = ReflectUtils.findMethods(new String[]{"equals", "(Ljava/lang/Object;)Z", "toString", "()Ljava/lang/String;", "hashCode", "()I", "getRef", "()Ljava/rmi/server/RemoteRef;"}, (var1 = Class.forName("java.rmi.server.RemoteObject")).getDeclaredMethods());
        CGLIB$equals$6$Method = var10000[0];
        CGLIB$equals$6$Proxy = MethodProxy.create(var1, var0, "(Ljava/lang/Object;)Z", "equals", "CGLIB$equals$6");
        CGLIB$toString$7$Method = var10000[1];
        CGLIB$toString$7$Proxy = MethodProxy.create(var1, var0, "()Ljava/lang/String;", "toString", "CGLIB$toString$7");
        CGLIB$hashCode$8$Method = var10000[2];
        CGLIB$hashCode$8$Proxy = MethodProxy.create(var1, var0, "()I", "hashCode", "CGLIB$hashCode$8");
        CGLIB$getRef$9$Method = var10000[3];
        CGLIB$getRef$9$Proxy = MethodProxy.create(var1, var0, "()Ljava/rmi/server/RemoteRef;", "getRef", "CGLIB$getRef$9");
    }
     // 代理方法
    final Double CGLIB$getPrice3$0() {
        return super.getPrice3();
    }
    // 被代理的方法
    final Double getPrice3() {
        MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;
        if (this.CGLIB$CALLBACK_0 == null) {
            CGLIB$BIND_CALLBACKS(this);
            var10000 = this.CGLIB$CALLBACK_0;
        }
        // 调用拦截器
        return var10000 != null ? (Double)var10000.intercept(this, CGLIB$getPrice3$0$Method, CGLIB$emptyArgs, CGLIB$getPrice3$0$Proxy) : super.getPrice3();
    }

    final Double CGLIB$getPrice1$1() {
        return super.getPrice1();
    }

    protected final Double getPrice1() {
        MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;
        if (this.CGLIB$CALLBACK_0 == null) {
            CGLIB$BIND_CALLBACKS(this);
            var10000 = this.CGLIB$CALLBACK_0;
        }

        return var10000 != null ? (Double)var10000.intercept(this, CGLIB$getPrice1$1$Method, CGLIB$emptyArgs, CGLIB$getPrice1$1$Proxy) : super.getPrice1();
    }

    final Double CGLIB$getPrice$2() {
        return super.getPrice();
    }

    public final Double getPrice() {
        MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;
        if (this.CGLIB$CALLBACK_0 == null) {
            CGLIB$BIND_CALLBACKS(this);
            var10000 = this.CGLIB$CALLBACK_0;
        }

        return var10000 != null ? (Double)var10000.intercept(this, CGLIB$getPrice$2$Method, CGLIB$emptyArgs, CGLIB$getPrice$2$Proxy) : super.getPrice();
    }

    final void CGLIB$boost$3(Double var1) {
        super.boost(var1);
    }

    public final void boost(Double var1) {
        MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;
        if (this.CGLIB$CALLBACK_0 == null) {
            CGLIB$BIND_CALLBACKS(this);
            var10000 = this.CGLIB$CALLBACK_0;
        }

        if (var10000 != null) {
            var10000.intercept(this, CGLIB$boost$3$Method, new Object[]{var1}, CGLIB$boost$3$Proxy);
        } else {
            super.boost(var1);
        }
    }

    final Double CGLIB$getApogee$4() {
        return super.getApogee();
    }

    public final Double getApogee() {
        MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;
        if (this.CGLIB$CALLBACK_0 == null) {
            CGLIB$BIND_CALLBACKS(this);
            var10000 = this.CGLIB$CALLBACK_0;
        }

        return var10000 != null ? (Double)var10000.intercept(this, CGLIB$getApogee$4$Method, CGLIB$emptyArgs, CGLIB$getApogee$4$Proxy) : super.getApogee();
    }

    final Object CGLIB$clone$5() throws CloneNotSupportedException {
        return super.clone();
    }

    public final Object clone() throws CloneNotSupportedException {
        MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;
        if (this.CGLIB$CALLBACK_0 == null) {
            CGLIB$BIND_CALLBACKS(this);
            var10000 = this.CGLIB$CALLBACK_0;
        }

        return var10000 != null ? var10000.intercept(this, CGLIB$clone$5$Method, CGLIB$emptyArgs, CGLIB$clone$5$Proxy) : super.clone();
    }

    final boolean CGLIB$equals$6(Object var1) {
        return super.equals(var1);
    }

    public final boolean equals(Object var1) {
        MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;
        if (this.CGLIB$CALLBACK_0 == null) {
            CGLIB$BIND_CALLBACKS(this);
            var10000 = this.CGLIB$CALLBACK_0;
        }

        if (var10000 != null) {
            Object var2 = var10000.intercept(this, CGLIB$equals$6$Method, new Object[]{var1}, CGLIB$equals$6$Proxy);
            return var2 == null ? false : (Boolean)var2;
        } else {
            return super.equals(var1);
        }
    }

    final String CGLIB$toString$7() {
        return super.toString();
    }

    public final String toString() {
        MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;
        if (this.CGLIB$CALLBACK_0 == null) {
            CGLIB$BIND_CALLBACKS(this);
            var10000 = this.CGLIB$CALLBACK_0;
        }

        return var10000 != null ? (String)var10000.intercept(this, CGLIB$toString$7$Method, CGLIB$emptyArgs, CGLIB$toString$7$Proxy) : super.toString();
    }

    final int CGLIB$hashCode$8() {
        return super.hashCode();
    }

    public final int hashCode() {
        MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;
        if (this.CGLIB$CALLBACK_0 == null) {
            CGLIB$BIND_CALLBACKS(this);
            var10000 = this.CGLIB$CALLBACK_0;
        }

        if (var10000 != null) {
            Object var1 = var10000.intercept(this, CGLIB$hashCode$8$Method, CGLIB$emptyArgs, CGLIB$hashCode$8$Proxy);
            return var1 == null ? 0 : ((Number)var1).intValue();
        } else {
            return super.hashCode();
        }
    }

    final RemoteRef CGLIB$getRef$9() {
        return super.getRef();
    }

    public final RemoteRef getRef() {
        MethodInterceptor var10000 = this.CGLIB$CALLBACK_0;
        if (this.CGLIB$CALLBACK_0 == null) {
            CGLIB$BIND_CALLBACKS(this);
            var10000 = this.CGLIB$CALLBACK_0;
        }

        return var10000 != null ? (RemoteRef)var10000.intercept(this, CGLIB$getRef$9$Method, CGLIB$emptyArgs, CGLIB$getRef$9$Proxy) : super.getRef();
    }

    public static MethodProxy CGLIB$findMethodProxy(Signature var0) {
        String var10000 = var0.toString();
        switch(var10000.hashCode()) {
        case -1649328610:
            if (var10000.equals("getPrice()Ljava/lang/Double;")) {
                return CGLIB$getPrice$2$Proxy;
            }
            break;
        case -508378822:
            if (var10000.equals("clone()Ljava/lang/Object;")) {
                return CGLIB$clone$5$Proxy;
            }
            break;
        case -409952759:
            if (var10000.equals("getPrice1()Ljava/lang/Double;")) {
                return CGLIB$getPrice1$1$Proxy;
            }
            break;
        case 12749067:
            if (var10000.equals("getPrice3()Ljava/lang/Double;")) {
                return CGLIB$getPrice3$0$Proxy;
            }
            break;
        case 431984252:
            if (var10000.equals("boost(Ljava/lang/Double;)V")) {
                return CGLIB$boost$3$Proxy;
            }
            break;
        case 522126042:
            if (var10000.equals("getRef()Ljava/rmi/server/RemoteRef;")) {
                return CGLIB$getRef$9$Proxy;
            }
            break;
        case 1666564520:
            if (var10000.equals("getApogee()Ljava/lang/Double;")) {
                return CGLIB$getApogee$4$Proxy;
            }
            break;
        case 1826985398:
            if (var10000.equals("equals(Ljava/lang/Object;)Z")) {
                return CGLIB$equals$6$Proxy;
            }
            break;
        case 1913648695:
            if (var10000.equals("toString()Ljava/lang/String;")) {
                return CGLIB$toString$7$Proxy;
            }
            break;
        case 1984935277:
            if (var10000.equals("hashCode()I")) {
                return CGLIB$hashCode$8$Proxy;
            }
        }

        return null;
    }

    public RocketImplN$$EnhancerByCGLIB$$e9cf4fff() throws RemoteException {
        CGLIB$BIND_CALLBACKS(this);
    }

    public static void CGLIB$SET_THREAD_CALLBACKS(Callback[] var0) {
        CGLIB$THREAD_CALLBACKS.set(var0);
    }

    public static void CGLIB$SET_STATIC_CALLBACKS(Callback[] var0) {
        CGLIB$STATIC_CALLBACKS = var0;
    }

    private static final void CGLIB$BIND_CALLBACKS(Object var0) {
        RocketImplN$$EnhancerByCGLIB$$e9cf4fff var1 = (RocketImplN$$EnhancerByCGLIB$$e9cf4fff)var0;
        if (!var1.CGLIB$BOUND) {
            var1.CGLIB$BOUND = true;
            Object var10000 = CGLIB$THREAD_CALLBACKS.get();
            if (var10000 == null) {
                var10000 = CGLIB$STATIC_CALLBACKS;
                if (CGLIB$STATIC_CALLBACKS == null) {
                    return;
                }
            }

            var1.CGLIB$CALLBACK_0 = (MethodInterceptor)((Callback[])var10000)[0];
        }

    }

    public Object newInstance(Callback[] var1) {
        CGLIB$SET_THREAD_CALLBACKS(var1);
        RocketImplN$$EnhancerByCGLIB$$e9cf4fff var10000 = new RocketImplN$$EnhancerByCGLIB$$e9cf4fff();
        CGLIB$SET_THREAD_CALLBACKS((Callback[])null);
        return var10000;
    }

    public Object newInstance(Callback var1) {
        CGLIB$SET_THREAD_CALLBACKS(new Callback[]{var1});
        RocketImplN$$EnhancerByCGLIB$$e9cf4fff var10000 = new RocketImplN$$EnhancerByCGLIB$$e9cf4fff();
        CGLIB$SET_THREAD_CALLBACKS((Callback[])null);
        return var10000;
    }

    public Object newInstance(Class[] var1, Object[] var2, Callback[] var3) {
        CGLIB$SET_THREAD_CALLBACKS(var3);
        RocketImplN$$EnhancerByCGLIB$$e9cf4fff var10000 = new RocketImplN$$EnhancerByCGLIB$$e9cf4fff;
        switch(var1.length) {
        case 0:
            var10000.<init>();
            CGLIB$SET_THREAD_CALLBACKS((Callback[])null);
            return var10000;
        default:
            throw new IllegalArgumentException("Constructor not found");
        }
    }

    public Callback getCallback(int var1) {
        CGLIB$BIND_CALLBACKS(this);
        MethodInterceptor var10000;
        switch(var1) {
        case 0:
            var10000 = this.CGLIB$CALLBACK_0;
            break;
        default:
            var10000 = null;
        }

        return var10000;
    }

    public void setCallback(int var1, Callback var2) {
        switch(var1) {
        case 0:
            this.CGLIB$CALLBACK_0 = (MethodInterceptor)var2;
        default:
        }
    }

    public Callback[] getCallbacks() {
        CGLIB$BIND_CALLBACKS(this);
        return new Callback[]{this.CGLIB$CALLBACK_0};
    }

    public void setCallbacks(Callback[] var1) {
        this.CGLIB$CALLBACK_0 = (MethodInterceptor)var1[0];
    }

    static {
        CGLIB$STATICHOOK1();
    }
}
```

```java
public class MethodProxy {
	private Signature sig1;
	private Signature sig2;
	private CreateInfo createInfo;
	private final Object initLock = new Object();
	private volatile FastClassInfo fastClassInfo;
  /*
   * c1：被代理对象的Class，c2：代理对象的Class，desc：入参类型（Double --> ()Ljava/lang/Double;），name1:被代理方法名，name2:代理方法名
   */
	public static MethodProxy create(Class c1, Class c2, String desc, String name1, String name2) {
		MethodProxy proxy = new MethodProxy();
		proxy.sig1 = new Signature(name1, desc);
		proxy.sig2 = new Signature(name2, desc);
		proxy.createInfo = new CreateInfo(c1, c2);
		return proxy;
	}

	private void init() {
		if (fastClassInfo == null) {
			synchronized (initLock) {
				if (fastClassInfo == null) {
					CreateInfo ci = createInfo;

					FastClassInfo fci = new FastClassInfo();
					fci.f1 = helper(ci, ci.c1);
					fci.f2 = helper(ci, ci.c2);
					fci.i1 = fci.f1.getIndex(sig1);
					fci.i2 = fci.f2.getIndex(sig2);
					fastClassInfo = fci;
					createInfo = null;
				}
			}
		}
	}


	private static class FastClassInfo {
		FastClass f1;// 被代理类的FastClass
		FastClass f2;// 代理类FastClass
		int i1;// 被代理类的方法签名(index)
		int i2;// 代理类的方法签名
	}


	private static class CreateInfo {

		Class c1;

		Class c2;

		NamingPolicy namingPolicy;

		GeneratorStrategy strategy;

		boolean attemptLoad;

		public CreateInfo(Class c1, Class c2) {
			this.c1 = c1;
			this.c2 = c2;
			AbstractClassGenerator fromEnhancer = AbstractClassGenerator.getCurrent();
			if (fromEnhancer != null) {
				namingPolicy = fromEnhancer.getNamingPolicy();
				strategy = fromEnhancer.getStrategy();
				attemptLoad = fromEnhancer.getAttemptLoad();
			}
		}
	}


	private static FastClass helper(CreateInfo ci, Class type) {
		FastClass.Generator g = new FastClass.Generator();
		g.setType(type);
		// SPRING PATCH BEGIN
		g.setContextClass(type);
		// SPRING PATCH END
		g.setClassLoader(ci.c2.getClassLoader());
		g.setNamingPolicy(ci.namingPolicy);
		g.setStrategy(ci.strategy);
		g.setAttemptLoad(ci.attemptLoad);
		return g.create();
	}

	private MethodProxy() {
	}

	/**
	 * Return the signature of the proxied method.
	 */
	public Signature getSignature() {
		return sig1;
	}

	/**
	 * Return the name of the synthetic method created by CGLIB which is
	 * used by {@link #invokeSuper} to invoke the superclass
	 * (non-intercepted) method implementation. The parameter types are
	 * the same as the proxied method.
	 */
	public String getSuperName() {
		return sig2.getName();
	}

	/**
	 * Return the {@link org.springframework.cglib.reflect.FastClass} method index
	 * for the method used by {@link #invokeSuper}. This index uniquely
	 * identifies the method within the generated proxy, and therefore
	 * can be useful to reference external metadata.
	 * @see #getSuperName
	 */
	public int getSuperIndex() {
		init();
		return fastClassInfo.i2;
	}

	// For testing
	FastClass getFastClass() {
		init();
		return fastClassInfo.f1;
	}

	// For testing
	FastClass getSuperFastClass() {
		init();
		return fastClassInfo.f2;
	}

	/**
	 * Return the <code>MethodProxy</code> used when intercepting the method
	 * matching the given signature.
	 * @param type the class generated by Enhancer
	 * @param sig the signature to match
	 * @return the MethodProxy instance, or null if no applicable matching method is found
	 * @throws IllegalArgumentException if the Class was not created by Enhancer or does not use a MethodInterceptor
	 */
	public static MethodProxy find(Class type, Signature sig) {
		try {
			Method m = type.getDeclaredMethod(MethodInterceptorGenerator.FIND_PROXY_NAME,
					MethodInterceptorGenerator.FIND_PROXY_TYPES);
			return (MethodProxy) m.invoke(null, new Object[]{sig});
		}
		catch (NoSuchMethodException ex) {
			throw new IllegalArgumentException("Class " + type + " does not use a MethodInterceptor");
		}
		catch (IllegalAccessException | InvocationTargetException ex) {
			throw new CodeGenerationException(ex);
		}
	}

	/**
	 * Invoke the original method, on a different object of the same type.
	 * @param obj the compatible object; recursion will result if you use the object passed as the first
	 * argument to the MethodInterceptor (usually not what you want)
	 * @param args the arguments passed to the intercepted method; you may substitute a different
	 * argument array as long as the types are compatible
	 * @throws Throwable the bare exceptions thrown by the called method are passed through
	 * without wrapping in an <code>InvocationTargetException</code>
	 * @see MethodInterceptor#intercept
	 */
	public Object invoke(Object obj, Object[] args) throws Throwable {
		try {
			init();
			FastClassInfo fci = fastClassInfo;
			return fci.f1.invoke(fci.i1, obj, args);
		}
		catch (InvocationTargetException ex) {
			throw ex.getTargetException();
		}
		catch (IllegalArgumentException ex) {
			if (fastClassInfo.i1 < 0)
				throw new IllegalArgumentException("Protected method: " + sig1);
			throw ex;
		}
	}

	/**
	 * Invoke the original (super) method on the specified object.
	 */
	public Object invokeSuper(Object obj, Object[] args) throws Throwable {
		try {
			init();
			FastClassInfo fci = fastClassInfo;
			// 代理类f2，代理类的方法签名
			return fci.f2.invoke(fci.i2, obj, args);
		}
		catch (InvocationTargetException e) {
			throw e.getTargetException();
		}
	}

}
```
CGLIB生成代理类只需要一个目标类和一个回调函数即增强执行逻辑。

JDK动态代理使用的是反射技术，而CGLIB则使用了FastClass构建方法索引+继承的方式访问目标类的方法。

反编译class文件可以发现代理了Object中的equals,toString,hashCode,clone方法。

JDK动态代理实现原理：动态创建代理类并通过指定类加载器加载，然后在创建代理对象时，将InvokerHandler 对象作为构造参数传入，
当调用代理对象时，会调用InvokerHandler.invoker()方法，并真正调用业务对象的相应方法。

