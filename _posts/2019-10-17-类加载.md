---
layout: post
title:  "类加载"
date:   2019-10-17 15:13:34
author: zhangtejun
categories: Java
---
##### 类加载器
JVM中的类加载器（ClassLoader）负责加载来自文件系统，网络或其他来源的类文件。默认使用双亲委派加载，有3中默认类加载器
分别是Bootstrap ClassLoader,Extension ClassLoader和System ClassLoader(Application ClassLoader),每种类加载器都已经确定从哪个位置
加载类文件。

* Bootstrap ClassLoader： 负责加载JDK自带的rt.jar包中的类文件，它是所有类加载器的父加载器。
* Extension ClassLoader：负责加载java扩展类库，即jre/lib/ext目录下或者由java.ext.dirs系统属性指定。
* System ClassLoader：负责从classpath环境变量中加载类文件，通常由-classpath指定或者由JAR中的manifest文件的classpath属性指定。

当第一次访问类中的静态字段时，会触发类加载，并且同一个类只加载一次，静态内部类也是如此，故可以采用此方式创建单例模式。


##### Transaction
Mybatis使用Transaction接口对事务进行抽象，有JdbcTransaction，ManagedTransaction 2个实现，其对象分别由JdbcTransactionFactory，ManagedTransactionFactory
来负责创建。JdbcTransaction 依赖于JDBC Connection进行事务控制和事务提交回滚，

```java
public interface Transaction {
    Connection getConnection() throws SQLException; // 获取数据库链接对象
    void commit() throws SQLException; // 提交事务
    void rollback() throws SQLException;// 回滚事务
    void close() throws SQLException;// 关闭数据库连接
    Integer getTimeout() throws SQLException;// 获取事务超时时间
}

public class JdbcTransaction implements Transaction {
    protected Connection connection; // 事务对应数据库连接
    protected DataSource dataSource; // 数据库连接所属的DataSource
    protected TransactionIsolationLevel level; // 事务隔离级别
    protected boolean autoCommmit; // 是否自动提交
}

public class ManagedTransaction implements Transaction {
    private DataSource dataSource;
    private TransactionIsolationLevel level;
    private Connection connection;
    private final boolean closeConnection;
 }
```
在JdbcTransaction构造函数中会初始化除connection之外的3个字段，connection会延迟初始化，它会在调用getConnection()时通过
dataSource.getConnection()方法初始化，并同时设置autoCommit和事务隔离级别。

ManagedTransaction实现更简单，它的rollback和commit都是空方法，事务的提交和回滚依赖于管理的容器。

mybatis通常和spring集成，事务交与spring容器管理，其实现为SpringManagedTransaction。
```java
public class SpringManagedTransaction implements Transaction {
    private final DataSource dataSource;
    private Connection connection;
    private boolean isConnectionTransactional; //标志该数据库连接对象是否由spring的事务管理器管理
    private boolean autoCommit;

    private void openConnection() throws SQLException {
          // 从spring事务管理器中获取数据库连接对象，实际上，先尝试从事务上下文中获取数据库连接
          // 如果成功则返回该连接，否则从数据源获取并返回该连接
          this.connection = DataSourceUtils.getConnection(this.dataSource);
          // 记录事务是否自动提交，当使用spring来管理事务时，并不会由SpringManagedTransaction
          // 的commit和rollback方法来管理事务
          this.autoCommit = this.connection.getAutoCommit();
          // 记录当前连接是否由spring事务管理器管理
          this.isConnectionTransactional = DataSourceUtils.isConnectionTransactional(this.connection, this.dataSource);
          //...
    }
    public void commit() throws SQLException {
            if (this.connection != null && !this.isConnectionTransactional && !this.autoCommit) {
                //当事务不是由spring事务管理器管理，并且不需要自动提交时，在此处提交事务
                this.connection.commit();
            }
        }
    public void rollback() throws SQLException {
        if (this.connection != null && !this.isConnectionTransactional && !this.autoCommit) {
            //...
            this.connection.rollback();
        }

    }
}
```

##### binding
```java
public class MapperRegistry {
    private final Configuration config; // Configuration对象，mybatis全局唯一配置
    // 记录Mapper接口和对应MapperProxyFactory之间的关系
    private final Map<Class<?>, MapperProxyFactory<?>> knownMappers = new HashMap();
}
```
在需要执行sql时，会先调用MapperRegistry.getMapper()方法获取 实现了Mapper接口的代理对象。例如session.getMapper(BlogMapper.class)
得到的是Mybatis通过JDK动态代理为BlogMapper接口生成的代理对象。

MapperProxyFactory主要负责创建代理对象，
```java
public T newInstance(SqlSession sqlSession) {
    // 每次调用产生新的MapperProxy对象
    MapperProxy<T> mapperProxy = new MapperProxy(sqlSession, this.mapperInterface, this.methodCache);
    return this.newInstance(mapperProxy);
}

public class MapperProxy<T> implements InvocationHandler, Serializable {
    private final SqlSession sqlSession; // 记录关联的sqlSession对象
    private final Class<T> mapperInterface; // Mapper接口对应的class对象
    // 用于缓存MapperMethod对象，MapperMethod对象会完成参数转换和SQL语句的执行功能
    private final Map<Method, MapperMethod> methodCache;

    // 代理对象执行的主要逻辑
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            try {
                // 如果目标方法继承至Object，直接调用目标方法（）
                if (Object.class.equals(method.getDeclaringClass())) {
                    return method.invoke(this, args);
                }

                if (this.isDefaultMethod(method)) {
                    // java 7以上版本支持动态类型语言
                    return this.invokeDefaultMethod(proxy, method, args);
                }
            } catch (Throwable var5) {
                throw ExceptionUtil.unwrapThrowable(var5);
            }
            // 从缓存中获取MapperMethod，没有就创建
            MapperMethod mapperMethod = this.cachedMapperMethod(method);
            // 执行SQL语句
            return mapperMethod.execute(this.sqlSession, args);
        }
}
// MapperMethod 封装了Mapper接口中对应的方法信息，以及对应的SQL信息
public class MapperMethod {
    private final MapperMethod.SqlCommand command; // 记录SQL语句的名称和类型
    private final MapperMethod.MethodSignature method;// Mapper接口中对应的方法相关信息
    // 核心方法。根据sql类型完成数据库的操作
    public Object execute(SqlSession sqlSession, Object[] args) {
          Object param;
          Object result;
          switch(this.command.getType()) {
          case INSERT:
              param = this.method.convertArgsToSqlCommandParam(args);
              // INSERT/UPDATE/DELETE 由sqlSession返回的都是int值，需要通过rowCountResult方法将其转换成Mapper接口方法中对应的返回值
              result = this.rowCountResult(sqlSession.insert(this.command.getName(), param));
              break;
          case UPDATE:
              param = this.method.convertArgsToSqlCommandParam(args);
              result = this.rowCountResult(sqlSession.update(this.command.getName(), param));
              break;
          case DELETE:
              param = this.method.convertArgsToSqlCommandParam(args);
              result = this.rowCountResult(sqlSession.delete(this.command.getName(), param));
              break;
          case SELECT:
              if (this.method.returnsVoid() && this.method.hasResultHandler()) {
                  this.executeWithResultHandler(sqlSession, args);
                  result = null;
              } else if (this.method.returnsMany()) {
                  result = this.executeForMany(sqlSession, args);
              } else if (this.method.returnsMap()) {
                  result = this.executeForMap(sqlSession, args);
              } else if (this.method.returnsCursor()) {
                  result = this.executeForCursor(sqlSession, args);
              } else {
                  param = this.method.convertArgsToSqlCommandParam(args);
                  result = sqlSession.selectOne(this.command.getName(), param);
              }
              break;
          case FLUSH:
              result = sqlSession.flushStatements();
              break;
          default:
              throw new BindingException("Unknown execution method for: " + this.command.getName());
          }

          if (result == null && this.method.getReturnType().isPrimitive() && !this.method.returnsVoid()) {
              throw new BindingException("Mapper method '" + this.command.getName() + " attempted to return null from a method with a primitive return type (" + this.method.getReturnType() + ").");
          } else {
              return result;
          }
      }
 }

 public static class MethodSignature {
   // 解析Mapper接口参数列表，参数名称可以使用@Param注解指定，如果没有指定该注解，则使用参数
   // 索引作为其名称
   private final ParamNameResolver paramNameResolver;
}
```


#### spring 事务
spring事务处理是通过AOP功能来实现声明式事务处理的，比如事务的配置和读取，事务对象的抽象等。

* 声明式事务：结合ioc容器和TransactionProxyFactoryBean对事务管理进行配置，


声明式事务是用事务参数来定义的。一个事务参数就是事务策略应该如何应用到某个方法的一段描述。

5个事务参数：
* 传播行为：用于定义客户端和被调用方法的事务边界。spring定义了7种传播行为，由TransactionDefinition接口常量定义。
* 隔离级别：定义一个事务可能受其他并发事务活动影响的程度。5种隔离级别，由TransactionDefinition接口常量定义。
* 是否只读：是否为一个只读事务，如果一个事务只读后端数据库进行读操作，那么数据库可能会利用事务的可读属性，进行一些优化措施
            ，优化措施由后端数据库实施，因此只有对于那些具有可能启动一个新事务的传播行为的方法来说，将事务设置为读才有意义。
            比如Hibernate，如何把一个事务设置为只读，将使Hibernate的flush模式被设置为FLUSH_NEVER。这就告诉Hibernate避免和数据库进行不必要的
            对象同步，从而把所有更新延迟到事务结束。
* 事务超时：一个应用程序很好的运行，它的事务执行时间不能太长，长时间运行的事务会占用数据库资源，设置超时时间，可以使事务在特定数秒后进行自动回滚
            默认情况下事务只在出现运行时异常（runtime Exception）时回滚，出现受阻异常（check Exception）不回滚。

在spring2.0以前，声明式事务通过TransactionProxyFactoryBean 代理POJO来完成。
```xml
<bean id="newsDaoTransProxy"
    class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean">
    <!-- 1. 配置事务管理器： 为事务代理工厂Bean注入事务管理器 -->
    <property name="transactionManager" ref="transactionManager" />
    <!-- 2. 装配事务目标： 要在哪个Bean上面创建事务代理对象 -->
    <property name="target" ref="newsDao" />
    <!-- 3. 配置事务规则，边界： 指定事务属性 -->
    <property name="transactionAttributes">
        <props>
            <prop key="add*">PROPAGATION_REQUIRED</prop>
            <prop key="*">PROPAGATION_SUPPORTS,readOnly</prop>
            <prop key="*">传播行为,隔离级别(可选),是否只读(可选),回滚规则(可选)</prop>
            <prop key="*">PROPAGATION_SUPPORTS,ISOLATION,readOnly,-Exception,+Exception</prop>
        </props>
    </property>
</bean>
// 调用
NewsDao dao = (NewsDao)applicationContext.getBean("newsDaoTransProxy"，NewsDao.class);
dao.insert("");
```

以上实例为TransactionProxyFactoryBean代理单个bean，如何代理多个bean？ 可以使用事务代理模板

**事务代理模板**
1. 创建一个抽象TransactionProxyFactoryBean声明
```
<bean id="txProxyTemplate"
    class="org.springframework.transaction.interceptor.TransactionProxyFactoryBean" abstract=true>
    <!-- 1. 配置事务管理器： 为事务代理工厂Bean注入事务管理器 -->
    <property name="transactionManager" ref="transactionManager" />
    <!-- 2. 配置事务规则，边界： 指定事务属性 -->
    <property name="transactionAttributes">
        <props>
            <prop key="add*">PROPAGATION_REQUIRED</prop>
            <prop key="*">PROPAGATION_SUPPORTS,readOnly</prop>
            <prop key="*">传播行为,隔离级别(可选),是否只读(可选),回滚规则(可选)</prop>
            <prop key="*">PROPAGATION_SUPPORTS,ISOLATION,readOnly,-Exception,+Exception</prop>
        </props>
    </property>
</bean>
```
2. 把txProxyTemplate作为相应bean的父类
```
<bean id="newsDaoTrans" parent="txProxyTemplate">
      <!--装配事务目标： 要在哪个Bean上面创建事务代理对象 -->
      <property name="target" ref="newsDao" />
</bean>
```

**在spring2.0中的配置**
使用TransactionProxyFactoryBean 会导致很长的xml配置文件，spring2.0为声明式事务提供了一些新的配置元素，位于tx命名空间，也包括aop的名称。

1. 使用`<tx:advice>`声明事务性策略
```xml
<tx:advice id="txAdvice" transaction-manager="txManager">
  <tx:attributes>
    <tx:method name="add*" propagation="REQUIRED">
    <tx:method name="*" propagation="REQUIRED" read-only=true>
  <tx:attributes>
</tx:advice>
```
2. 定义通知器
```
<aop:config>
  <aop:advisor pointcut="execuion(* *..newsDao.*(..))" advice-ref="txAdvice"/>
</aop:config>
```
3. 声明事务管理器
```
<tx:advice id="txAdvice" transaction-manager="txManager">
  <tx:attributes>
    <tx:method name="add*" propagation="REQUIRED">
    <tx:method name="*" propagation="REQUIRED" read-only=true>
  <tx:attributes>
</tx:advice>
```

**注解事务**
声明注解事务并指定一个特定的transactionManager
```
<tx:annotation-driven transaction-manager="txManager">
```
`<tx:annotation-driven>`告诉spring在类层面或者方法层面检查应用程序上下文中的所有bean,并寻找被@Transaction 注解的Bean。

```java
@Service
@Transactional(propagation = Propagation.SUPPORTS,readOnly = true)
public class SysUserServiceImpl implements SysUserService {
    @Override
    @Transactional(propagation = Propagation.REQUIRED,readOnly = false)
    public void addUser(SysUser sysUser) {

    }
}
```
在SysUserServiceImpl类上注解，说明该类的所有方法都支持事务并且是可读的，在方法addUser增加注释，说明这个方法要求一个事务上下文。
@Transactional同样可注解到SysUserService接口上。


##### 事务管理器
不管是JPA还是JDBC等都实现自接口 PlatformTransactionManager。 spring boot 框架会默认注入 DataSourceTransactionManager 实例。
如果你添加的是 spring-boot-starter-data-jpa 依赖，框架会默认注入 JpaTransactionManager 实例。

DefaultTransactionDefinition类是一个默认的TransactionDefinition实现，它的传播行为是
PROPAGATION_REQUIRED(如果当前没事务，则创建一个，否则加入到当前事务中)，隔离级别是数据库默认级别。

如果我们手动配置了事务管理器，Spring boot就不会再为我们自动配置事务管理器。
如果要使用多个事务管理器的话，那么需要手动配置多个。Spring给我们提供了一个
TransactionManagementConfigurer接口，该接口只有一个方法返回PlatformTransactionManager。其中返回的PlatformTransactionManager
就表示这是默认的事务处理器，这样在Transactional注解上就不需要声明是使用哪个事务管理器了。
```
  @Resource(name="txManager2")
  private PlatformTransactionManager txManager2;

  // 手动创建事务管理器1 datasource框架会自动注入
  @Bean(name = "txManager1")
  public PlatformTransactionManager txManager(DataSource dataSource) {
    return new DataSourceTransactionManager(dataSource);
  }

  // 创建事务管理器2
  @Bean(name = "txManager2")
  public PlatformTransactionManager txManager2(EntityManagerFactory factory) {
    return new JpaTransactionManager(factory);
  }

  // 实现接口 TransactionManagementConfigurer 方法，其返回值代表在拥有多个事务管理器的情况下默认使用的事务管理器
  @Override
  public PlatformTransactionManager annotationDrivenTransactionManager() {
    return txManager2;
  }
```

##### 注解@EnableTransactionManagement
```
@Target({ElementType.TYPE})
@Retention(RetentionPolicy.RUNTIME)
@Documented
@Import({TransactionManagementConfigurationSelector.class})
public @interface EnableTransactionManagement {
    boolean proxyTargetClass() default false;
    AdviceMode mode() default AdviceMode.PROXY;
    int order() default 2147483647;
}
```

**基于proxy模式解析类**
TransactionManagementConfigurationSelector
总共注入了4个类到Spring中
* 在AutoProxyRegistrar中添加：InfrastructureAdvisorAutoProxyCreator
* 在ProxyTransactionManagementConfiguration中添加：BeanFactoryTransactionAttributeSourceAdvisor/TransactionAttributeSource/TransactionInterceptor

```java
@Configuration
public class ProxyTransactionManagementConfiguration extends AbstractTransactionManagementConfiguration {
    public ProxyTransactionManagementConfiguration() {
    }
    @Bean(name = {"org.springframework.transaction.config.internalTransactionAdvisor"})
    @Role(2)
    public BeanFactoryTransactionAttributeSourceAdvisor transactionAdvisor() {
        // 创建BeanFactoryTransactionAttributeSourceAdvisor
        BeanFactoryTransactionAttributeSourceAdvisor advisor = new BeanFactoryTransactionAttributeSourceAdvisor();
        // 设置transactionAttributeSource
        advisor.setTransactionAttributeSource(this.transactionAttributeSource());
        // 设置拦截器
        advisor.setAdvice(this.transactionInterceptor());
        if (this.enableTx != null) {
            advisor.setOrder((Integer)this.enableTx.getNumber("order"));
        }
        return advisor;
    }

    @Bean
    @Role(2)
    public TransactionAttributeSource transactionAttributeSource() {
        return new AnnotationTransactionAttributeSource();
    }

    @Bean
    @Role(2)
    public TransactionInterceptor transactionInterceptor() {
        // 创建事务拦截器
        TransactionInterceptor interceptor = new TransactionInterceptor();
        interceptor.setTransactionAttributeSource(this.transactionAttributeSource());
        if (this.txManager != null) {
            // 设置事务管理器
            interceptor.setTransactionManager(this.txManager);
        }
        return interceptor;
    }
}
```

**基于aspectj模式的解析类**
```java
@Configuration
public class AspectJTransactionManagementConfiguration extends AbstractTransactionManagementConfiguration {
   @Bean(name = TransactionManagementConfigUtils.TRANSACTION_ASPECT_BEAN_NAME)
   @Role(BeanDefinition.ROLE_INFRASTRUCTURE)
   public AnnotationTransactionAspect transactionAspect() {
      //创建事务注解切面
      AnnotationTransactionAspect txAspect = AnnotationTransactionAspect.aspectOf();
      //设置事务管理器
      if (this.txManager != null) {
         txAspect.setTransactionManager(this.txManager);
      }
      return txAspect;
   }
```

**internalAutoProxyCreator（AutoProxyRegistrar）**
参照缓存一文

**ProxyTransactionManagementConfiguration（事务核心bean的构建）**
`AnnotationTransactionAttributeSource`和`TransactionInterceptor`这两个bean又都注册到了`BeanFactoryTransactionAttributeSourceAdvisor`中。

**代理的实现核心拦截器**
```
// 1.
public Object invoke(MethodInvocation invocation) throws Throwable {
		Class<?> targetClass = (invocation.getThis() != null ? AopUtils.getTargetClass(invocation.getThis()) : null);
		return invokeWithinTransaction(invocation.getMethod(), targetClass, invocation::proceed);
	}
// 2.TransactionAspectSupport
protected Object invokeWithinTransaction(Method method, @Nullable Class<?> targetClass,
			final InvocationCallback invocation) throws Throwable {

		// 获取 @Transactional 注解事务属性
		TransactionAttributeSource tas = getTransactionAttributeSource();
		// 根据方法和class获取事务属性
		final TransactionAttribute txAttr = (tas != null ? tas.getTransactionAttribute(method, targetClass) : null);
		// 获取事务管理器 defaultTransactionManager = this.beanFactory.getBean(PlatformTransactionManager.class);
		final PlatformTransactionManager tm = determineTransactionManager(txAttr);
		// 获取需要执行的目标方法 com.example.demo.service.impl.SysUserServiceImpl.addUser
		final String joinpointIdentification = methodIdentification(method, targetClass, txAttr);
    //声明式事务
		if (txAttr == null || !(tm instanceof CallbackPreferringPlatformTransactionManager)) {
			// 1. 创建TransactionInfo
			TransactionInfo txInfo = createTransactionIfNecessary(tm, txAttr, joinpointIdentification);
			Object retVal;
			try {
			  // 2. 调用执行链
				retVal = invocation.proceedWithInvocation();
			}
			catch (Throwable ex) {
				// 3. 异常回滚
				completeTransactionAfterThrowing(txInfo, ex);
				throw ex;
			}
			finally {
			  // 4. 清除事务信息(重置线程局部变量的事务信息)
				cleanupTransactionInfo(txInfo);
			}
			// 5. 提交事务
			commitTransactionAfterReturning(txInfo);
			return retVal;
		}

		else {
			final ThrowableHolder throwableHolder = new ThrowableHolder();

			// It's a CallbackPreferringPlatformTransactionManager: pass a TransactionCallback in.
			try {
				Object result = ((CallbackPreferringPlatformTransactionManager) tm).execute(txAttr, status -> {
					TransactionInfo txInfo = prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);
					try {
						return invocation.proceedWithInvocation();
					}
					catch (Throwable ex) {
						if (txAttr.rollbackOn(ex)) {
							// A RuntimeException: will lead to a rollback.
							if (ex instanceof RuntimeException) {
								throw (RuntimeException) ex;
							}
							else {
								throw new ThrowableHolderException(ex);
							}
						}
						else {
							// A normal return value: will lead to a commit.
							throwableHolder.throwable = ex;
							return null;
						}
					}
					finally {
						cleanupTransactionInfo(txInfo);
					}
				});

				// Check result state: It might indicate a Throwable to rethrow.
				if (throwableHolder.throwable != null) {
					throw throwableHolder.throwable;
				}
				return result;
			}
			catch (ThrowableHolderException ex) {
				throw ex.getCause();
			}
			catch (TransactionSystemException ex2) {
				if (throwableHolder.throwable != null) {
					logger.error("Application exception overridden by commit exception", throwableHolder.throwable);
					ex2.initApplicationException(throwableHolder.throwable);
				}
				throw ex2;
			}
			catch (Throwable ex2) {
				if (throwableHolder.throwable != null) {
					logger.error("Application exception overridden by commit exception", throwableHolder.throwable);
				}
				throw ex2;
			}
		}
	}

// 创建事务
protected TransactionInfo createTransactionIfNecessary(@Nullable PlatformTransactionManager tm,
			@Nullable TransactionAttribute txAttr, final String joinpointIdentification) {
		//如果事务没有指定名称则使用方法标识
		if (txAttr != null && txAttr.getName() == null) {
			txAttr = new DelegatingTransactionAttribute(txAttr) {
				@Override
				public String getName() {
					return joinpointIdentification;
				}
			};
		}

		TransactionStatus status = null;
		if (txAttr != null) {
			if (tm != null) {
			  //1. 获取事务
				status = tm.getTransaction(txAttr);
			}
			else {
				if (logger.isDebugEnabled()) {
					logger.debug("Skipping transactional joinpoint [" + joinpointIdentification +
							"] because no transaction manager has been configured");
				}
			}
		}
		// 2. 构建事务信
		return prepareTransactionInfo(tm, txAttr, joinpointIdentification, status);
	}

// 获取事务
public final TransactionStatus getTransaction(@Nullable TransactionDefinition definition) throws TransactionException {
		// //1. 获取事务
		Object transaction = doGetTransaction();
		boolean debugEnabled = logger.isDebugEnabled();
		if (definition == null) {
			// Use defaults if no transaction definition given.
			definition = new DefaultTransactionDefinition();
		}
    //2. 判断当前线程是否存在事务
		if (isExistingTransaction(transaction)) {
		  // 存在事务则使用嵌套事务处理
			return handleExistingTransaction(definition, transaction, debugEnabled);
		}

		// 事务超时
		if (definition.getTimeout() < TransactionDefinition.TIMEOUT_DEFAULT) {
			throw new InvalidTimeoutException("Invalid transaction timeout", definition.getTimeout());
		}

		// 如果当前没有事务，但是事务的传播行为被定义为PROPAGATION_MANDATORY，则抛出异常
		if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_MANDATORY) {
			throw new IllegalTransactionStateException(
					"No existing transaction found for transaction marked with propagation 'mandatory'");
		}// 当事务的传播行为需要新建事务时的处理
		else if (definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRED ||
				definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_REQUIRES_NEW ||
				definition.getPropagationBehavior() == TransactionDefinition.PROPAGATION_NESTED) {
			SuspendedResourcesHolder suspendedResources = suspend(null);
			if (debugEnabled) {
				logger.debug("Creating new transaction with name [" + definition.getName() + "]: " + definition);
			}
			try {
				boolean newSynchronization = (getTransactionSynchronization() != SYNCHRONIZATION_NEVER);
				DefaultTransactionStatus status = newTransactionStatus(
						definition, transaction, true, newSynchronization, debugEnabled, suspendedResources);
				doBegin(transaction, definition);//3. 准备事务
				prepareSynchronization(status, definition);//4. 记录事务状态
				return status;
			}
			catch (RuntimeException | Error ex) {
				resume(null, suspendedResources);
				throw ex;
			}
		}
		else {
			// 创建空事务
			if (definition.getIsolationLevel() != TransactionDefinition.ISOLATION_DEFAULT && logger.isWarnEnabled()) {
				logger.warn("Custom isolation level specified but no actual transaction initiated; " +
						"isolation level will effectively be ignored: " + definition);
			}
			boolean newSynchronization = (getTransactionSynchronization() == SYNCHRONIZATION_ALWAYS);
			return prepareTransactionStatus(definition, null, true, newSynchronization, debugEnabled, null);
		}
	}
```


##### Spring框架通过使用以下方法提供了两种编程事务管理方法：
* TransactionTemplate
```
// TransactionCallback()可以返回一个值,TransactionCallbackWithoutResult没有返回值。
Object execute = transactionTemplate.execute((transactionStatus) -> {
    try {
        sysUserMapper.insert(sysUser);
        sysUserMapper.insert(sysUser);
    } catch (Exception e) {
        transactionStatus.setRollbackOnly();
    }
    return null;
});
```

* A PlatformTransactionManager implementation directly
```
DefaultTransactionDefinition def = new DefaultTransactionDefinition();
// explicitly setting the transaction name is something that can be done only programmatically
def.setName("SomeTxName");
def.setPropagationBehavior(TransactionDefinition.PROPAGATION_REQUIRED);

TransactionStatus status = txManager.getTransaction(def);
try {
    // execute your business logic here
}
catch (MyException ex) {
    txManager.rollback(status);
    throw ex;
}
txManager.commit(status);
```

**事务绑定事件**
从Spring4.2开始，事件的侦听器可以绑定到事务的一个阶段。

**事务提交成功后进行异步操作**
Spring它非常友好的提供了两种解决方案来处理：
* 事务同步管理器TransactionSynchronizationManager
* @TransactionalEventListener注解（需要Spring4.2+）
```
TransactionSynchronizationManager.registerSynchronization(new TransactionSynchronizationAdapter() {
        @Override
        public void afterCommit() {
            System.out.println("send email after transaction commit...");
        }
});

//
@Transactional(propagation = Propagation.SUPPORTS,readOnly = true)
public class SysUserServiceImpl implements SysUserService {
    @Autowired
    private SysUserMapper sysUserMapper;
    @Autowired
    private ApplicationEventPublisher applicationEventPublisher;
    @Override
    @Transactional()
    public void addUser(SysUser sysUser) {
        sysUserMapper.insert(sysUser);
        sysUserMapper.insert(sysUser);
        // 1. 发布一个自定义的事件
        applicationEventPublisher.publishEvent(new MyAfterTransactionEvent("事务相关的事件，事务操作","msg"));
    }
}
//2. Listener
@Slf4j
@Component
public   class MyTransactionListener {
    @TransactionalEventListener(phase = TransactionPhase.AFTER_COMPLETION)
    private void onHelloEvent(MyAfterTransactionEvent event) {
        Object source = event.getSource();
        Object msg = event.getMsg();
        log.info(source + "@@@@" + msg.toString());
    }
}
// 3. 定义一个事件，继承自ApplicationEvent
@Data
public class MyAfterTransactionEvent extends ApplicationEvent {
    protected   Object msg;

    public MyAfterTransactionEvent(Object source, String msg) {
        super(source);
        this.msg = msg;
    }
}
```


spring的TransactionInterceptor配置什么时候被启动并成为Advisor通知器的一部分？

方法createMainInterceptor()在IOC容器完成依赖注入时，通过Initializbean方法被调用，该类实现了InitializingBean接口
在其方法afterPropertiesSet()中完成ProxyFactory生成代理对象，配置通知器，设置代理接口等

```
public void afterPropertiesSet() {
		if (this.target == null) {
			throw new IllegalArgumentException("Property 'target' is required");
		}
		if (this.target instanceof String) {
			throw new IllegalArgumentException("'target' needs to be a bean reference, not a bean name as value");
		}
		if (this.proxyClassLoader == null) {
			this.proxyClassLoader = ClassUtils.getDefaultClassLoader();
		}
		// TransactionProxyFactoryBean使用ProxyFactory完成AOP功能，ProxyFactory提供proxy对象
		// 并将TransactionInterceptor设置为target方法调用的拦截器
		ProxyFactory proxyFactory = new ProxyFactory();

		if (this.preInterceptors != null) {
			for (Object interceptor : this.preInterceptors) {
				proxyFactory.addAdvisor(this.advisorAdapterRegistry.wrap(interceptor));
			}
		}

		// spring在这里添加通知器,可以加入2种通知器：DefaultPointcutAdvisor 和TransactionAttributeSourceAdvisor
		proxyFactory.addAdvisor(this.advisorAdapterRegistry.wrap(createMainInterceptor()));

		if (this.postInterceptors != null) {
			for (Object interceptor : this.postInterceptors) {
				proxyFactory.addAdvisor(this.advisorAdapterRegistry.wrap(interceptor));
			}
		}

		proxyFactory.copyFrom(this);
		// 创建AOP的目标源
		TargetSource targetSource = createTargetSource(this.target);
		proxyFactory.setTargetSource(targetSource);

		if (this.proxyInterfaces != null) {
			proxyFactory.setInterfaces(this.proxyInterfaces);
		}
		else if (!isProxyTargetClass()) {
			// Rely on AOP infrastructure to tell us what interfaces to proxy.
			Class<?> targetClass = targetSource.getTargetClass();
			if (targetClass != null) {
				proxyFactory.setInterfaces(ClassUtils.getAllInterfacesForClass(targetClass, this.proxyClassLoader));
			}
		}

		postProcessProxyFactory(proxyFactory);

		this.proxy = proxyFactory.getProxy(this.proxyClassLoader);
	}
```
