---
layout: post
title:  "类加载"
date:   2019-10-17 15:13:34
author: zhangtejun
categories: Java
---
##### 类加载器
JVM中的类加载器（ClassLoader）负责加载来自文件系统，网络或其他来源的类文件。默认使用双亲委派加载，有3中默认类加载器
分别是Bootstrap ClassLoader,Extension ClassLoader和System ClassLoader(Application ClassLoader),每种类加载器都已经确定从哪个位置
加载类文件。

* Bootstrap ClassLoader： 负责加载JDK自带的rt.jar包中的类文件，它是所有类加载器的父加载器。
* Extension ClassLoader：负责加载java扩展类库，即jre/lib/ext目录下或者由java.ext.dirs系统属性指定。
* System ClassLoader：负责从classpath环境变量中加载类文件，通常由-classpath指定或者由JAR中的manifest文件的classpath属性指定。

当第一次访问类中的静态字段时，会触发类加载，并且同一个类只加载一次，静态内部类也是如此，故可以采用此方式创建单例模式。


##### Transaction
Mybatis使用Transaction接口对事务进行抽象，有JdbcTransaction，ManagedTransaction 2个实现，其对象分别由JdbcTransactionFactory，ManagedTransactionFactory
来负责创建。JdbcTransaction 依赖于JDBC Connection进行事务控制和事务提交回滚，

```java
public interface Transaction {
    Connection getConnection() throws SQLException; // 获取数据库链接对象
    void commit() throws SQLException; // 提交事务
    void rollback() throws SQLException;// 回滚事务
    void close() throws SQLException;// 关闭数据库连接
    Integer getTimeout() throws SQLException;// 获取事务超时时间
}

public class JdbcTransaction implements Transaction {
    protected Connection connection; // 事务对应数据库连接
    protected DataSource dataSource; // 数据库连接所属的DataSource
    protected TransactionIsolationLevel level; // 事务隔离级别
    protected boolean autoCommmit; // 是否自动提交
}

public class ManagedTransaction implements Transaction {
    private DataSource dataSource;
    private TransactionIsolationLevel level;
    private Connection connection;
    private final boolean closeConnection;
 }
```
在JdbcTransaction构造函数中会初始化除connection之外的3个字段，connection会延迟初始化，它会在调用getConnection()时通过
dataSource.getConnection()方法初始化，并同时设置autoCommit和事务隔离级别。

ManagedTransaction实现更简单，它的rollback和commit都是空方法，事务的提交和回滚依赖于管理的容器。

mybatis通常和spring集成，事务交与spring容器管理，其实现为SpringManagedTransaction。


##### binding
```java
public class MapperRegistry {
    private final Configuration config; // Configuration对象，mybatis全局唯一配置
    // 记录Mapper接口和对应MapperProxyFactory之间的关系
    private final Map<Class<?>, MapperProxyFactory<?>> knownMappers = new HashMap();
}
```
在需要执行sql时，会先调用MapperRegistry.getMapper()方法获取 实现了Mapper接口的代理对象。例如session.getMapper(BlogMapper.class)
得到的是Mybatis通过JDK动态代理为BlogMapper接口生成的代理对象。

MapperProxyFactory主要负责创建代理对象，
```java
public T newInstance(SqlSession sqlSession) {
    // 每次调用产生新的MapperProxy对象
    MapperProxy<T> mapperProxy = new MapperProxy(sqlSession, this.mapperInterface, this.methodCache);
    return this.newInstance(mapperProxy);
}

public class MapperProxy<T> implements InvocationHandler, Serializable {
    private final SqlSession sqlSession; // 记录关联的sqlSession对象
    private final Class<T> mapperInterface; // Mapper接口对应的class对象
    // 用于缓存MapperMethod对象，MapperMethod对象会完成参数转换和SQL语句的执行功能
    private final Map<Method, MapperMethod> methodCache;

    // 代理对象执行的主要逻辑
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
            try {
                // 如果目标方法继承至Object，直接调用目标方法（）
                if (Object.class.equals(method.getDeclaringClass())) {
                    return method.invoke(this, args);
                }

                if (this.isDefaultMethod(method)) {
                    // java 7以上版本支持动态类型语言
                    return this.invokeDefaultMethod(proxy, method, args);
                }
            } catch (Throwable var5) {
                throw ExceptionUtil.unwrapThrowable(var5);
            }
            // 从缓存中获取MapperMethod，没有就创建
            MapperMethod mapperMethod = this.cachedMapperMethod(method);
            // 执行SQL语句
            return mapperMethod.execute(this.sqlSession, args);
        }
}
// MapperMethod 封装了Mapper接口中对应的方法信息，以及对应的SQL信息
public class MapperMethod {
    private final MapperMethod.SqlCommand command; // 记录SQL语句的名称和类型
    private final MapperMethod.MethodSignature method;// Mapper接口中对应的方法相关信息
    // 核心方法。根据sql类型完成数据库的操作
    public Object execute(SqlSession sqlSession, Object[] args) {
          Object param;
          Object result;
          switch(this.command.getType()) {
          case INSERT:
              param = this.method.convertArgsToSqlCommandParam(args);
              // INSERT/UPDATE/DELETE 由sqlSession返回的都是int值，需要通过rowCountResult方法将其转换成Mapper接口方法中对应的返回值
              result = this.rowCountResult(sqlSession.insert(this.command.getName(), param));
              break;
          case UPDATE:
              param = this.method.convertArgsToSqlCommandParam(args);
              result = this.rowCountResult(sqlSession.update(this.command.getName(), param));
              break;
          case DELETE:
              param = this.method.convertArgsToSqlCommandParam(args);
              result = this.rowCountResult(sqlSession.delete(this.command.getName(), param));
              break;
          case SELECT:
              if (this.method.returnsVoid() && this.method.hasResultHandler()) {
                  this.executeWithResultHandler(sqlSession, args);
                  result = null;
              } else if (this.method.returnsMany()) {
                  result = this.executeForMany(sqlSession, args);
              } else if (this.method.returnsMap()) {
                  result = this.executeForMap(sqlSession, args);
              } else if (this.method.returnsCursor()) {
                  result = this.executeForCursor(sqlSession, args);
              } else {
                  param = this.method.convertArgsToSqlCommandParam(args);
                  result = sqlSession.selectOne(this.command.getName(), param);
              }
              break;
          case FLUSH:
              result = sqlSession.flushStatements();
              break;
          default:
              throw new BindingException("Unknown execution method for: " + this.command.getName());
          }

          if (result == null && this.method.getReturnType().isPrimitive() && !this.method.returnsVoid()) {
              throw new BindingException("Mapper method '" + this.command.getName() + " attempted to return null from a method with a primitive return type (" + this.method.getReturnType() + ").");
          } else {
              return result;
          }
      }
 }

 public static class MethodSignature {
   // 解析Mapper接口参数列表，参数名称可以使用@Param注解指定，如果没有指定该注解，则使用参数
   // 索引作为其名称
   private final ParamNameResolver paramNameResolver;
}
```
