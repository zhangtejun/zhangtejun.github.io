<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Zhangtejun.GitHub.io by zhangtejun</title>
    <link rel="stylesheet" href="../stylesheets/styles.css">
    <link rel="stylesheet" href="../stylesheets/github-dark.css">
    <script src="../javascripts/jquery.min.js"></script>
    <script src="../javascripts/respond.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <!--[if lt IE 8]>
    <link rel="stylesheet" href="stylesheets/ie.css">
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  </head>
  <body>
      <div id="header">
        <nav>
          <li class="fork"><a href="https://github.com/zhangtejun">View On GitHub</a></li>
        </nav>
      </div><!-- end header -->

    <div class="wrapper">
        <section>
        <div style="float: left;overflow: hidden;width: 15%;margin-top: 70px;padding: 20px 20px;max-width: 250px;">
          <div>目录</div>
          <div style="list-style-type:none!important;">        
              <li>1，<a href="">README</a></li>
              <li><a href="">1，README</a></li>           
          </div>
        </div>
<div style="overflow: hidden;padding-left: 20px;width: 60%">

        <div id="title">
          <p>Java虚拟机学习（2）：垃圾收集算法</p>
          <hr>
          <span class="credits left">Project maintained by <a href="https://github.com/zhangtejun">zhangtejun</a></span>
          <span class="credits right">Hosted on GitHub Pages &mdash; Theme by <a href="https://twitter.com/michigangraham">mattgraham</a></span>
        </div>
        <h3>跟踪收集器</h3><p>跟踪收集器采用的为集中式的管理方式，全局记录对象之间的引用状态，执行时从一些列GC  Roots的对象做为起点，从这些节点向下开始进行搜索所有的引用链，当一个对象到GC  Roots 没有任何引用链时，则证明此对象是不可用的。</p><p>下图中，对象Object6、Object7、Object8虽然互相引用，但他们的GC Roots是不可到达的，所以它们将会被判定为是可回收的对象。</p>
        <img src="../images/class2_1.jpg">
        <p>可作为GC Roots 的对象包括：</p><p>虚拟机栈(栈帧中的本地变量表)中的引用对象。 方法区中的类静态属性引用的对象 方法区中的常量引用的对象 本地方法栈中JNI的引用对象。</p><p>主要有复制、标记清除、标记压缩三种实现算法。</p><h3>1. 标记 – 清除算法 </h3><p>标记清除算法是最基础的收集算法，其他收集算法都是基于这种思想。标记清除算法分为“标记”和“清除”两个阶段：首先标记出需要回收的对象，标记完成之后统一清除对象。</p><p>它的主要缺点：</p><p>①.标记和清除过程效率不高</p><p>②.标记清除之后会产生大量不连续的内存碎片。</p>
        <img src="../images/class2_2.jpg">
        <img src="../images/class2_3.jpg">
        <h3>2. 复制算法</h3><p>它将可用内存容量划分为大小相等的两块，每次只使用其中的一块。当这一块用完之后，就将还存活的对象复制到另外一块上面，然后在把已使用过的内存空间一次清理掉。这样使得每次都是对其中的一块进行内存回收，不会产生碎片等情况，只要移动堆订的指针，按顺序分配内存即可，实现简单，运行高效。</p><p>主要缺点：</p><p>内存缩小为原来的一半。</p>
        <img src="../images/class2_4.jpg">
        <img src="../images/class2_5.jpg">
        <h3>3. 标记  - 整理算法</h3><p>标记操作和“标记-清除”算法一致，后续操作不只是直接清理对象，而是在清理无用对象完成后让所有存活的对象都向一端移动，并更新引用其对象的指针。</p><p>主要缺点：</p><p>在标记-清除的基础上还需进行对象的移动，成本相对较高，好处则是不会产生内存碎片。</p>
        <img src="../images/class2_6.jpg">
        <img src="../images/class2_7.jpg">
        <h3>引用计数收集器</h3><p>引用计数收集器采用的是分散式管理方式，通过计数器记录对象是否被引用。当计数器为0时说明此对象不在被使用，可以被回收。</p><p>主要缺点：</p><p>循环引用的场景下无法实现回收，例如下面的图中，ObjectC和ObjectB相互引用，那么ObjectA即便释放了对ObjectC、ObjectB的引用，也无法回收。sunJDK在实现GC时未采用这种方式。</p>
        <img src="../images/class2_8.jpg">
        </div></section></div></body></html>