<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>Zhangtejun.GitHub.io by zhangtejun</title>
    <link rel="stylesheet" href="../stylesheets/styles.css">
    <link rel="stylesheet" href="../stylesheets/github-dark.css">
    <script src="../javascripts/jquery.min.js"></script>
    <script src="../javascripts/respond.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <!--[if lt IE 8]>
    <link rel="stylesheet" href="stylesheets/ie.css">
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  </head>
  <body>
      <div id="header">
        <nav>
          <li class="fork"><a href="https://github.com/zhangtejun">View On GitHub</a></li>
        </nav>
      </div><!-- end header -->

    <div class="wrapper">
        <section>
        <div style="float: left;overflow: hidden;width: 15%;margin-top: 70px;padding: 20px 20px;max-width: 250px;">
          <div>目录</div>
          <div style="list-style-type:none!important;">        
              <li>1，<a href="">README</a></li>
              <li><a href="">1，README</a></li>           
          </div>
        </div>
<div style="overflow: hidden;padding-left: 20px;width: 60%">

        <div id="title">
          <p>Java虚拟机学习（9）：对象引用强度</p>
          <hr>
          <span class="credits left">Project maintained by <a href="https://github.com/zhangtejun">zhangtejun</a></span>
          <span class="credits right">Hosted on GitHub Pages &mdash; Theme by <a href="https://twitter.com/michigangraham">mattgraham</a></span>
        </div>
<p>无论是通过计数算法判断对象的引用数量，还是通过根搜索算法判断对象引用链是否可达，判定对象是否存活都与“引用”相关。</p><p>引用主要分为 ：强引用(Strong Reference)、软引用(Soft Reference)、弱引用(Weak Reference)、虚引用(PhantomReference) 四种，引用的强度依次骤减。</p><h3>强引用</h3><p>就是指在代码之中普遍存在的，类似：“Object objectRef = new Obejct”，这种引用，只要强引用还存在，永远不会被GC清理。</p><h3>软引用</h3><p>用来描述一些还有用，但并非必须存在的对象，当Jvm内存不足时（内存溢出之前）会被回收，如果执行GC后，还是没有足够的空间，才会抛出内存溢出异常。</p><p>通过SoftReference类来实现软引用，SoftReference很适合用于实现缓存。另，当GC认为扫描的SoftReference不经常使用时，可会进行回收。</p><p>使用方法：</p>
<pre>
User user = new User();  
SoftReference<Object> softReference  = new SoftReference<Object>(user);  
softReference.get();
</pre>
<h3>弱引用</h3><p>弱引用也是用来描述一些还有用，但并非必须存在的对象，它的强度会被软引用弱些，被弱引用关联的对象，只能生存到下一次GC前，当GC工作时，无论内存是否足够，都会回收掉弱引用关联的对象。JDK通过WeakReference类来实现。</p><p>当获取时，可通过weakReference.get方法获取，可能返回null</p><p>可传入一个ReferenceQueue对象到WeakReference构造，当引用对象被表示为可回收时，isEnqueued返回true</p>
<pre>
User user = new User();  
WeakReference<User> weakReference = new WeakReference<User>(user);  
weakReference.get();  
ReferenceQueue<User> referenceQueue = new ReferenceQueue<User>();  
WeakReference<User> weakReference2 = new WeakReference<User>(user, referenceQueue);  
//当引用对象被标识为可回收时  返回true,  即当user对象标识为可回收时，返回true  
weakReference.isEnqueued();
</pre>

<h3>虚引用</h3><p>虚引用称为“幻影引用”，它是最弱的一种引用关系，一个对象是否有虚引用的存在，完全不会对生存时间构成影响。为一个对象设置虚引用关联的唯一目的就是希望能在这个对象被GC回收时收到一个系统通知。通过PhantomReference类实现。</p><p>值得注意的是：phantomReference.get方法永远返回null, 当user从内存中删除时，调用isEnqueued会返回true</p>

<p>
<pre>
User user = new User();  
ReferenceQueue<User> referenceQueue = new ReferenceQueue<User>();  
PhantomReference<User>  phantomReference = new PhantomReference<User>(user, referenceQueue);  
//即当user对象标识为可回收时，返回true  
System.out.println(phantomReference.isEnqueued());  
//永远返回null  
System.out.println(phantomReference.get());
</pre>
</p><p>其他相关类：</p>
<pre>
WeakCache weakCache  = new WeakCache();  
SoftCache softCache = new SoftCache();  
WeakHashMap weakHashMap  = new WeakHashMap();
</pre>
<p>当垃圾回收机制运行，扫描引用关系，GC会对这三种类型的引用进行不同的处理，简单来说，GC首先会判断所扫描到的引用是否为Reference类型，如果为Reference类型，且其所引用的对象无强引用，则认为该对象为相应的Reference类型，之后GC在垃圾回收时这些对象则根据Reference类型的不同进行相应处理。</p></div></section></div></body></html>